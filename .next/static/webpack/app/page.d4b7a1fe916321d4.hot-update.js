"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: function() { return /* binding */ Environment; },\n/* harmony export */   EnvironmentCube: function() { return /* binding */ EnvironmentCube; },\n/* harmony export */   EnvironmentMap: function() { return /* binding */ EnvironmentMap; },\n/* harmony export */   EnvironmentPortal: function() { return /* binding */ EnvironmentPortal; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/useEnvironment.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\n\n\n\n\n\n\nconst isRef = (obj)=>obj.current && obj.current.isScene;\nconst resolveScene = (scene)=>isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture) {\n    let blur = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    // @ts-ignore\n    const oldBlur = target.backgroundBlurriness || 0;\n    if (background !== \"only\") target.environment = texture;\n    if (background) target.background = texture;\n    // @ts-ignore\n    if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = blur;\n    return ()=>{\n        if (background !== \"only\") target.environment = oldenv;\n        if (background) target.background = oldbg;\n        // @ts-ignore\n        if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = oldBlur;\n    };\n}\nfunction EnvironmentMap(param) {\n    let { scene, background = false, blur, map } = param;\n    _s();\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (map) return setEnvProps(background, scene, defaultScene, map, blur);\n    }, [\n        defaultScene,\n        scene,\n        map,\n        background,\n        blur\n    ]);\n    return null;\n}\n_s(EnvironmentMap, \"3vRjfNX3tHG4rc5nxiu2WUPVaBU=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A\n    ];\n});\n_c = EnvironmentMap;\nfunction EnvironmentCube(param) {\n    let { background = false, scene, blur, ...rest } = param;\n    _s1();\n    const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        return setEnvProps(background, scene, defaultScene, texture, blur);\n    }, [\n        texture,\n        background,\n        scene,\n        defaultScene,\n        blur\n    ]);\n    return null;\n}\n_s1(EnvironmentCube, \"Bt6geZNjOJqNDXXTA401hDTtzx4=\", false, function() {\n    return [\n        _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A\n    ];\n});\n_c1 = EnvironmentCube;\nfunction EnvironmentPortal(param) {\n    let { children, near = 1, far = 1000, resolution = 256, frames = 1, map, background = false, blur, scene, files, path, preset = undefined, extensions } = param;\n    _s2();\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n    const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n        fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n        return fbo;\n    }, [\n        resolution\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (frames === 1) camera.current.update(gl, virtualScene);\n        return setEnvProps(background, scene, defaultScene, fbo.texture, blur);\n    }, [\n        children,\n        virtualScene,\n        fbo.texture,\n        scene,\n        defaultScene,\n        background,\n        frames,\n        gl\n    ]);\n    let count = 1;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (frames === Infinity || count < frames) {\n            camera.current.update(gl, virtualScene);\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.g)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n        ref: camera,\n        args: [\n            near,\n            far,\n            fbo\n        ]\n    }), files || preset ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n        background: true,\n        files: files,\n        preset: preset,\n        path: path,\n        extensions: extensions\n    }) : map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n        background: true,\n        map: map,\n        extensions: extensions\n    }) : null), virtualScene));\n}\n_s2(EnvironmentPortal, \"CRFYVg7huSIX2iBf3Jfdym5K3LE=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A,\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C\n    ];\n});\n_c2 = EnvironmentPortal;\nfunction EnvironmentGround(props) {\n    _s3();\n    var _props$ground, _props$ground2, _scale, _props$ground3;\n    const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n    const texture = props.map || textureDefault;\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n            GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n        }), []);\n    const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            texture\n        ], [\n        texture\n    ]);\n    const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n    const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n    const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        map: texture\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n        args: args,\n        scale: scale,\n        height: height,\n        radius: radius\n    }));\n}\n_s3(EnvironmentGround, \"ynUbUh5y1eDvivs9syqoYGI9MMA=\", false, function() {\n    return [\n        _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment\n    ];\n});\n_c3 = EnvironmentGround;\nfunction Environment(props) {\n    return props.ground ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n_c4 = Environment;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"EnvironmentMap\");\n$RefreshReg$(_c1, \"EnvironmentCube\");\n$RefreshReg$(_c2, \"EnvironmentPortal\");\n$RefreshReg$(_c3, \"EnvironmentGround\");\n$RefreshReg$(_c4, \"Environment\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0Vudmlyb25tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMrQztBQUNWO0FBQ2xCO0FBQ0c7QUFFckQsTUFBTVcsUUFBUUMsQ0FBQUEsTUFBT0EsSUFBSUMsT0FBTyxJQUFJRCxJQUFJQyxPQUFPLENBQUNDLE9BQU87QUFDdkQsTUFBTUMsZUFBZUMsQ0FBQUEsUUFBU0wsTUFBTUssU0FBU0EsTUFBTUgsT0FBTyxHQUFHRztBQUM3RCxTQUFTQyxZQUFZQyxVQUFVLEVBQUVGLEtBQUssRUFBRUcsWUFBWSxFQUFFQyxPQUFPO1FBQUVDLE9BQUFBLGlFQUFPO0lBQ3BFLE1BQU1DLFNBQVNQLGFBQWFDLFNBQVNHO0lBQ3JDLE1BQU1JLFFBQVFELE9BQU9KLFVBQVU7SUFDL0IsTUFBTU0sU0FBU0YsT0FBT0csV0FBVztJQUNqQyxhQUFhO0lBQ2IsTUFBTUMsVUFBVUosT0FBT0ssb0JBQW9CLElBQUk7SUFDL0MsSUFBSVQsZUFBZSxRQUFRSSxPQUFPRyxXQUFXLEdBQUdMO0lBQ2hELElBQUlGLFlBQVlJLE9BQU9KLFVBQVUsR0FBR0U7SUFDcEMsYUFBYTtJQUNiLElBQUlGLGNBQWNJLE9BQU9LLG9CQUFvQixLQUFLQyxXQUFXTixPQUFPSyxvQkFBb0IsR0FBR047SUFDM0YsT0FBTztRQUNMLElBQUlILGVBQWUsUUFBUUksT0FBT0csV0FBVyxHQUFHRDtRQUNoRCxJQUFJTixZQUFZSSxPQUFPSixVQUFVLEdBQUdLO1FBQ3BDLGFBQWE7UUFDYixJQUFJTCxjQUFjSSxPQUFPSyxvQkFBb0IsS0FBS0MsV0FBV04sT0FBT0ssb0JBQW9CLEdBQUdEO0lBQzdGO0FBQ0Y7QUFDQSxTQUFTRyxlQUFlLEtBS3ZCO1FBTHVCLEVBQ3RCYixLQUFLLEVBQ0xFLGFBQWEsS0FBSyxFQUNsQkcsSUFBSSxFQUNKUyxHQUFHLEVBQ0osR0FMdUI7O0lB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UUFBUUE7UUFDUkUsUUFBUUE7SUFDVjtBQUNGO0lBbkJTVjs7UUFFZ0JsRCw4REFBY0E7OztNQUY5QmtEO0FBb0JULFNBQVNZLFlBQVlYLEtBQUs7SUFDeEIsT0FBT0EsTUFBTVEsTUFBTSxHQUFHLFdBQVcsR0FBRXBFLGdEQUFtQixDQUFDMkQsbUJBQW1CQyxTQUFTQSxNQUFNL0IsR0FBRyxHQUFHLFdBQVcsR0FBRTdCLGdEQUFtQixDQUFDNEIsZ0JBQWdCZ0MsU0FBU0EsTUFBTXpCLFFBQVEsR0FBRyxXQUFXLEdBQUVuQyxnREFBbUIsQ0FBQ2tDLG1CQUFtQjBCLFNBQVMsV0FBVyxHQUFFNUQsZ0RBQW1CLENBQUNnQyxpQkFBaUI0QjtBQUMzUjtNQUZTVztBQUlrRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcz82MDQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRocmVlLCB1c2VGcmFtZSwgY3JlYXRlUG9ydGFsLCBleHRlbmQgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgU2NlbmUsIFdlYkdMQ3ViZVJlbmRlclRhcmdldCwgSGFsZkZsb2F0VHlwZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEdyb3VuZFByb2plY3RlZEVudiB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyB1c2VFbnZpcm9ubWVudCB9IGZyb20gJy4vdXNlRW52aXJvbm1lbnQuanMnO1xuXG5jb25zdCBpc1JlZiA9IG9iaiA9PiBvYmouY3VycmVudCAmJiBvYmouY3VycmVudC5pc1NjZW5lO1xuY29uc3QgcmVzb2x2ZVNjZW5lID0gc2NlbmUgPT4gaXNSZWYoc2NlbmUpID8gc2NlbmUuY3VycmVudCA6IHNjZW5lO1xuZnVuY3Rpb24gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgdGV4dHVyZSwgYmx1ciA9IDApIHtcbiAgY29uc3QgdGFyZ2V0ID0gcmVzb2x2ZVNjZW5lKHNjZW5lIHx8IGRlZmF1bHRTY2VuZSk7XG4gIGNvbnN0IG9sZGJnID0gdGFyZ2V0LmJhY2tncm91bmQ7XG4gIGNvbnN0IG9sZGVudiA9IHRhcmdldC5lbnZpcm9ubWVudDtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBvbGRCbHVyID0gdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzIHx8IDA7XG4gIGlmIChiYWNrZ3JvdW5kICE9PSAnb25seScpIHRhcmdldC5lbnZpcm9ubWVudCA9IHRleHR1cmU7XG4gIGlmIChiYWNrZ3JvdW5kKSB0YXJnZXQuYmFja2dyb3VuZCA9IHRleHR1cmU7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGJhY2tncm91bmQgJiYgdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzICE9PSB1bmRlZmluZWQpIHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IGJsdXI7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGJhY2tncm91bmQgIT09ICdvbmx5JykgdGFyZ2V0LmVudmlyb25tZW50ID0gb2xkZW52O1xuICAgIGlmIChiYWNrZ3JvdW5kKSB0YXJnZXQuYmFja2dyb3VuZCA9IG9sZGJnO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoYmFja2dyb3VuZCAmJiB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgIT09IHVuZGVmaW5lZCkgdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzID0gb2xkQmx1cjtcbiAgfTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50TWFwKHtcbiAgc2NlbmUsXG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgYmx1cixcbiAgbWFwXG59KSB7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwKSByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgbWFwLCBibHVyKTtcbiAgfSwgW2RlZmF1bHRTY2VuZSwgc2NlbmUsIG1hcCwgYmFja2dyb3VuZCwgYmx1cl0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50Q3ViZSh7XG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgc2NlbmUsXG4gIGJsdXIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgdGV4dHVyZSA9IHVzZUVudmlyb25tZW50KHJlc3QpO1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIHRleHR1cmUsIGJsdXIpO1xuICB9LCBbdGV4dHVyZSwgYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgYmx1cl0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50UG9ydGFsKHtcbiAgY2hpbGRyZW4sXG4gIG5lYXIgPSAxLFxuICBmYXIgPSAxMDAwLFxuICByZXNvbHV0aW9uID0gMjU2LFxuICBmcmFtZXMgPSAxLFxuICBtYXAsXG4gIGJhY2tncm91bmQgPSBmYWxzZSxcbiAgYmx1cixcbiAgc2NlbmUsXG4gIGZpbGVzLFxuICBwYXRoLFxuICBwcmVzZXQgPSB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnNcbn0pIHtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgY29uc3QgY2FtZXJhID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbdmlydHVhbFNjZW5lXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBTY2VuZSgpKTtcbiAgY29uc3QgZmJvID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZmJvID0gbmV3IFdlYkdMQ3ViZVJlbmRlclRhcmdldChyZXNvbHV0aW9uKTtcbiAgICBmYm8udGV4dHVyZS50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICByZXR1cm4gZmJvO1xuICB9LCBbcmVzb2x1dGlvbl0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChmcmFtZXMgPT09IDEpIGNhbWVyYS5jdXJyZW50LnVwZGF0ZShnbCwgdmlydHVhbFNjZW5lKTtcbiAgICByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgZmJvLnRleHR1cmUsIGJsdXIpO1xuICB9LCBbY2hpbGRyZW4sIHZpcnR1YWxTY2VuZSwgZmJvLnRleHR1cmUsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIGJhY2tncm91bmQsIGZyYW1lcywgZ2xdKTtcbiAgbGV0IGNvdW50ID0gMTtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGlmIChmcmFtZXMgPT09IEluZmluaXR5IHx8IGNvdW50IDwgZnJhbWVzKSB7XG4gICAgICBjYW1lcmEuY3VycmVudC51cGRhdGUoZ2wsIHZpcnR1YWxTY2VuZSk7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiY3ViZUNhbWVyYVwiLCB7XG4gICAgcmVmOiBjYW1lcmEsXG4gICAgYXJnczogW25lYXIsIGZhciwgZmJvXVxuICB9KSwgZmlsZXMgfHwgcHJlc2V0ID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRDdWJlLCB7XG4gICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICBmaWxlczogZmlsZXMsXG4gICAgcHJlc2V0OiBwcmVzZXQsXG4gICAgcGF0aDogcGF0aCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zXG4gIH0pIDogbWFwID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIHtcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIG1hcDogbWFwLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNcbiAgfSkgOiBudWxsKSwgdmlydHVhbFNjZW5lKSk7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudEdyb3VuZChwcm9wcykge1xuICB2YXIgX3Byb3BzJGdyb3VuZCwgX3Byb3BzJGdyb3VuZDIsIF9zY2FsZSwgX3Byb3BzJGdyb3VuZDM7XG4gIGNvbnN0IHRleHR1cmVEZWZhdWx0ID0gdXNlRW52aXJvbm1lbnQocHJvcHMpO1xuICBjb25zdCB0ZXh0dXJlID0gcHJvcHMubWFwIHx8IHRleHR1cmVEZWZhdWx0O1xuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZCh7XG4gICAgR3JvdW5kUHJvamVjdGVkRW52SW1wbDogR3JvdW5kUHJvamVjdGVkRW52XG4gIH0pLCBbXSk7XG4gIGNvbnN0IGFyZ3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IFt0ZXh0dXJlXSwgW3RleHR1cmVdKTtcbiAgY29uc3QgaGVpZ2h0ID0gKF9wcm9wcyRncm91bmQgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kLmhlaWdodDtcbiAgY29uc3QgcmFkaXVzID0gKF9wcm9wcyRncm91bmQyID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZDIucmFkaXVzO1xuICBjb25zdCBzY2FsZSA9IChfc2NhbGUgPSAoX3Byb3BzJGdyb3VuZDMgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kMy5zY2FsZSkgIT09IG51bGwgJiYgX3NjYWxlICE9PSB2b2lkIDAgPyBfc2NhbGUgOiAxMDAwO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBtYXA6IHRleHR1cmVcbiAgfSkpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VuZFByb2plY3RlZEVudkltcGxcIiwge1xuICAgIGFyZ3M6IGFyZ3MsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHJhZGl1czogcmFkaXVzXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50KHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5ncm91bmQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEdyb3VuZCwgcHJvcHMpIDogcHJvcHMubWFwID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIHByb3BzKSA6IHByb3BzLmNoaWxkcmVuID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRQb3J0YWwsIHByb3BzKSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50Q3ViZSwgcHJvcHMpO1xufVxuXG5leHBvcnQgeyBFbnZpcm9ubWVudCwgRW52aXJvbm1lbnRDdWJlLCBFbnZpcm9ubWVudE1hcCwgRW52aXJvbm1lbnRQb3J0YWwgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwidXNlVGhyZWUiLCJ1c2VGcmFtZSIsImNyZWF0ZVBvcnRhbCIsImV4dGVuZCIsIlNjZW5lIiwiV2ViR0xDdWJlUmVuZGVyVGFyZ2V0IiwiSGFsZkZsb2F0VHlwZSIsIkdyb3VuZFByb2plY3RlZEVudiIsInVzZUVudmlyb25tZW50IiwiaXNSZWYiLCJvYmoiLCJjdXJyZW50IiwiaXNTY2VuZSIsInJlc29sdmVTY2VuZSIsInNjZW5lIiwic2V0RW52UHJvcHMiLCJiYWNrZ3JvdW5kIiwiZGVmYXVsdFNjZW5lIiwidGV4dHVyZSIsImJsdXIiLCJ0YXJnZXQiLCJvbGRiZyIsIm9sZGVudiIsImVudmlyb25tZW50Iiwib2xkQmx1ciIsImJhY2tncm91bmRCbHVycmluZXNzIiwidW5kZWZpbmVkIiwiRW52aXJvbm1lbnRNYXAiLCJtYXAiLCJzdGF0ZSIsInVzZUxheW91dEVmZmVjdCIsIkVudmlyb25tZW50Q3ViZSIsInJlc3QiLCJFbnZpcm9ubWVudFBvcnRhbCIsImNoaWxkcmVuIiwibmVhciIsImZhciIsInJlc29sdXRpb24iLCJmcmFtZXMiLCJmaWxlcyIsInBhdGgiLCJwcmVzZXQiLCJleHRlbnNpb25zIiwiZ2wiLCJjYW1lcmEiLCJ1c2VSZWYiLCJ2aXJ0dWFsU2NlbmUiLCJ1c2VTdGF0ZSIsImZibyIsInVzZU1lbW8iLCJ0eXBlIiwidXBkYXRlIiwiY291bnQiLCJJbmZpbml0eSIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInJlZiIsImFyZ3MiLCJFbnZpcm9ubWVudEdyb3VuZCIsInByb3BzIiwiX3Byb3BzJGdyb3VuZCIsIl9wcm9wcyRncm91bmQyIiwiX3NjYWxlIiwiX3Byb3BzJGdyb3VuZDMiLCJ0ZXh0dXJlRGVmYXVsdCIsIkdyb3VuZFByb2plY3RlZEVudkltcGwiLCJoZWlnaHQiLCJncm91bmQiLCJyYWRpdXMiLCJzY2FsZSIsIkVudmlyb25tZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Environment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: function() { return /* binding */ useEnvironment; }\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst CUBEMAP_ROOT = \"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\";\nconst isArray = (arr)=>Array.isArray(arr);\nfunction useEnvironment() {\n    let { files = [\n        \"/px.png\",\n        \"/nx.png\",\n        \"/py.png\",\n        \"/ny.png\",\n        \"/pz.png\",\n        \"/nz.png\"\n    ], path = \"\", preset = undefined, encoding = undefined, extensions } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s();\n    var _files$split$pop;\n    let loader = null;\n    let isCubeMap = false;\n    let extension;\n    if (preset) {\n        if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj)) throw new Error(\"Preset must be one of: \" + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj).join(\", \"));\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    // Everything else\n    isCubeMap = isArray(files);\n    extension = isArray(files) ? \"cube\" : files.startsWith(\"data:application/exr\") ? \"exr\" : files.startsWith(\"data:application/hdr\") ? \"hdr\" : (_files$split$pop = files.split(\".\").pop()) == null || (_files$split$pop = _files$split$pop.split(\"?\")) == null || (_files$split$pop = _files$split$pop.shift()) == null ? void 0 : _files$split$pop.toLowerCase();\n    loader = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeTextureLoader : extension === \"hdr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_2__.RGBELoader : extension === \"exr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_3__.EXRLoader : null;\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(// @ts-expect-error\n    loader, isCubeMap ? [\n        files\n    ] : files, (loader)=>{\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n    const texture = isCubeMap ? // @ts-ignore\n    loaderResult[0] : loaderResult;\n    texture.mapping = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_1__.EquirectangularReflectionMapping;\n    const sRGBEncoding = 3001;\n    const LinearEncoding = 3000;\n    if (\"colorSpace\" in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? \"srgb\" : \"srgb-linear\";\n    else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? sRGBEncoding : LinearEncoding;\n    return texture;\n}\n_s(useEnvironment, \"6DxXcMUiWfDrxhvWVwWmZ/Hz/qc=\", false, function() {\n    return [\n        _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F\n    ];\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3VzZUVudmlyb25tZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBK0M7QUFDb0Q7QUFDOUM7QUFDUztBQUU5RCxNQUFNTyxlQUFlO0FBQ3JCLE1BQU1DLFVBQVVDLENBQUFBLE1BQU9DLE1BQU1GLE9BQU8sQ0FBQ0M7QUFDckMsU0FBU0U7UUFBZSxFQUN0QkMsUUFBUTtRQUFDO1FBQVc7UUFBVztRQUFXO1FBQVc7UUFBVztLQUFVLEVBQzFFQyxPQUFPLEVBQUUsRUFDVEMsU0FBU0MsU0FBUyxFQUNsQkMsV0FBV0QsU0FBUyxFQUNwQkUsVUFBVSxFQUNYLEdBTnVCLGlFQU1wQixDQUFDOztJQUNILElBQUlDO0lBQ0osSUFBSUMsU0FBUztJQUNiLElBQUlDLFlBQVk7SUFDaEIsSUFBSUM7SUFDSixJQUFJUCxRQUFRO1FBQ1YsSUFBSSxDQUFFQSxDQUFBQSxVQUFVUixzRUFBUyxHQUFJLE1BQU0sSUFBSWdCLE1BQU0sNEJBQTRCQyxPQUFPQyxJQUFJLENBQUNsQixzRUFBVUEsRUFBRW1CLElBQUksQ0FBQztRQUN0R2IsUUFBUU4sc0VBQVUsQ0FBQ1EsT0FBTztRQUMxQkQsT0FBT047SUFDVDtJQUVBLGtCQUFrQjtJQUNsQmEsWUFBWVosUUFBUUk7SUFDcEJTLFlBQVliLFFBQVFJLFNBQVMsU0FBU0EsTUFBTWMsVUFBVSxDQUFDLDBCQUEwQixRQUFRZCxNQUFNYyxVQUFVLENBQUMsMEJBQTBCLFFBQVEsQ0FBQ1IsbUJBQW1CTixNQUFNZSxLQUFLLENBQUMsS0FBS0MsR0FBRyxFQUFDLEtBQU0sUUFBUSxDQUFDVixtQkFBbUJBLGlCQUFpQlMsS0FBSyxDQUFDLElBQUcsS0FBTSxRQUFRLENBQUNULG1CQUFtQkEsaUJBQWlCVyxLQUFLLEVBQUMsS0FBTSxPQUFPLEtBQUssSUFBSVgsaUJBQWlCWSxXQUFXO0lBQzVWWCxTQUFTQyxZQUFZakIsb0RBQWlCQSxHQUFHa0IsY0FBYyxRQUFRakIsb0RBQVVBLEdBQUdpQixjQUFjLFFBQVFoQixtREFBU0EsR0FBRztJQUM5RyxJQUFJLENBQUNjLFFBQVEsTUFBTSxJQUFJRyxNQUFNLGtEQUFrRFY7SUFDL0UsTUFBTW1CLGVBQWUvQixxREFBU0EsQ0FDOUIsbUJBQW1CO0lBQ25CbUIsUUFBUUMsWUFBWTtRQUFDUjtLQUFNLEdBQUdBLE9BQU9PLENBQUFBO1FBQ25DQSxPQUFPYSxPQUFPLElBQUksUUFBUWIsT0FBT2EsT0FBTyxDQUFDbkI7UUFDekMsSUFBSUksWUFBWUEsV0FBV0U7SUFDN0I7SUFDQSxNQUFNYyxVQUFVYixZQUNoQixhQUFhO0lBQ2JXLFlBQVksQ0FBQyxFQUFFLEdBQUdBO0lBQ2xCRSxRQUFRQyxPQUFPLEdBQUdkLFlBQVluQix3REFBcUJBLEdBQUdDLG1FQUFnQ0E7SUFDdEYsTUFBTWlDLGVBQWU7SUFDckIsTUFBTUMsaUJBQWlCO0lBQ3ZCLElBQUksZ0JBQWdCSCxTQUFTQSxRQUFRSSxVQUFVLEdBQUcsQ0FBQ3JCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVdJLFNBQVEsSUFBSyxTQUFTO1NBQW1CYSxRQUFRakIsUUFBUSxHQUFHLENBQUNBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVdJLFNBQVEsSUFBS2UsZUFBZUM7SUFDeFAsT0FBT0g7QUFDVDtHQXBDU3RCOztRQXNCY1gsaURBQVNBOzs7QUFnQk4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvdXNlRW52aXJvbm1lbnQuanM/NzBjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VMb2FkZXIgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLCBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZywgQ3ViZVRleHR1cmVMb2FkZXIgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBSR0JFTG9hZGVyLCBFWFJMb2FkZXIgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgcHJlc2V0c09iaiB9IGZyb20gJy4uL2hlbHBlcnMvZW52aXJvbm1lbnQtYXNzZXRzLmpzJztcblxuY29uc3QgQ1VCRU1BUF9ST09UID0gJ2h0dHBzOi8vcmF3LmdpdGhhY2suY29tL3BtbmRycy9kcmVpLWFzc2V0cy80NTYwNjBhMjZiYmViOGZkZjc5MzI2ZjIyNGI2ZDk5YjhiY2NlNzM2L2hkcmkvJztcbmNvbnN0IGlzQXJyYXkgPSBhcnIgPT4gQXJyYXkuaXNBcnJheShhcnIpO1xuZnVuY3Rpb24gdXNlRW52aXJvbm1lbnQoe1xuICBmaWxlcyA9IFsnL3B4LnBuZycsICcvbngucG5nJywgJy9weS5wbmcnLCAnL255LnBuZycsICcvcHoucG5nJywgJy9uei5wbmcnXSxcbiAgcGF0aCA9ICcnLFxuICBwcmVzZXQgPSB1bmRlZmluZWQsXG4gIGVuY29kaW5nID0gdW5kZWZpbmVkLFxuICBleHRlbnNpb25zXG59ID0ge30pIHtcbiAgdmFyIF9maWxlcyRzcGxpdCRwb3A7XG4gIGxldCBsb2FkZXIgPSBudWxsO1xuICBsZXQgaXNDdWJlTWFwID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb247XG4gIGlmIChwcmVzZXQpIHtcbiAgICBpZiAoIShwcmVzZXQgaW4gcHJlc2V0c09iaikpIHRocm93IG5ldyBFcnJvcignUHJlc2V0IG11c3QgYmUgb25lIG9mOiAnICsgT2JqZWN0LmtleXMocHJlc2V0c09iaikuam9pbignLCAnKSk7XG4gICAgZmlsZXMgPSBwcmVzZXRzT2JqW3ByZXNldF07XG4gICAgcGF0aCA9IENVQkVNQVBfUk9PVDtcbiAgfVxuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZVxuICBpc0N1YmVNYXAgPSBpc0FycmF5KGZpbGVzKTtcbiAgZXh0ZW5zaW9uID0gaXNBcnJheShmaWxlcykgPyAnY3ViZScgOiBmaWxlcy5zdGFydHNXaXRoKCdkYXRhOmFwcGxpY2F0aW9uL2V4cicpID8gJ2V4cicgOiBmaWxlcy5zdGFydHNXaXRoKCdkYXRhOmFwcGxpY2F0aW9uL2hkcicpID8gJ2hkcicgOiAoX2ZpbGVzJHNwbGl0JHBvcCA9IGZpbGVzLnNwbGl0KCcuJykucG9wKCkpID09IG51bGwgfHwgKF9maWxlcyRzcGxpdCRwb3AgPSBfZmlsZXMkc3BsaXQkcG9wLnNwbGl0KCc/JykpID09IG51bGwgfHwgKF9maWxlcyRzcGxpdCRwb3AgPSBfZmlsZXMkc3BsaXQkcG9wLnNoaWZ0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfZmlsZXMkc3BsaXQkcG9wLnRvTG93ZXJDYXNlKCk7XG4gIGxvYWRlciA9IGlzQ3ViZU1hcCA/IEN1YmVUZXh0dXJlTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnaGRyJyA/IFJHQkVMb2FkZXIgOiBleHRlbnNpb24gPT09ICdleHInID8gRVhSTG9hZGVyIDogbnVsbDtcbiAgaWYgKCFsb2FkZXIpIHRocm93IG5ldyBFcnJvcigndXNlRW52aXJvbm1lbnQ6IFVucmVjb2duaXplZCBmaWxlIGV4dGVuc2lvbjogJyArIGZpbGVzKTtcbiAgY29uc3QgbG9hZGVyUmVzdWx0ID0gdXNlTG9hZGVyKFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGxvYWRlciwgaXNDdWJlTWFwID8gW2ZpbGVzXSA6IGZpbGVzLCBsb2FkZXIgPT4ge1xuICAgIGxvYWRlci5zZXRQYXRoID09IG51bGwgfHwgbG9hZGVyLnNldFBhdGgocGF0aCk7XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgfSk7XG4gIGNvbnN0IHRleHR1cmUgPSBpc0N1YmVNYXAgP1xuICAvLyBAdHMtaWdub3JlXG4gIGxvYWRlclJlc3VsdFswXSA6IGxvYWRlclJlc3VsdDtcbiAgdGV4dHVyZS5tYXBwaW5nID0gaXNDdWJlTWFwID8gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIDogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc7XG4gIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgaWYgKCdjb2xvclNwYWNlJyBpbiB0ZXh0dXJlKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcgIT09IHZvaWQgMCA/IGVuY29kaW5nIDogaXNDdWJlTWFwKSA/ICdzcmdiJyA6ICdzcmdiLWxpbmVhcic7ZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gKGVuY29kaW5nICE9PSBudWxsICYmIGVuY29kaW5nICE9PSB2b2lkIDAgPyBlbmNvZGluZyA6IGlzQ3ViZU1hcCkgPyBzUkdCRW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcbiAgcmV0dXJuIHRleHR1cmU7XG59XG5cbmV4cG9ydCB7IHVzZUVudmlyb25tZW50IH07XG4iXSwibmFtZXMiOlsidXNlTG9hZGVyIiwiQ3ViZVJlZmxlY3Rpb25NYXBwaW5nIiwiRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmciLCJDdWJlVGV4dHVyZUxvYWRlciIsIlJHQkVMb2FkZXIiLCJFWFJMb2FkZXIiLCJwcmVzZXRzT2JqIiwiQ1VCRU1BUF9ST09UIiwiaXNBcnJheSIsImFyciIsIkFycmF5IiwidXNlRW52aXJvbm1lbnQiLCJmaWxlcyIsInBhdGgiLCJwcmVzZXQiLCJ1bmRlZmluZWQiLCJlbmNvZGluZyIsImV4dGVuc2lvbnMiLCJfZmlsZXMkc3BsaXQkcG9wIiwibG9hZGVyIiwiaXNDdWJlTWFwIiwiZXh0ZW5zaW9uIiwiRXJyb3IiLCJPYmplY3QiLCJrZXlzIiwiam9pbiIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsInBvcCIsInNoaWZ0IiwidG9Mb3dlckNhc2UiLCJsb2FkZXJSZXN1bHQiLCJzZXRQYXRoIiwidGV4dHVyZSIsIm1hcHBpbmciLCJzUkdCRW5jb2RpbmciLCJMaW5lYXJFbmNvZGluZyIsImNvbG9yU3BhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/useEnvironment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: function() { return /* binding */ presetsObj; }\n/* harmony export */ });\nconst presetsObj = {\n    apartment: \"lebombo_1k.hdr\",\n    city: \"potsdamer_platz_1k.hdr\",\n    dawn: \"kiara_1_dawn_1k.hdr\",\n    forest: \"forest_slope_1k.hdr\",\n    lobby: \"st_fagans_interior_1k.hdr\",\n    night: \"dikhololo_night_1k.hdr\",\n    park: \"rooitou_park_1k.hdr\",\n    studio: \"studio_small_03_1k.hdr\",\n    sunset: \"venice_sunset_1k.hdr\",\n    warehouse: \"empty_warehouse_01_1k.hdr\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9oZWxwZXJzL2Vudmlyb25tZW50LWFzc2V0cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsYUFBYTtJQUNqQkMsV0FBVztJQUNYQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsV0FBVztBQUNiO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9oZWxwZXJzL2Vudmlyb25tZW50LWFzc2V0cy5qcz8xNjUxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHByZXNldHNPYmogPSB7XG4gIGFwYXJ0bWVudDogJ2xlYm9tYm9fMWsuaGRyJyxcbiAgY2l0eTogJ3BvdHNkYW1lcl9wbGF0el8xay5oZHInLFxuICBkYXduOiAna2lhcmFfMV9kYXduXzFrLmhkcicsXG4gIGZvcmVzdDogJ2ZvcmVzdF9zbG9wZV8xay5oZHInLFxuICBsb2JieTogJ3N0X2ZhZ2Fuc19pbnRlcmlvcl8xay5oZHInLFxuICBuaWdodDogJ2Rpa2hvbG9sb19uaWdodF8xay5oZHInLFxuICBwYXJrOiAncm9vaXRvdV9wYXJrXzFrLmhkcicsXG4gIHN0dWRpbzogJ3N0dWRpb19zbWFsbF8wM18xay5oZHInLFxuICBzdW5zZXQ6ICd2ZW5pY2Vfc3Vuc2V0XzFrLmhkcicsXG4gIHdhcmVob3VzZTogJ2VtcHR5X3dhcmVob3VzZV8wMV8xay5oZHInXG59O1xuXG5leHBvcnQgeyBwcmVzZXRzT2JqIH07XG4iXSwibmFtZXMiOlsicHJlc2V0c09iaiIsImFwYXJ0bWVudCIsImNpdHkiLCJkYXduIiwiZm9yZXN0IiwibG9iYnkiLCJuaWdodCIsInBhcmsiLCJzdHVkaW8iLCJzdW5zZXQiLCJ3YXJlaG91c2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/helpers/environment-assets.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/fflate/esm/browser.js":
/*!********************************************!*\
  !*** ./node_modules/fflate/esm/browser.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: function() { return /* binding */ AsyncGzip; },\n/* harmony export */   AsyncDecompress: function() { return /* binding */ AsyncDecompress; },\n/* harmony export */   AsyncDeflate: function() { return /* binding */ AsyncDeflate; },\n/* harmony export */   AsyncGunzip: function() { return /* binding */ AsyncGunzip; },\n/* harmony export */   AsyncGzip: function() { return /* binding */ AsyncGzip; },\n/* harmony export */   AsyncInflate: function() { return /* binding */ AsyncInflate; },\n/* harmony export */   AsyncUnzipInflate: function() { return /* binding */ AsyncUnzipInflate; },\n/* harmony export */   AsyncUnzlib: function() { return /* binding */ AsyncUnzlib; },\n/* harmony export */   AsyncZipDeflate: function() { return /* binding */ AsyncZipDeflate; },\n/* harmony export */   AsyncZlib: function() { return /* binding */ AsyncZlib; },\n/* harmony export */   Compress: function() { return /* binding */ Gzip; },\n/* harmony export */   DecodeUTF8: function() { return /* binding */ DecodeUTF8; },\n/* harmony export */   Decompress: function() { return /* binding */ Decompress; },\n/* harmony export */   Deflate: function() { return /* binding */ Deflate; },\n/* harmony export */   EncodeUTF8: function() { return /* binding */ EncodeUTF8; },\n/* harmony export */   Gunzip: function() { return /* binding */ Gunzip; },\n/* harmony export */   Gzip: function() { return /* binding */ Gzip; },\n/* harmony export */   Inflate: function() { return /* binding */ Inflate; },\n/* harmony export */   Unzip: function() { return /* binding */ Unzip; },\n/* harmony export */   UnzipInflate: function() { return /* binding */ UnzipInflate; },\n/* harmony export */   UnzipPassThrough: function() { return /* binding */ UnzipPassThrough; },\n/* harmony export */   Unzlib: function() { return /* binding */ Unzlib; },\n/* harmony export */   Zip: function() { return /* binding */ Zip; },\n/* harmony export */   ZipDeflate: function() { return /* binding */ ZipDeflate; },\n/* harmony export */   ZipPassThrough: function() { return /* binding */ ZipPassThrough; },\n/* harmony export */   Zlib: function() { return /* binding */ Zlib; },\n/* harmony export */   compress: function() { return /* binding */ gzip; },\n/* harmony export */   compressSync: function() { return /* binding */ gzipSync; },\n/* harmony export */   decompress: function() { return /* binding */ decompress; },\n/* harmony export */   decompressSync: function() { return /* binding */ decompressSync; },\n/* harmony export */   deflate: function() { return /* binding */ deflate; },\n/* harmony export */   deflateSync: function() { return /* binding */ deflateSync; },\n/* harmony export */   gunzip: function() { return /* binding */ gunzip; },\n/* harmony export */   gunzipSync: function() { return /* binding */ gunzipSync; },\n/* harmony export */   gzip: function() { return /* binding */ gzip; },\n/* harmony export */   gzipSync: function() { return /* binding */ gzipSync; },\n/* harmony export */   inflate: function() { return /* binding */ inflate; },\n/* harmony export */   inflateSync: function() { return /* binding */ inflateSync; },\n/* harmony export */   strFromU8: function() { return /* binding */ strFromU8; },\n/* harmony export */   strToU8: function() { return /* binding */ strToU8; },\n/* harmony export */   unzip: function() { return /* binding */ unzip; },\n/* harmony export */   unzipSync: function() { return /* binding */ unzipSync; },\n/* harmony export */   unzlib: function() { return /* binding */ unzlib; },\n/* harmony export */   unzlibSync: function() { return /* binding */ unzlibSync; },\n/* harmony export */   zip: function() { return /* binding */ zip; },\n/* harmony export */   zipSync: function() { return /* binding */ zipSync; },\n/* harmony export */   zlib: function() { return /* binding */ zlib; },\n/* harmony export */   zlibSync: function() { return /* binding */ zlibSync; }\n/* harmony export */ });\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = function(c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([\n        c\n    ], {\n        type: \"text/javascript\"\n    }))));\n    w.onerror = function(e) {\n        return cb(e.error, null);\n    };\n    w.onmessage = function(e) {\n        return cb(null, e.data);\n    };\n    w.postMessage(msg, transfer);\n    return w;\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return [\n        b,\n        r\n    ];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i)++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 0; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p / 8 | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                // ensure size\n                if (noBuf) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else throw \"invalid block type\";\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n            if (!c) throw \"invalid length/literal\";\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) throw \"invalid distance\";\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                if (noBuf) cbuf(bt + 131072);\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return [\n        et,\n        0\n    ];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [\n            v,\n            1\n        ];\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [\n        new u8(tr),\n        mbt\n    ];\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [\n        cl.subarray(0, cli),\n        s\n    ];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;\n    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        if (syms[i] > 255) {\n            var len = syms[i] >>> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for(var i = 0; i <= s; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            } else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    } else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for(; i < s; ++i){\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j + 32768 & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti + 32768 & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod + 32768 & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Alder32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/ /g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return [\n        fnStr,\n        td\n    ];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        inflt,\n        inflateSync,\n        pbf,\n        gu8\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zlv\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get u8\nvar gu8 = function(o) {\n    return o && o.size && new u8(o.size);\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        return strm.push(ev.data[0], ev.data[1]);\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function(d, f) {\n        if (t) throw \"stream finished\";\n        if (!strm.ondata) throw \"no stream handler\";\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw \"invalid gzip data\";\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename && o.filename.length + 1 || 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n};\n// zlib valid\nvar zlv = function(d) {\n    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw \"invalid zlib data\";\n    if (d[1] & 32) throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n_c = AsyncCmpStrm;\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}();\n\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function(c) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function(final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}();\n\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));\n    }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}();\n\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}();\n\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final) return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8) throw \"invalid gzip stream\";\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}();\n\n/**\n * Asynchronous streaming GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}();\n\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0]));\n    }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */ function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}();\n\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}();\n\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final) return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) throw \"invalid zlib stream\";\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\n\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}();\n\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));\n    }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */ function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no stream handler\";\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function() {\n                    _this_1.ondata.apply(_this_1, arguments);\n                };\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */ function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\n\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function decompressSync(data, out) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k;\n        if (val instanceof u8) t[n] = [\n            val,\n            o\n        ];\n        else if (Array.isArray(val)) t[n] = [\n            val[0],\n            mrg(o, val[1])\n        ];\n        else fltn(val, n + \"/\", t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return [\n            r,\n            slc(d, i - 1)\n        ];\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) throw \"invalid utf-8 data\";\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) throw \"stream finished\";\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length) throw \"invalid utf-8 data\";\n            this.p = null;\n        } else this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}();\n\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        if (this.d) throw \"stream finished\";\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length) throw \"invalid utf-8 data\";\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) throw \"extra field too long\";\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) throw \"date not in range 1980-2099\";\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback - add to ZIP archive before pushing\";\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this_1 = this;\n        if (this.d & 2) throw \"stream finished\";\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || o && com.length != o.length;\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535) throw \"filename too long\";\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [\n            header\n        ];\n        var pAll = function() {\n            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function() {\n                if (file.terminate) file.terminate();\n            },\n            r: function() {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt) nxt.r();\n                    else _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function(err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            } else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr) uf.r();\n                    tr = 1;\n                } else if (tr) pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1) throw \"stream finishing\";\n            throw \"stream finished\";\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this_1.d & 1)) return;\n                _this_1.u.splice(-1, 1);\n                _this_1.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\n\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(\"filename too long\", null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) throw \"filename too long\";\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile) throw \"no callback\";\n        if (!this.p) throw \"stream finished\";\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) throw \"no callback\";\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr) throw \"unknown compression type \" + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) throw \"invalid zip file\";\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */ function unzip(data, cb) {\n    if (typeof cb != \"function\") throw \"no callback\";\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft) cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function(i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                files[fn] = d;\n                if (!--lft) cb(null, files);\n            }\n        };\n        if (!c_1) cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                } catch (e) {\n                    cbl(e, null);\n                }\n            } else term.push(inflate(infl, {\n                size: su\n            }, cbl));\n        } else cbl(\"unknown compression type \" + c_1, null);\n    };\n    for(var i = 0; i < c; ++i){\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */ function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) throw \"invalid zip file\";\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) throw \"invalid zip file\";\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2) files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else throw \"unknown compression type \" + c_2;\n    }\n    return files;\n}\nvar _c;\n$RefreshReg$(_c, \"AsyncCmpStrm\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkZBQTJGO0FBQzNGLHNDQUFzQztBQUN0QywyRUFBMkU7QUFDM0UscUVBQXFFO0FBQ3JFLDREQUE0RDtBQUM1RCxzQ0FBc0M7QUFDdEMsdUhBQXVIO0FBQ3ZILDJGQUEyRjtBQUMzRixvREFBb0Q7QUFDcEQsSUFBSUEsTUFBTSxDQUFDO0FBQ1gsSUFBSUMsS0FBTSxTQUFVQyxDQUFDLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDeEMsSUFBSUMsSUFBSSxJQUFJQyxPQUFPUixHQUFHLENBQUNHLEdBQUcsSUFBS0gsQ0FBQUEsR0FBRyxDQUFDRyxHQUFHLEdBQUdNLElBQUlDLGVBQWUsQ0FBQyxJQUFJQyxLQUFLO1FBQUNUO0tBQUUsRUFBRTtRQUFFVSxNQUFNO0lBQWtCLEdBQUU7SUFDdkdMLEVBQUVNLE9BQU8sR0FBRyxTQUFVQyxDQUFDO1FBQUksT0FBT1IsR0FBR1EsRUFBRUMsS0FBSyxFQUFFO0lBQU87SUFDckRSLEVBQUVTLFNBQVMsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBT1IsR0FBRyxNQUFNUSxFQUFFRyxJQUFJO0lBQUc7SUFDdERWLEVBQUVXLFdBQVcsQ0FBQ2QsS0FBS0M7SUFDbkIsT0FBT0U7QUFDWDtBQUVBLG9FQUFvRTtBQUNwRSxJQUFJWSxLQUFLQyxZQUFZQyxNQUFNQyxhQUFhQyxNQUFNQztBQUM5QywwQkFBMEI7QUFDMUIsSUFBSUMsT0FBTyxJQUFJTixHQUFHO0lBQUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFH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S3dELFFBQVEsQ0FBQzFDLEdBQUdBLElBQUlpVSxLQUFLLElBQUk3VSxHQUFHOFU7YUFFekQsTUFBTSw4QkFBOEIrRjtJQUM1QztJQUNBLE9BQU8vQztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2Jyb3dzZXIuanM/ZDNiZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBERUZMQVRFIGlzIGEgY29tcGxleCBmb3JtYXQ7IHRvIHJlYWQgdGhpcyBjb2RlLCB5b3Ugc2hvdWxkIHByb2JhYmx5IGNoZWNrIHRoZSBSRkMgZmlyc3Q6XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTk1MVxuLy8gWW91IG1heSBhbHNvIHdpc2ggdG8gdGFrZSBhIGxvb2sgYXQgdGhlIGd1aWRlIEkgbWFkZSBhYm91dCB0aGlzIHByb2dyYW06XG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDFhcnJvd3ovMjUzZjMxZWI1YWJjM2Q5Mjc1YWI5NDMwMDNmZmVjYWRcbi8vIFNvbWUgb2YgdGhlIGZvbGxvd2luZyBjb2RlIGlzIHNpbWlsYXIgdG8gdGhhdCBvZiBVWklQLmpzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvcGVhL1VaSVAuanNcbi8vIEhvd2V2ZXIsIHRoZSB2YXN0IG1ham9yaXR5IG9mIHRoZSBjb2RlYmFzZSBoYXMgZGl2ZXJnZWQgZnJvbSBVWklQLmpzIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlIGFuZCByZWR1Y2UgYnVuZGxlIHNpemUuXG4vLyBTb21ldGltZXMgMCB3aWxsIGFwcGVhciB3aGVyZSAtMSB3b3VsZCBiZSBtb3JlIGFwcHJvcHJpYXRlLiBUaGlzIGlzIGJlY2F1c2UgdXNpbmcgYSB1aW50XG4vLyBpcyBiZXR0ZXIgZm9yIG1lbW9yeSBpbiBtb3N0IGVuZ2luZXMgKEkgKnRoaW5rKikuXG52YXIgY2gyID0ge307XG52YXIgd2sgPSAoZnVuY3Rpb24gKGMsIGlkLCBtc2csIHRyYW5zZmVyLCBjYikge1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihjaDJbaWRdIHx8IChjaDJbaWRdID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSkpKSk7XG4gICAgdy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNiKGUuZXJyb3IsIG51bGwpOyB9O1xuICAgIHcub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNiKG51bGwsIGUuZGF0YSk7IH07XG4gICAgdy5wb3N0TWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICByZXR1cm4gdztcbn0pO1xuXG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4vLyBzZWUgZmxlYiBub3RlXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgdTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYiwgcl07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYVswXSwgcmV2ZmwgPSBfYVsxXTtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iWzBdLCByZXZmZCA9IF9iWzFdO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+Pj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSlcbiAgICAgICAgKytsW2NkW2ldIC0gMV07XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMDsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgZmx0W2ldID0gODtcbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICBmbHRbaV0gPSA5O1xuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIGZsdFtpXSA9IDc7XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgZmx0W2ldID0gODtcbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIGZkdFtpXSA9IDU7XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMCksIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDApLCBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICBtID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwIC8gOCkgfCAwKSArIChwICYgNyAmJiAxKTsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgdmFyIG4gPSBuZXcgKHYgaW5zdGFuY2VvZiB1MTYgPyB1MTYgOiB2IGluc3RhbmNlb2YgdTMyID8gdTMyIDogdTgpKGUgLSBzKTtcbiAgICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgICByZXR1cm4gbjtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICBpZiAoIXNsIHx8IChzdCAmJiAhc3QubCAmJiBzbCA8IDUpKVxuICAgICAgICByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0O1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSAhc3QgfHwgc3QuaTtcbiAgICBpZiAoIXN0KVxuICAgICAgICBzdCA9IHt9O1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmICghYnVmKVxuICAgICAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIHN0LmYgPSBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogODtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3O1xuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgICAgIGZvciAoOzsgbHBvcyA9IHBvcykge1xuICAgICAgICAgICAgLy8gYml0cyByZWFkLCBjb2RlXG4gICAgICAgICAgICB2YXIgYyA9IGxtW2JpdHMxNihkYXQsIHBvcykgJiBsbXNdLCBzeW0gPSBjID4+PiA0O1xuICAgICAgICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgbGVuZ3RoL2xpdGVyYWwnO1xuICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICBidWZbYnQrK10gPSBzeW07XG4gICAgICAgICAgICBlbHNlIGlmIChzeW0gPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHN5bSAtIDI1NDtcbiAgICAgICAgICAgICAgICAvLyBubyBleHRyYSBiaXRzIG5lZWRlZCBpZiBsZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN5bSA+IDI2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IGJpdHMoZGF0LCBwb3MsICgxIDw8IGIpIC0gMSkgKyBmbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc3RcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRtW2JpdHMxNihkYXQsIHBvcykgJiBkbXNdLCBkc3ltID0gZCA+Pj4gNDtcbiAgICAgICAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGRpc3RhbmNlJztcbiAgICAgICAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICAgICAgICAgIGlmIChkc3ltID4gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgIGR0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoKDEgPDwgYikgLSAxKSwgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQ7XG4gICAgICAgIGlmIChsbSlcbiAgICAgICAgICAgIGZpbmFsID0gMSwgc3QubSA9IGxidCwgc3QuZCA9IGRtLCBzdC5uID0gZGJ0O1xuICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0cyA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyAoPjgpIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMxNiA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbiAgICBkW28gKyAyXSB8PSB2ID4+PiAxNjtcbn07XG4vLyBjcmVhdGVzIGNvZGUgbGVuZ3RocyBmcm9tIGEgZnJlcXVlbmN5IHRhYmxlXG52YXIgaFRyZWUgPSBmdW5jdGlvbiAoZCwgbWIpIHtcbiAgICAvLyBOZWVkIGV4dHJhIGluZm8gdG8gbWFrZSBhIHRyZWVcbiAgICB2YXIgdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoZFtpXSlcbiAgICAgICAgICAgIHQucHVzaCh7IHM6IGksIGY6IGRbaV0gfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIFtldCwgMF07XG4gICAgaWYgKHMgPT0gMSkge1xuICAgICAgICB2YXIgdiA9IG5ldyB1OCh0WzBdLnMgKyAxKTtcbiAgICAgICAgdlt0WzBdLnNdID0gMTtcbiAgICAgICAgcmV0dXJuIFt2LCAxXTtcbiAgICB9XG4gICAgdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmYgLSBiLmY7IH0pO1xuICAgIC8vIGFmdGVyIGkyIHJlYWNoZXMgbGFzdCBpbmQsIHdpbGwgYmUgc3RvcHBlZFxuICAgIC8vIGZyZXEgbXVzdCBiZSBncmVhdGVyIHRoYW4gbGFyZ2VzdCBwb3NzaWJsZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIHQucHVzaCh7IHM6IC0xLCBmOiAyNTAwMSB9KTtcbiAgICB2YXIgbCA9IHRbMF0sIHIgPSB0WzFdLCBpMCA9IDAsIGkxID0gMSwgaTIgPSAyO1xuICAgIHRbMF0gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICAvLyBlZmZpY2llbnQgYWxnb3JpdGhtIGZyb20gVVpJUC5qc1xuICAgIC8vIGkwIGlzIGxvb2tiZWhpbmQsIGkyIGlzIGxvb2thaGVhZCAtIGFmdGVyIHByb2Nlc3NpbmcgdHdvIGxvdy1mcmVxXG4gICAgLy8gc3ltYm9scyB0aGF0IGNvbWJpbmVkIGhhdmUgaGlnaCBmcmVxLCB3aWxsIHN0YXJ0IHByb2Nlc3NpbmcgaTIgKGhpZ2gtZnJlcSxcbiAgICAvLyBub24tY29tcG9zaXRlKSBzeW1ib2xzIGluc3RlYWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9yZWRkaXQuY29tL3IvcGhvdG9wZWEvY29tbWVudHMvaWtla2h0L3V6aXBqc19xdWVzdGlvbnMvXG4gICAgd2hpbGUgKGkxICE9IHMgLSAxKSB7XG4gICAgICAgIGwgPSB0W3RbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICByID0gdFtpMCAhPSBpMSAmJiB0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgdFtpMSsrXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIH1cbiAgICB2YXIgbWF4U3ltID0gdDJbMF0ucztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAodDJbaV0ucyA+IG1heFN5bSlcbiAgICAgICAgICAgIG1heFN5bSA9IHQyW2ldLnM7XG4gICAgfVxuICAgIC8vIGNvZGUgbGVuZ3Roc1xuICAgIHZhciB0ciA9IG5ldyB1MTYobWF4U3ltICsgMSk7XG4gICAgLy8gbWF4IGJpdHMgaW4gdHJlZVxuICAgIHZhciBtYnQgPSBsbih0W2kxIC0gMV0sIHRyLCAwKTtcbiAgICBpZiAobWJ0ID4gbWIpIHtcbiAgICAgICAgLy8gbW9yZSBhbGdvcml0aG1zIGZyb20gVVpJUC5qc1xuICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCBob3cgdGhpcyBjb2RlIHdvcmtzIChkZWJ0KVxuICAgICAgICAvLyAgaW5kICAgIGRlYnRcbiAgICAgICAgdmFyIGkgPSAwLCBkdCA9IDA7XG4gICAgICAgIC8vICAgIGxlZnQgICAgICAgICAgICBjb3N0XG4gICAgICAgIHZhciBsZnQgPSBtYnQgLSBtYiwgY3N0ID0gMSA8PCBsZnQ7XG4gICAgICAgIHQyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRyW2Iuc10gLSB0clthLnNdIHx8IGEuZiAtIGIuZjsgfSk7XG4gICAgICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaTJfMSA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMV0gPiBtYikge1xuICAgICAgICAgICAgICAgIGR0ICs9IGNzdCAtICgxIDw8IChtYnQgLSB0cltpMl8xXSkpO1xuICAgICAgICAgICAgICAgIHRyW2kyXzFdID0gbWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZHQgPj4+PSBsZnQ7XG4gICAgICAgIHdoaWxlIChkdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpMl8yID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8yXSA8IG1iKVxuICAgICAgICAgICAgICAgIGR0IC09IDEgPDwgKG1iIC0gdHJbaTJfMl0rKyAtIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA+PSAwICYmIGR0OyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBpMl8zID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8zXSA9PSBtYikge1xuICAgICAgICAgICAgICAgIC0tdHJbaTJfM107XG4gICAgICAgICAgICAgICAgKytkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYnQgPSBtYjtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXcgdTgodHIpLCBtYnRdO1xufTtcbi8vIGdldCB0aGUgbWF4IGxlbmd0aCBhbmQgYXNzaWduIGxlbmd0aCBjb2Rlc1xudmFyIGxuID0gZnVuY3Rpb24gKG4sIGwsIGQpIHtcbiAgICByZXR1cm4gbi5zID09IC0xXG4gICAgICAgID8gTWF0aC5tYXgobG4obi5sLCBsLCBkICsgMSksIGxuKG4uciwgbCwgZCArIDEpKVxuICAgICAgICA6IChsW24uc10gPSBkKTtcbn07XG4vLyBsZW5ndGggY29kZXMgZ2VuZXJhdGlvblxudmFyIGxjID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgcyA9IGMubGVuZ3RoO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VtaWNvbG9uIHdhcyBpbnRlbnRpb25hbFxuICAgIHdoaWxlIChzICYmICFjWy0tc10pXG4gICAgICAgIDtcbiAgICB2YXIgY2wgPSBuZXcgdTE2KCsrcyk7XG4gICAgLy8gIGluZCAgICAgIG51bSAgICAgICAgIHN0cmVha1xuICAgIHZhciBjbGkgPSAwLCBjbG4gPSBjWzBdLCBjbHMgPSAxO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgY2xbY2xpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNbaV0gPT0gY2xuICYmIGkgIT0gcylcbiAgICAgICAgICAgICsrY2xzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY2xuICYmIGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gMTM4OyBjbHMgLT0gMTM4KVxuICAgICAgICAgICAgICAgICAgICB3KDMyNzU0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMikge1xuICAgICAgICAgICAgICAgICAgICB3KGNscyA+IDEwID8gKChjbHMgLSAxMSkgPDwgNSkgfCAyODY5MCA6ICgoY2xzIC0gMykgPDwgNSkgfCAxMjMwNSk7XG4gICAgICAgICAgICAgICAgICAgIGNscyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xzID4gMykge1xuICAgICAgICAgICAgICAgIHcoY2xuKSwgLS1jbHM7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDY7IGNscyAtPSA2KVxuICAgICAgICAgICAgICAgICAgICB3KDgzMDQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKVxuICAgICAgICAgICAgICAgICAgICB3KCgoY2xzIC0gMykgPDwgNSkgfCA4MjA4KSwgY2xzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjbHMtLSlcbiAgICAgICAgICAgICAgICB3KGNsbik7XG4gICAgICAgICAgICBjbHMgPSAxO1xuICAgICAgICAgICAgY2xuID0gY1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2NsLnN1YmFycmF5KDAsIGNsaSksIHNdO1xufTtcbi8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIG91dHB1dCBmcm9tIHRyZWUsIGNvZGUgbGVuZ3Roc1xudmFyIGNsZW4gPSBmdW5jdGlvbiAoY2YsIGNsKSB7XG4gICAgdmFyIGwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2wubGVuZ3RoOyArK2kpXG4gICAgICAgIGwgKz0gY2ZbaV0gKiBjbFtpXTtcbiAgICByZXR1cm4gbDtcbn07XG4vLyB3cml0ZXMgYSBmaXhlZCBibG9ja1xuLy8gcmV0dXJucyB0aGUgbmV3IGJpdCBwb3NcbnZhciB3ZmJsayA9IGZ1bmN0aW9uIChvdXQsIHBvcywgZGF0KSB7XG4gICAgLy8gbm8gbmVlZCB0byB3cml0ZSAwMCBhcyB0eXBlOiBUeXBlZEFycmF5IGRlZmF1bHRzIHRvIDBcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBzaGZ0KHBvcyArIDIpO1xuICAgIG91dFtvXSA9IHMgJiAyNTU7XG4gICAgb3V0W28gKyAxXSA9IHMgPj4+IDg7XG4gICAgb3V0W28gKyAyXSA9IG91dFtvXSBeIDI1NTtcbiAgICBvdXRbbyArIDNdID0gb3V0W28gKyAxXSBeIDI1NTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7ICsraSlcbiAgICAgICAgb3V0W28gKyBpICsgNF0gPSBkYXRbaV07XG4gICAgcmV0dXJuIChvICsgNCArIHMpICogODtcbn07XG4vLyB3cml0ZXMgYSBibG9ja1xudmFyIHdibGsgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGZpbmFsLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGJsLCBwKSB7XG4gICAgd2JpdHMob3V0LCBwKyssIGZpbmFsKTtcbiAgICArK2xmWzI1Nl07XG4gICAgdmFyIF9hID0gaFRyZWUobGYsIDE1KSwgZGx0ID0gX2FbMF0sIG1sYiA9IF9hWzFdO1xuICAgIHZhciBfYiA9IGhUcmVlKGRmLCAxNSksIGRkdCA9IF9iWzBdLCBtZGIgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBsYyhkbHQpLCBsY2x0ID0gX2NbMF0sIG5sYyA9IF9jWzFdO1xuICAgIHZhciBfZCA9IGxjKGRkdCksIGxjZHQgPSBfZFswXSwgbmRjID0gX2RbMV07XG4gICAgdmFyIGxjZnJlcSA9IG5ldyB1MTYoMTkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNsdC5sZW5ndGg7ICsraSlcbiAgICAgICAgbGNmcmVxW2xjbHRbaV0gJiAzMV0rKztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjZHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2R0W2ldICYgMzFdKys7XG4gICAgdmFyIF9lID0gaFRyZWUobGNmcmVxLCA3KSwgbGN0ID0gX2VbMF0sIG1sY2IgPSBfZVsxXTtcbiAgICB2YXIgbmxjYyA9IDE5O1xuICAgIGZvciAoOyBubGNjID4gNCAmJiAhbGN0W2NsaW1bbmxjYyAtIDFdXTsgLS1ubGNjKVxuICAgICAgICA7XG4gICAgdmFyIGZsZW4gPSAoYmwgKyA1KSA8PCAzO1xuICAgIHZhciBmdGxlbiA9IGNsZW4obGYsIGZsdCkgKyBjbGVuKGRmLCBmZHQpICsgZWI7XG4gICAgdmFyIGR0bGVuID0gY2xlbihsZiwgZGx0KSArIGNsZW4oZGYsIGRkdCkgKyBlYiArIDE0ICsgMyAqIG5sY2MgKyBjbGVuKGxjZnJlcSwgbGN0KSArICgyICogbGNmcmVxWzE2XSArIDMgKiBsY2ZyZXFbMTddICsgNyAqIGxjZnJlcVsxOF0pO1xuICAgIGlmIChmbGVuIDw9IGZ0bGVuICYmIGZsZW4gPD0gZHRsZW4pXG4gICAgICAgIHJldHVybiB3ZmJsayhvdXQsIHAsIGRhdC5zdWJhcnJheShicywgYnMgKyBibCkpO1xuICAgIHZhciBsbSwgbGwsIGRtLCBkbDtcbiAgICB3Yml0cyhvdXQsIHAsIDEgKyAoZHRsZW4gPCBmdGxlbikpLCBwICs9IDI7XG4gICAgaWYgKGR0bGVuIDwgZnRsZW4pIHtcbiAgICAgICAgbG0gPSBoTWFwKGRsdCwgbWxiLCAwKSwgbGwgPSBkbHQsIGRtID0gaE1hcChkZHQsIG1kYiwgMCksIGRsID0gZGR0O1xuICAgICAgICB2YXIgbGxtID0gaE1hcChsY3QsIG1sY2IsIDApO1xuICAgICAgICB3Yml0cyhvdXQsIHAsIG5sYyAtIDI1Nyk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDUsIG5kYyAtIDEpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyAxMCwgbmxjYyAtIDQpO1xuICAgICAgICBwICs9IDE0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5sY2M7ICsraSlcbiAgICAgICAgICAgIHdiaXRzKG91dCwgcCArIDMgKiBpLCBsY3RbY2xpbVtpXV0pO1xuICAgICAgICBwICs9IDMgKiBubGNjO1xuICAgICAgICB2YXIgbGN0cyA9IFtsY2x0LCBsY2R0XTtcbiAgICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IDI7ICsraXQpIHtcbiAgICAgICAgICAgIHZhciBjbGN0ID0gbGN0c1tpdF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2xjdFtpXSAmIDMxO1xuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgbGxtW2xlbl0pLCBwICs9IGxjdFtsZW5dO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoY2xjdFtpXSA+Pj4gNSkgJiAxMjcpLCBwICs9IGNsY3RbaV0gPj4+IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsbSA9IGZsbSwgbGwgPSBmbHQsIGRtID0gZmRtLCBkbCA9IGZkdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaTsgKytpKSB7XG4gICAgICAgIGlmIChzeW1zW2ldID4gMjU1KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gKHN5bXNbaV0gPj4+IDE4KSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW2xlbiArIDI1N10pLCBwICs9IGxsW2xlbiArIDI1N107XG4gICAgICAgICAgICBpZiAobGVuID4gNylcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChzeW1zW2ldID4+PiAyMykgJiAzMSksIHAgKz0gZmxlYltsZW5dO1xuICAgICAgICAgICAgdmFyIGRzdCA9IHN5bXNbaV0gJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBkbVtkc3RdKSwgcCArPSBkbFtkc3RdO1xuICAgICAgICAgICAgaWYgKGRzdCA+IDMpXG4gICAgICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIChzeW1zW2ldID4+PiA1KSAmIDgxOTEpLCBwICs9IGZkZWJbZHN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtzeW1zW2ldXSksIHAgKz0gbGxbc3ltc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2JpdHMxNihvdXQsIHAsIGxtWzI1Nl0pO1xuICAgIHJldHVybiBwICsgbGxbMjU2XTtcbn07XG4vLyBkZWZsYXRlIG9wdGlvbnMgKG5pY2UgPDwgMTMpIHwgY2hhaW5cbnZhciBkZW8gPSAvKiNfX1BVUkVfXyovIG5ldyB1MzIoWzY1NTQwLCAxMzEwODAsIDEzMTA4OCwgMTMxMTA0LCAyNjIxNzYsIDEwNDg3MDQsIDEwNDg4MzIsIDIxMTQ1NjAsIDIxMTc2MzJdKTtcbi8vIGVtcHR5XG52YXIgZXQgPSAvKiNfX1BVUkVfXyovIG5ldyB1OCgwKTtcbi8vIGNvbXByZXNzZXMgZGF0YSBpbnRvIGEgcmF3IERFRkxBVEUgYnVmZmVyXG52YXIgZGZsdCA9IGZ1bmN0aW9uIChkYXQsIGx2bCwgcGx2bCwgcHJlLCBwb3N0LCBsc3QpIHtcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBuZXcgdTgocHJlICsgcyArIDUgKiAoMSArIE1hdGguY2VpbChzIC8gNzAwMCkpICsgcG9zdCk7XG4gICAgLy8gd3JpdGluZyB0byB0aGlzIHdyaXRlcyB0byB0aGUgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciB3ID0gby5zdWJhcnJheShwcmUsIG8ubGVuZ3RoIC0gcG9zdCk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgaWYgKCFsdmwgfHwgcyA8IDgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gczsgaSArPSA2NTUzNSkge1xuICAgICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgICB2YXIgZSA9IGkgKyA2NTUzNTtcbiAgICAgICAgICAgIGlmIChlIDwgcykge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZ1bGwgYmxvY2tcbiAgICAgICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MsIGRhdC5zdWJhcnJheShpLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmaW5hbCBibG9ja1xuICAgICAgICAgICAgICAgIHdbaV0gPSBsc3Q7XG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgICB2YXIgbiA9IG9wdCA+Pj4gMTMsIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgICB2YXIgbXNrXzEgPSAoMSA8PCBwbHZsKSAtIDE7XG4gICAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgICB2YXIgcHJldiA9IG5ldyB1MTYoMzI3NjgpLCBoZWFkID0gbmV3IHUxNihtc2tfMSArIDEpO1xuICAgICAgICB2YXIgYnMxXzEgPSBNYXRoLmNlaWwocGx2bCAvIDMpLCBiczJfMSA9IDIgKiBiczFfMTtcbiAgICAgICAgdmFyIGhzaCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiAoZGF0W2ldIF4gKGRhdFtpICsgMV0gPDwgYnMxXzEpIF4gKGRhdFtpICsgMl0gPDwgYnMyXzEpKSAmIG1za18xOyB9O1xuICAgICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgICAgLy8gNDI0IGJ1ZmZlciBmb3IgbGFzdCBibG9ja1xuICAgICAgICB2YXIgc3ltcyA9IG5ldyB1MzIoMjUwMDApO1xuICAgICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgICB2YXIgbGYgPSBuZXcgdTE2KDI4OCksIGRmID0gbmV3IHUxNigzMik7XG4gICAgICAgIC8vICBsL2xjbnQgIGV4Yml0cyAgaW5kZXggIGwvbGluZCAgd2FpdGR4ICBiaXRwb3NcbiAgICAgICAgdmFyIGxjXzEgPSAwLCBlYiA9IDAsIGkgPSAwLCBsaSA9IDAsIHdpID0gMCwgYnMgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICAgICAgLy8gZGVvcHQgd2hlbiBpID4gcyAtIDMgLSBhdCBlbmQsIGRlb3B0IGFjY2VwdGFibGVcbiAgICAgICAgICAgIHZhciBodiA9IGhzaChpKTtcbiAgICAgICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3LCBwaW1vZCA9IGhlYWRbaHZdO1xuICAgICAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICAgICAgaGVhZFtodl0gPSBpbW9kO1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNob3VsZCBtb2RpZnkgaGVhZCBhbmQgcHJldiwgYnV0IG9ubHkgYWRkIHN5bWJvbHMgaWZcbiAgICAgICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgICAgICBpZiAod2kgPD0gaSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIHZhciByZW0gPSBzIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAoKGxjXzEgPiA3MDAwIHx8IGxpID4gMjQ1NzYpICYmIHJlbSA+IDQyMykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgMCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gbGNfMSA9IGViID0gMCwgYnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGZbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDMwOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBkZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAyLCBkID0gMCwgY2hfMSA9IGMsIGRpZiA9IChpbW9kIC0gcGltb2QpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgaWYgKHJlbSA+IDIgJiYgaHYgPT0gaHNoKGkgLSBkaWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhkID0gTWF0aC5taW4oMzI3NjcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXggcG9zc2libGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWwgPSBNYXRoLm1pbigyNTgsIHJlbSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWYgPD0gbWF4ZCAmJiAtLWNoXzEgJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdFtpICsgbF0gPT0gZGF0W2kgKyBsIC0gZGlmXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG5sIDwgbWwgJiYgZGF0W2kgKyBubF0gPT0gZGF0W2kgKyBubCAtIGRpZl07ICsrbmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBubCwgZCA9IGRpZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBtYXhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgZmluZCB0aGUgcmFyZXN0IDItYnl0ZSBzZXF1ZW5jZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGl0ZXJhbHMgYW5kIHNlYXJjaCBmb3IgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtbWQgPSBNYXRoLm1pbihkaWYsIG5sIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW1kOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IChpIC0gZGlmICsgaiArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0aSA9IHByZXZbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gKHRpIC0gcHRpICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2QgPiBtZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW9kID0gcGltb2QsIHBpbW9kID0gcHJldltpbW9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZiArPSAoaW1vZCAtIHBpbW9kICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYm90aCBkaXN0IGFuZCBsZW4gZGF0YSBpbiBvbmUgVWludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlY29nbml6ZWQgYXMgYSBsZW4vZGlzdCB3aXRoIDI4dGggYml0ICgyXjI4KVxuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gMjY4NDM1NDU2IHwgKHJldmZsW2xdIDw8IDE4KSB8IHJldmZkW2RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluID0gcmV2ZmxbbF0gJiAzMSwgZGluID0gcmV2ZmRbZF0gJiAzMTtcbiAgICAgICAgICAgICAgICAgICAgZWIgKz0gZmxlYltsaW5dICsgZmRlYltkaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICAgICAgICAgICsrZGZbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBpICsgbDtcbiAgICAgICAgICAgICAgICAgICAgKytsY18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgbHN0LCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gYXZvaWQgbmVlZGluZyB0byBtYWludGFpbiBzdGF0ZVxuICAgICAgICBpZiAoIWxzdCAmJiBwb3MgJiA3KVxuICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zICsgMSwgZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKG8sIDAsIHByZSArIHNoZnQocG9zKSArIHBvc3QpO1xufTtcbi8vIENSQzMyIHRhYmxlXG52YXIgY3JjdCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGksIGsgPSA5O1xuICAgICAgICB3aGlsZSAoLS1rKVxuICAgICAgICAgICAgYyA9ICgoYyAmIDEpICYmIC0zMDY2NzQ5MTIpIF4gKGMgPj4+IDEpO1xuICAgICAgICB0W2ldID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuLy8gQ1JDMzJcbnZhciBjcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGMgPSAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIGNyID0gYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjciA9IGNyY3RbKGNyICYgMjU1KSBeIGRbaV1dIF4gKGNyID4+PiA4KTtcbiAgICAgICAgICAgIGMgPSBjcjtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gfmM7IH1cbiAgICB9O1xufTtcbi8vIEFsZGVyMzJcbnZhciBhZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IDEsIGIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgbiA9IGEsIG0gPSBiO1xuICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9IGw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihpICsgMjY1NSwgbCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBlOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG0gKz0gbiArPSBkW2ldO1xuICAgICAgICAgICAgICAgIG4gPSAobiAmIDY1NTM1KSArIDE1ICogKG4gPj4gMTYpLCBtID0gKG0gJiA2NTUzNSkgKyAxNSAqIChtID4+IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBuLCBiID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYSAlPSA2NTUyMSwgYiAlPSA2NTUyMTtcbiAgICAgICAgICAgIHJldHVybiAoYSAmIDI1NSkgPDwgMjQgfCAoYSA+Pj4gOCkgPDwgMTYgfCAoYiAmIDI1NSkgPDwgOCB8IChiID4+PiA4KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuO1xuLy8gZGVmbGF0ZSB3aXRoIG9wdHNcbnZhciBkb3B0ID0gZnVuY3Rpb24gKGRhdCwgb3B0LCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgcmV0dXJuIGRmbHQoZGF0LCBvcHQubGV2ZWwgPT0gbnVsbCA/IDYgOiBvcHQubGV2ZWwsIG9wdC5tZW0gPT0gbnVsbCA/IE1hdGguY2VpbChNYXRoLm1heCg4LCBNYXRoLm1pbigxMywgTWF0aC5sb2coZGF0Lmxlbmd0aCkpKSAqIDEuNSkgOiAoMTIgKyBvcHQubWVtKSwgcHJlLCBwb3N0LCAhc3QpO1xufTtcbi8vIFdhbG1hcnQgb2JqZWN0IHNwcmVhZFxudmFyIG1yZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGEpXG4gICAgICAgIG9ba10gPSBhW2tdO1xuICAgIGZvciAodmFyIGsgaW4gYilcbiAgICAgICAgb1trXSA9IGJba107XG4gICAgcmV0dXJuIG87XG59O1xuLy8gd29ya2VyIGNsb25lXG4vLyBUaGlzIGlzIHBvc3NpYmx5IHRoZSBjcmF6aWVzdCBwYXJ0IG9mIHRoZSBlbnRpcmUgY29kZWJhc2UsIGRlc3BpdGUgaG93IHNpbXBsZSBpdCBtYXkgc2VlbS5cbi8vIFRoZSBvbmx5IHBhcmFtZXRlciB0byB0aGlzIGZ1bmN0aW9uIGlzIGEgY2xvc3VyZSB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIHNjb3BlLlxuLy8gV2UncmUgZ29pbmcgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHZhcmlhYmxlIG5hbWVzIHVzZWQgaW4gdGhlIGNsb3N1cmUgYXMgc3RyaW5ncyBiZWNhdXNlIHRoYXQgaXMgY3J1Y2lhbCBmb3Igd29ya2VyaXphdGlvbi5cbi8vIFdlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIG9mIHRydWUgdmFyaWFibGUgbmFtZSB0byB2YWx1ZSAoYmFzaWNhbGx5LCB0aGUgY3VycmVudCBzY29wZSBhcyBhIEpTIG9iamVjdCkuXG4vLyBUaGUgcmVhc29uIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBuYW1lcyBpcyBtaW5pZmllcnMgbWFuZ2xpbmcgdGhlIHRvcGxldmVsIHNjb3BlLlxuLy8gVGhpcyB0b29rIG1lIHRocmVlIHdlZWtzIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGRvLlxudmFyIHdjbG4gPSBmdW5jdGlvbiAoZm4sIGZuU3RyLCB0ZCkge1xuICAgIHZhciBkdCA9IGZuKCk7XG4gICAgdmFyIHN0ID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIga3MgPSBzdC5zbGljZShzdC5pbmRleE9mKCdbJykgKyAxLCBzdC5sYXN0SW5kZXhPZignXScpKS5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSBkdFtpXSwgayA9IGtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICc9JztcbiAgICAgICAgICAgIHZhciBzdF8xID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHYucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGdsb2JhbCBvYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKHN0XzEuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcEluZCA9IHN0XzEuaW5kZXhPZignICcsIDgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMS5zbGljZShzcEluZCwgc3RfMS5pbmRleE9mKCcoJywgc3BJbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gdi5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJy5wcm90b3R5cGUuJyArIHQgKyAnPScgKyB2LnByb3RvdHlwZVt0XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRkW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIFtmblN0ciwgdGRdO1xufTtcbnZhciBjaCA9IFtdO1xuLy8gY2xvbmUgYnVmc1xudmFyIGNiZnMgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciB0bCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gdikge1xuICAgICAgICBpZiAodltrXSBpbnN0YW5jZW9mIHU4IHx8IHZba10gaW5zdGFuY2VvZiB1MTYgfHwgdltrXSBpbnN0YW5jZW9mIHUzMilcbiAgICAgICAgICAgIHRsLnB1c2goKHZba10gPSBuZXcgdltrXS5jb25zdHJ1Y3Rvcih2W2tdKSkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRsO1xufTtcbi8vIHVzZSBhIHdvcmtlciB0byBleGVjdXRlIGNvZGVcbnZhciB3cmtyID0gZnVuY3Rpb24gKGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghY2hbaWRdKSB7XG4gICAgICAgIHZhciBmblN0ciA9ICcnLCB0ZF8xID0ge30sIG0gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICBfYSA9IHdjbG4oZm5zW2ldLCBmblN0ciwgdGRfMSksIGZuU3RyID0gX2FbMF0sIHRkXzEgPSBfYVsxXTtcbiAgICAgICAgY2hbaWRdID0gd2NsbihmbnNbbV0sIGZuU3RyLCB0ZF8xKTtcbiAgICB9XG4gICAgdmFyIHRkID0gbXJnKHt9LCBjaFtpZF1bMV0pO1xuICAgIHJldHVybiB3ayhjaFtpZF1bMF0gKyAnO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0nICsgaW5pdC50b1N0cmluZygpICsgJ30nLCBpZCwgdGQsIGNiZnModGQpLCBjYik7XG59O1xuLy8gYmFzZSBhc3luYyBpbmZsYXRlIGZuXG52YXIgYkluZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgZmwsIGZkLCBmbHJtLCBmZHJtLCByZXYsIGhNYXAsIG1heCwgYml0cywgYml0czE2LCBzaGZ0LCBzbGMsIGluZmx0LCBpbmZsYXRlU3luYywgcGJmLCBndThdOyB9O1xudmFyIGJEZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgcmV2ZmwsIHJldmZkLCBmbG0sIGZsdCwgZmRtLCBmZHQsIHJldiwgZGVvLCBldCwgaE1hcCwgd2JpdHMsIHdiaXRzMTYsIGhUcmVlLCBsbiwgbGMsIGNsZW4sIHdmYmxrLCB3YmxrLCBzaGZ0LCBzbGMsIGRmbHQsIGRvcHQsIGRlZmxhdGVTeW5jLCBwYmZdOyB9O1xuLy8gZ3ppcCBleHRyYVxudmFyIGd6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemgsIGd6aGwsIHdieXRlcywgY3JjLCBjcmN0XTsgfTtcbi8vIGd1bnppcCBleHRyYVxudmFyIGd1emUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3pzLCBnemxdOyB9O1xuLy8gemxpYiBleHRyYVxudmFyIHpsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGgsIHdieXRlcywgYWRsZXJdOyB9O1xuLy8gdW56bGliIGV4dHJhXG52YXIgenVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bHZdOyB9O1xuLy8gcG9zdCBidWZcbnZhciBwYmYgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBwb3N0TWVzc2FnZShtc2csIFttc2cuYnVmZmVyXSk7IH07XG4vLyBnZXQgdThcbnZhciBndTggPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBvLnNpemUgJiYgbmV3IHU4KG8uc2l6ZSk7IH07XG4vLyBhc3luYyBoZWxwZXJcbnZhciBjYmlmeSA9IGZ1bmN0aW9uIChkYXQsIG9wdHMsIGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICBjYihlcnIsIGRhdCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShbZGF0LCBvcHRzXSwgb3B0cy5jb25zdW1lID8gW2RhdC5idWZmZXJdIDogW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gYXV0byBzdHJlYW1cbnZhciBhc3RybSA9IGZ1bmN0aW9uIChzdHJtKSB7XG4gICAgc3RybS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0LCBmaW5hbCkgeyByZXR1cm4gcG9zdE1lc3NhZ2UoW2RhdCwgZmluYWxdLCBbZGF0LmJ1ZmZlcl0pOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHN0cm0ucHVzaChldi5kYXRhWzBdLCBldi5kYXRhWzFdKTsgfTtcbn07XG4vLyBhc3luYyBzdHJlYW0gYXR0YWNoXG52YXIgYXN0cm1pZnkgPSBmdW5jdGlvbiAoZm5zLCBzdHJtLCBvcHRzLCBpbml0LCBpZCkge1xuICAgIHZhciB0O1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHcudGVybWluYXRlKCksIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0WzFdKVxuICAgICAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVyciwgZGF0WzBdLCBkYXRbMV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShvcHRzKTtcbiAgICBzdHJtLnB1c2ggPSBmdW5jdGlvbiAoZCwgZikge1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXN0cm0ub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdy5wb3N0TWVzc2FnZShbZCwgdCA9IGZdLCBbZC5idWZmZXJdKTtcbiAgICB9O1xuICAgIHN0cm0udGVybWluYXRlID0gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIHJlYWQgMiBieXRlc1xudmFyIGIyID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGRbYl0gfCAoZFtiICsgMV0gPDwgOCk7IH07XG4vLyByZWFkIDQgYnl0ZXNcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbnZhciBiOCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiNChkLCBiKSArIChiNChkLCBiICsgNCkgKiA0Mjk0OTY3Mjk2KTsgfTtcbi8vIHdyaXRlIGJ5dGVzXG52YXIgd2J5dGVzID0gZnVuY3Rpb24gKGQsIGIsIHYpIHtcbiAgICBmb3IgKDsgdjsgKytiKVxuICAgICAgICBkW2JdID0gdiwgdiA+Pj49IDg7XG59O1xuLy8gZ3ppcCBoZWFkZXJcbnZhciBnemggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBmbiA9IG8uZmlsZW5hbWU7XG4gICAgY1swXSA9IDMxLCBjWzFdID0gMTM5LCBjWzJdID0gOCwgY1s4XSA9IG8ubGV2ZWwgPCAyID8gNCA6IG8ubGV2ZWwgPT0gOSA/IDIgOiAwLCBjWzldID0gMzsgLy8gYXNzdW1lIFVuaXhcbiAgICBpZiAoby5tdGltZSAhPSAwKVxuICAgICAgICB3Ynl0ZXMoYywgNCwgTWF0aC5mbG9vcihuZXcgRGF0ZShvLm10aW1lIHx8IERhdGUubm93KCkpIC8gMTAwMCkpO1xuICAgIGlmIChmbikge1xuICAgICAgICBjWzNdID0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZm4ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjW2kgKyAxMF0gPSBmbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbn07XG4vLyBnemlwIGZvb3RlcjogLTggdG8gLTQgPSBDUkMsIC00IHRvIC0wIGlzIGxlbmd0aFxuLy8gZ3ppcCBzdGFydFxudmFyIGd6cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGRbMF0gIT0gMzEgfHwgZFsxXSAhPSAxMzkgfHwgZFsyXSAhPSA4KVxuICAgICAgICB0aHJvdyAnaW52YWxpZCBnemlwIGRhdGEnO1xuICAgIHZhciBmbGcgPSBkWzNdO1xuICAgIHZhciBzdCA9IDEwO1xuICAgIGlmIChmbGcgJiA0KVxuICAgICAgICBzdCArPSBkWzEwXSB8IChkWzExXSA8PCA4KSArIDI7XG4gICAgZm9yICh2YXIgenMgPSAoZmxnID4+IDMgJiAxKSArIChmbGcgPj4gNCAmIDEpOyB6cyA+IDA7IHpzIC09ICFkW3N0KytdKVxuICAgICAgICA7XG4gICAgcmV0dXJuIHN0ICsgKGZsZyAmIDIpO1xufTtcbi8vIGd6aXAgbGVuZ3RoXG52YXIgZ3psID0gZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgIHJldHVybiAoKGRbbCAtIDRdIHwgZFtsIC0gM10gPDwgOCB8IGRbbCAtIDJdIDw8IDE2KSB8IChkW2wgLSAxXSA8PCAyNCkpID4+PiAwO1xufTtcbi8vIGd6aXAgaGVhZGVyIGxlbmd0aFxudmFyIGd6aGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gMTAgKyAoKG8uZmlsZW5hbWUgJiYgKG8uZmlsZW5hbWUubGVuZ3RoICsgMSkpIHx8IDApOyB9O1xuLy8gemxpYiBoZWFkZXJcbnZhciB6bGggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBsdiA9IG8ubGV2ZWwsIGZsID0gbHYgPT0gMCA/IDAgOiBsdiA8IDYgPyAxIDogbHYgPT0gOSA/IDMgOiAyO1xuICAgIGNbMF0gPSAxMjAsIGNbMV0gPSAoZmwgPDwgNikgfCAoZmwgPyAoMzIgLSAyICogZmwpIDogMSk7XG59O1xuLy8gemxpYiB2YWxpZFxudmFyIHpsdiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKChkWzBdICYgMTUpICE9IDggfHwgKGRbMF0gPj4+IDQpID4gNyB8fCAoKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpKVxuICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIGRhdGEnO1xuICAgIGlmIChkWzFdICYgMzIpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgZGF0YTogcHJlc2V0IGRpY3Rpb25hcmllcyBub3Qgc3VwcG9ydGVkJztcbn07XG5mdW5jdGlvbiBBc3luY0NtcFN0cm0ob3B0cywgY2IpIHtcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgcmV0dXJuIG9wdHM7XG59XG4vLyB6bGliIGZvb3RlcjogLTQgdG8gLTAgaXMgQWRsZXIzMlxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGlmICghY2IgJiYgdHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLm8gPSBvcHRzIHx8IHt9O1xuICAgIH1cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEoZG9wdChjLCB0aGlzLm8sIDAsIDAsICFmKSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB0aGlzLmQgPSBmaW5hbDtcbiAgICAgICAgdGhpcy5wKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBEZWZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IERlZmxhdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNik7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0RlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihkZWZsYXRlU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDAsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggREVGTEFURSB3aXRob3V0IGFueSB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWZsYXRlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGRvcHQoZGF0YSwgb3B0cyB8fCB7fSwgMCwgMCk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmZsYXRlKGNiKSB7XG4gICAgICAgIHRoaXMucyA9IHt9O1xuICAgICAgICB0aGlzLnAgPSBuZXcgdTgoMCk7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIEluZmxhdGUucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB2YXIgbCA9IHRoaXMucC5sZW5ndGg7XG4gICAgICAgIHZhciBuID0gbmV3IHU4KGwgKyBjLmxlbmd0aCk7XG4gICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGMsIGwpLCB0aGlzLnAgPSBuO1xuICAgIH07XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChmaW5hbCkge1xuICAgICAgICB0aGlzLmQgPSB0aGlzLnMuaSA9IGZpbmFsIHx8IGZhbHNlO1xuICAgICAgICB2YXIgYnRzID0gdGhpcy5zLmI7XG4gICAgICAgIHZhciBkdCA9IGluZmx0KHRoaXMucCwgdGhpcy5vLCB0aGlzLnMpO1xuICAgICAgICB0aGlzLm9uZGF0YShzbGMoZHQsIGJ0cywgdGhpcy5zLmIpLCB0aGlzLmQpO1xuICAgICAgICB0aGlzLm8gPSBzbGMoZHQsIHRoaXMucy5iIC0gMzI3NjgpLCB0aGlzLnMuYiA9IHRoaXMuby5sZW5ndGg7XG4gICAgICAgIHRoaXMucCA9IHNsYyh0aGlzLnAsICh0aGlzLnMucCAvIDgpIHwgMCksIHRoaXMucy5wICY9IDc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBpbmZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rXG4gICAgICovXG4gICAgSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5lKGNodW5rKSwgdGhpcy5jKGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEluZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0luZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBJbmZsYXRlKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNyk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0luZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNJbmZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHRcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihpbmZsYXRlU3luYyhldi5kYXRhWzBdLCBndTgoZXYuZGF0YVsxXSkpKTsgfSwgMSwgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIERFRkxBVEUgZGF0YSB3aXRoIG5vIHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEsIG91dCk7XG59XG4vLyBiZWZvcmUgeW91IHllbGwgYXQgbWUgZm9yIG5vdCBqdXN0IHVzaW5nIGV4dGVuZHMsIG15IHJlYXNvbiBpcyB0aGF0IFRTIGluaGVyaXRhbmNlIGlzIGhhcmQgdG8gd29ya2VyaXplLlxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLmwgPSAwO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd6aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgR3ppcC5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMuYy5wKGMpO1xuICAgICAgICB0aGlzLmwgKz0gYy5sZW5ndGg7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIGd6aGwodGhpcy5vKSwgZiAmJiA4LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICBnemgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA4LCB0aGlzLmMuZCgpKSwgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMubCk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gR3ppcDtcbn0oKSk7XG5leHBvcnQgeyBHemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jR3ppcChvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGd6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgR3ppcF07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd6aXAoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d6aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHemlwIH07XG5leHBvcnQgZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgZ3plLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3ppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3ppcFN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAyLCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIEdaSVBcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGd6aXBwZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3ppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBjID0gY3JjKCksIGwgPSBkYXRhLmxlbmd0aDtcbiAgICBjLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIGd6aGwob3B0cyksIDgpLCBzID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuIGd6aChkLCBvcHRzKSwgd2J5dGVzKGQsIHMgLSA4LCBjLmQoKSksIHdieXRlcyhkLCBzIC0gNCwgbCksIGQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEd1bnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR1VOWklQIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdVTlpJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHdW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5wLmxlbmd0aCA+IDMgPyBnenModGhpcy5wKSA6IDQ7XG4gICAgICAgICAgICBpZiAocyA+PSB0aGlzLnAubGVuZ3RoICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkocyksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgZ3ppcCBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC04KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEd1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBHdW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIEdVTlpJUCBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGd1emUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIEd1bnppcF07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgR3VuemlwKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0d1bnppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIGd1emUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtndW56aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd1bnppcFN5bmMoZXYuZGF0YVswXSkpOyB9LCAzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgR1pJUCBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBHWklQIGFscmVhZHkgZW5jb2RlcyB0aGUgb3V0cHV0IHNpemUsIHNvIHByb3ZpZGluZyB0aGlzIGRvZXNuJ3Qgc2F2ZSBtZW1vcnkuXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoZ3pzKGRhdGEpLCAtOCksIG91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpsaWIob3B0cywgY2IpIHtcbiAgICAgICAgdGhpcy5jID0gYWRsZXIoKTtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBabGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIFpsaWIucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgMiwgZiAmJiA0LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICB6bGgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmMuZCgpKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBabGliO1xufSgpKTtcbmV4cG9ydCB7IFpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1psaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgemxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBabGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBBc3luY0NtcFN0cm0uY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgWmxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1psaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNabGliIH07XG5leHBvcnQgZnVuY3Rpb24gemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgemxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoemxpYlN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCA0LCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzIGRhdGEgd2l0aCBabGliXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSB6bGliLWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gemxpYlN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBhID0gYWRsZXIoKTtcbiAgICBhLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnpsaWIoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCAyICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMiksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC00KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemxpYjtcbn0oKSk7XG5leHBvcnQgeyBVbnpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIFpsaWIgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIHp1bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIFVuemxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgVW56bGliKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNVbnpsaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnpsaWIgfTtcbmV4cG9ydCBmdW5jdGlvbiB1bnpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICB6dWxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbdW56bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih1bnpsaWJTeW5jKGV2LmRhdGFbMF0sIGd1OChldi5kYXRhWzFdKSkpOyB9LCA1LCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgWmxpYiBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemxpYlN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KCh6bHYoZGF0YSksIGRhdGEuc3ViYXJyYXkoMiwgLTQpKSwgb3V0KTtcbn1cbi8vIERlZmF1bHQgYWxnb3JpdGhtIGZvciBjb21wcmVzc2lvbiAodXNlZCBiZWNhdXNlIGhhdmluZyBhIGtub3duIG91dHB1dCBzaXplIGFsbG93cyBmYXN0ZXIgZGVjb21wcmVzc2lvbilcbmV4cG9ydCB7IGd6aXAgYXMgY29tcHJlc3MsIEFzeW5jR3ppcCBhcyBBc3luY0NvbXByZXNzIH07XG4vLyBEZWZhdWx0IGFsZ29yaXRobSBmb3IgY29tcHJlc3Npb24gKHVzZWQgYmVjYXVzZSBoYXZpbmcgYSBrbm93biBvdXRwdXQgc2l6ZSBhbGxvd3MgZmFzdGVyIGRlY29tcHJlc3Npb24pXG5leHBvcnQgeyBnemlwU3luYyBhcyBjb21wcmVzc1N5bmMsIEd6aXAgYXMgQ29tcHJlc3MgfTtcbi8qKlxuICogU3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIERlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb21wcmVzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb21wcmVzcyhjYikge1xuICAgICAgICB0aGlzLkcgPSBHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEluZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IFVuemxpYjtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICBpZiAoIXRoaXMucykge1xuICAgICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucCA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHsgX3RoaXNfMS5vbmRhdGEuYXBwbHkoX3RoaXNfMSwgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSAodGhpcy5wWzBdID09IDMxICYmIHRoaXMucFsxXSA9PSAxMzkgJiYgdGhpcy5wWzJdID09IDgpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuRyhjYilcbiAgICAgICAgICAgICAgICAgICAgOiAoKHRoaXMucFswXSAmIDE1KSAhPSA4IHx8ICh0aGlzLnBbMF0gPj4gNCkgPiA3IHx8ICgodGhpcy5wWzBdIDw8IDggfCB0aGlzLnBbMV0pICUgMzEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5JKGNiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5aKGNiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMucHVzaCh0aGlzLnAsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucy5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnQgeyBEZWNvbXByZXNzIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvbXByZXNzZWRcbiAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNEZWNvbXByZXNzKGNiKSB7XG4gICAgICAgIHRoaXMuRyA9IEFzeW5jR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBBc3luY0luZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IEFzeW5jVW56bGliO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY0RlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWNvbXByZXNzIH07XG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzcyhkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBjb21wcmVzc2VkIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRhdGEsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBmb3JtYXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXBTeW5jKGRhdGEsIG91dClcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG91dCk7XG59XG4vLyBmbGF0dGVuIGEgZGlyZWN0b3J5IHN0cnVjdHVyZVxudmFyIGZsdG4gPSBmdW5jdGlvbiAoZCwgcCwgdCwgbykge1xuICAgIGZvciAodmFyIGsgaW4gZCkge1xuICAgICAgICB2YXIgdmFsID0gZFtrXSwgbiA9IHAgKyBrO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgdTgpXG4gICAgICAgICAgICB0W25dID0gW3ZhbCwgb107XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgIHRbbl0gPSBbdmFsWzBdLCBtcmcobywgdmFsWzFdKV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZsdG4odmFsLCBuICsgJy8nLCB0LCBvKTtcbiAgICB9XG59O1xuLy8gdGV4dCBlbmNvZGVyXG52YXIgdGUgPSB0eXBlb2YgVGV4dEVuY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlclxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG52YXIgdGRzID0gMDtcbnRyeSB7XG4gICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB0ZHMgPSAxO1xufVxuY2F0Y2ggKGUpIHsgfVxuLy8gZGVjb2RlIFVURjhcbnZhciBkdXRmOCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgZm9yICh2YXIgciA9ICcnLCBpID0gMDs7KSB7XG4gICAgICAgIHZhciBjID0gZFtpKytdO1xuICAgICAgICB2YXIgZWIgPSAoYyA+IDEyNykgKyAoYyA+IDIyMykgKyAoYyA+IDIzOSk7XG4gICAgICAgIGlmIChpICsgZWIgPiBkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbciwgc2xjKGQsIGkgLSAxKV07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBmaW5hbCA9ICEhZmluYWw7XG4gICAgICAgIGlmICh0aGlzLnQpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKHRoaXMudC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLCBmaW5hbCk7XG4gICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50LmRlY29kZSgpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZGF0ID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBkYXQuc2V0KHRoaXMucCk7XG4gICAgICAgIGRhdC5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICB2YXIgX2EgPSBkdXRmOChkYXQpLCBjaCA9IF9hWzBdLCBucCA9IF9hWzFdO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IG5wO1xuICAgICAgICB0aGlzLm9uZGF0YShjaCwgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29kZVVURjg7XG59KCkpO1xuZXhwb3J0IHsgRGVjb2RlVVRGOCB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZW5jb2RpbmdcbiAqL1xudmFyIEVuY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGVuY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGVuY29kZWQgdG8gVVRGLThcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIHN0cmluZyBkYXRhIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRW5jb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdGhpcy5vbmRhdGEoc3RyVG9VOChjaHVuayksIHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IEVuY29kZVVURjggfTtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkgZm9yIHVzZSB3aXRoIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gbWV0aG9kc1xuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZGVjb2RpbmcgYSBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyBlbmNvZGVkIGluIFVURi04L0xhdGluLTEgYmluYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgYXJfMSA9IG5ldyB1OChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBhcl8xW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBhcl8xO1xuICAgIH1cbiAgICBpZiAodGUpXG4gICAgICAgIHJldHVybiB0ZS5lbmNvZGUoc3RyKTtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGFyID0gbmV3IHU4KHN0ci5sZW5ndGggKyAoc3RyLmxlbmd0aCA+PiAxKSk7XG4gICAgdmFyIGFpID0gMDtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGFyW2FpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYWkgKyA1ID4gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OChhaSArIDggKyAoKGwgLSBpKSA8PCAxKSk7XG4gICAgICAgICAgICBuLnNldChhcik7XG4gICAgICAgICAgICBhciA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjggfHwgbGF0aW4xKVxuICAgICAgICAgICAgdyhjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgICB3KDE5MiB8IChjID4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+IDE4KSksIHcoMTI4IHwgKChjID4+IDEyKSAmIDYzKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4gMTIpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhhciwgMCwgYWkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSBkYXQgVGhlIGRhdGEgdG8gZGVjb2RlIHRvIHN0cmluZ1xuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZW5jb2RpbmcgdG8gYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBVVEYtOC9MYXRpbi0xIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyRnJvbVU4KGRhdCwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdC5sZW5ndGg7IGkgKz0gMTYzODQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0LnN1YmFycmF5KGksIGkgKyAxNjM4NCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGQpXG4gICAgICAgIHJldHVybiB0ZC5kZWNvZGUoZGF0KTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgb3V0ID0gX2FbMF0sIGV4dCA9IF9hWzFdO1xuICAgICAgICBpZiAoZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbjtcbi8vIGRlZmxhdGUgYml0IGZsYWdcbnZhciBkYmYgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbCA9PSAxID8gMyA6IGwgPCA2ID8gMiA6IGwgPT0gOSA/IDEgOiAwOyB9O1xuLy8gc2tpcCBsb2NhbCB6aXAgaGVhZGVyXG52YXIgc2x6aCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiICsgMzAgKyBiMihkLCBiICsgMjYpICsgYjIoZCwgYiArIDI4KTsgfTtcbi8vIHJlYWQgemlwIGhlYWRlclxudmFyIHpoID0gZnVuY3Rpb24gKGQsIGIsIHopIHtcbiAgICB2YXIgZm5sID0gYjIoZCwgYiArIDI4KSwgZm4gPSBzdHJGcm9tVTgoZC5zdWJhcnJheShiICsgNDYsIGIgKyA0NiArIGZubCksICEoYjIoZCwgYiArIDgpICYgMjA0OCkpLCBlcyA9IGIgKyA0NiArIGZubCwgYnMgPSBiNChkLCBiICsgMjApO1xuICAgIHZhciBfYSA9IHogJiYgYnMgPT0gNDI5NDk2NzI5NSA/IHo2NGUoZCwgZXMpIDogW2JzLCBiNChkLCBiICsgMjQpLCBiNChkLCBiICsgNDIpXSwgc2MgPSBfYVswXSwgc3UgPSBfYVsxXSwgb2ZmID0gX2FbMl07XG4gICAgcmV0dXJuIFtiMihkLCBiICsgMTApLCBzYywgc3UsIGZuLCBlcyArIGIyKGQsIGIgKyAzMCkgKyBiMihkLCBiICsgMzIpLCBvZmZdO1xufTtcbi8vIHJlYWQgemlwNjQgZXh0cmEgZmllbGRcbnZhciB6NjRlID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKDsgYjIoZCwgYikgIT0gMTsgYiArPSA0ICsgYjIoZCwgYiArIDIpKVxuICAgICAgICA7XG4gICAgcmV0dXJuIFtiOChkLCBiICsgMTIpLCBiOChkLCBiICsgNCksIGI4KGQsIGIgKyAyMCldO1xufTtcbi8vIGV4dHJhIGZpZWxkIGxlbmd0aFxudmFyIGV4ZmwgPSBmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgbGUgPSAwO1xuICAgIGlmIChleCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgbCA9IGV4W2tdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsID4gNjU1MzUpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2V4dHJhIGZpZWxkIHRvbyBsb25nJztcbiAgICAgICAgICAgIGxlICs9IGwgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZTtcbn07XG4vLyB3cml0ZSB6aXAgaGVhZGVyXG52YXIgd3poID0gZnVuY3Rpb24gKGQsIGIsIGYsIGZuLCB1LCBjLCBjZSwgY28pIHtcbiAgICB2YXIgZmwgPSBmbi5sZW5ndGgsIGV4ID0gZi5leHRyYSwgY29sID0gY28gJiYgY28ubGVuZ3RoO1xuICAgIHZhciBleGwgPSBleGZsKGV4KTtcbiAgICB3Ynl0ZXMoZCwgYiwgY2UgIT0gbnVsbCA/IDB4MjAxNEI1MCA6IDB4NDAzNEI1MCksIGIgKz0gNDtcbiAgICBpZiAoY2UgIT0gbnVsbClcbiAgICAgICAgZFtiKytdID0gMjAsIGRbYisrXSA9IGYub3M7XG4gICAgZFtiXSA9IDIwLCBiICs9IDI7IC8vIHNwZWMgY29tcGxpYW5jZT8gd2hhdCdzIHRoYXQ/XG4gICAgZFtiKytdID0gKGYuZmxhZyA8PCAxKSB8IChjID09IG51bGwgJiYgOCksIGRbYisrXSA9IHUgJiYgODtcbiAgICBkW2IrK10gPSBmLmNvbXByZXNzaW9uICYgMjU1LCBkW2IrK10gPSBmLmNvbXByZXNzaW9uID4+IDg7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoZi5tdGltZSA9PSBudWxsID8gRGF0ZS5ub3coKSA6IGYubXRpbWUpLCB5ID0gZHQuZ2V0RnVsbFllYXIoKSAtIDE5ODA7XG4gICAgaWYgKHkgPCAwIHx8IHkgPiAxMTkpXG4gICAgICAgIHRocm93ICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknO1xuICAgIHdieXRlcyhkLCBiLCAoeSA8PCAyNSkgfCAoKGR0LmdldE1vbnRoKCkgKyAxKSA8PCAyMSkgfCAoZHQuZ2V0RGF0ZSgpIDw8IDE2KSB8IChkdC5nZXRIb3VycygpIDw8IDExKSB8IChkdC5nZXRNaW51dGVzKCkgPDwgNSkgfCAoZHQuZ2V0U2Vjb25kcygpID4+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBmLmNyYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNCwgYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrIC0gYWRkIHRvIFpJUCBhcmNoaXZlIGJlZm9yZSBwdXNoaW5nJztcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICB0aGlzLnNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoZmluYWwpXG4gICAgICAgICAgICB0aGlzLmNyYyA9IHRoaXMuYy5kKCk7XG4gICAgICAgIHRoaXMucHJvY2VzcyhjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFppcFBhc3NUaHJvdWdoIH07XG4vLyBJIGRvbid0IGV4dGVuZCBiZWNhdXNlIFR5cGVTY3JpcHQgZXh0ZW5zaW9uIGFkZHMgMWtCIG9mIHJ1bnRpbWUgYmxvYXRcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIHVzaW5nIEFzeW5jWmlwRGVmbGF0ZVxuICogZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICovXG52YXIgWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBEZWZsYXRlKGZpbGVuYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IERlZmxhdGUob3B0cywgZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICB9XG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIG51bGwsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgWmlwRGVmbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBBc3luY0RlZmxhdGUob3B0cywgZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5kLnRlcm1pbmF0ZTtcbiAgICB9XG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jWmlwRGVmbGF0ZSB9O1xuLy8gVE9ETzogQmV0dGVyIHRyZWUgc2hha2luZ1xuLyoqXG4gKiBBIHppcHBhYmxlIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGluY3JlbWVudGFsbHkgYmUgYWRkZWRcbiAqL1xudmFyIFppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IFpJUCBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGZvciB0aGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gICAgICogICAgICAgICAgIGlzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLnUgPSBbXTtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZpbGUgdG8gdGhlIFpJUCBhcmNoaXZlXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgc3RyZWFtIHRvIGFkZFxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMilcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZmlsZS5maWxlbmFtZSksIGZsID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBmaWxlLmNvbW1lbnQsIG8gPSBjb20gJiYgc3RyVG9VOChjb20pO1xuICAgICAgICB2YXIgdSA9IGZsICE9IGZpbGUuZmlsZW5hbWUubGVuZ3RoIHx8IChvICYmIChjb20ubGVuZ3RoICE9IG8ubGVuZ3RoKSk7XG4gICAgICAgIHZhciBobCA9IGZsICsgZXhmbChmaWxlLmV4dHJhKSArIDMwO1xuICAgICAgICBpZiAoZmwgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBoZWFkZXIgPSBuZXcgdTgoaGwpO1xuICAgICAgICB3emgoaGVhZGVyLCAwLCBmaWxlLCBmLCB1KTtcbiAgICAgICAgdmFyIGNoa3MgPSBbaGVhZGVyXTtcbiAgICAgICAgdmFyIHBBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMSA9IGNoa3M7IF9pIDwgY2hrc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGsgPSBjaGtzXzFbX2ldO1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGNoaywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hrcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHIgPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuZCA9IDA7XG4gICAgICAgIHZhciBpbmQgPSB0aGlzLnUubGVuZ3RoO1xuICAgICAgICB2YXIgdWYgPSBtcmcoZmlsZSwge1xuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIHU6IHUsXG4gICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gX3RoaXNfMS51W2luZCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbnh0LnIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5kID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsID0gMDtcbiAgICAgICAgZmlsZS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICBfdGhpc18xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2wgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaGtzLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gbmV3IHU4KDE2KTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDQsIGZpbGUuY3JjKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA4LCBjbCk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMTIsIGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoa3MucHVzaChkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVmLmMgPSBjbCwgdWYuYiA9IGhsICsgY2wgKyAxNiwgdWYuY3JjID0gZmlsZS5jcmMsIHVmLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmLnIoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnUucHVzaCh1Zik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmRzIHRoZSBwcm9jZXNzIG9mIGFkZGluZyBmaWxlcyBhbmQgcHJlcGFyZXMgdG8gZW1pdCB0aGUgZmluYWwgY2h1bmtzLlxuICAgICAqIFRoaXMgKm11c3QqIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgYWxsIGRlc2lyZWQgZmlsZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAgICAgKiBaSVAgZmlsZSB0byB3b3JrIHByb3Blcmx5LlxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmQgJiAyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGluZyc7XG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhpcy5lKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudS5wdXNoKHtcbiAgICAgICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF90aGlzXzEuZCAmIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLnUuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5lKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0OiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmQgPSAzO1xuICAgIH07XG4gICAgWmlwLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnQgPSAwLCBsID0gMCwgdGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICB0bCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRsICsgMjIpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy51OyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfY1tfYl07XG4gICAgICAgICAgICB3emgob3V0LCBidCwgZiwgZi5mLCBmLnUsIGYuYywgbCwgZi5vKTtcbiAgICAgICAgICAgIGJ0ICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApLCBsICs9IGYuYjtcbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBidCwgdGhpcy51Lmxlbmd0aCwgdGwsIGwpO1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBvdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gdGVybWluYXRlIGFueSBpbnRlcm5hbCB3b3JrZXJzIHVzZWQgYnkgdGhlIHN0cmVhbS4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIGFkZCgpIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgZi50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIHJldHVybiBaaXA7XG59KCkpO1xuZXhwb3J0IHsgWmlwIH07XG5leHBvcnQgZnVuY3Rpb24gemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciByID0ge307XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhyKTtcbiAgICB2YXIgbGZ0ID0gay5sZW5ndGgsIG8gPSAwLCB0b3QgPSAwO1xuICAgIHZhciBzbGZ0ID0gbGZ0LCBmaWxlcyA9IG5ldyBBcnJheShsZnQpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBjYmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgICAgIHRvdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgdG90LCBmLCBmLmYsIGYudSwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0b3QgKyBiYWRkO1xuICAgICAgICAgICAgICAgIG91dC5zZXQoZi5jLCBsb2MpO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBsLCB0b3QsIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKSwgdG90ID0gbG9jICsgbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgICAgIGNiKG51bGwsIG91dCk7XG4gICAgfTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2JmKCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgZm4gPSBrW2ldO1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjID0gY3JjKCksIHNpemUgPSBmaWxlLmxlbmd0aDtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRBbGwoKTtcbiAgICAgICAgICAgICAgICBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlsZXNbaV0gPSBtcmcocCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgICAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2JmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBjYmwoJ2ZpbGVuYW1lIHRvbyBsb25nJywgbnVsbCk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pXG4gICAgICAgICAgICBjYmwobnVsbCwgZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAxNjAwMDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIGRlZmxhdGVTeW5jKGZpbGUsIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRlcm0ucHVzaChkZWZsYXRlKGZpbGUsIHAsIGNibCkpO1xuICAgIH07XG4gICAgLy8gQ2Fubm90IHVzZSBsZnQgYmVjYXVzZSBpdCBjYW4gZGVjcmVhc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBjcmVhdGVzIGEgWklQIGZpbGUuIFByZWZlciB1c2luZyBgemlwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKiB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGZvciB0aGUgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBvcHRzIFRoZSBtYWluIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHBlci1maWxlIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciByID0ge307XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHZhciB0b3QgPSAwO1xuICAgIGZvciAodmFyIGZuIGluIHIpIHtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBkID0gY29tcHJlc3Npb24gPyBkZWZsYXRlU3luYyhmaWxlLCBwKSA6IGZpbGUsIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgdmFyIGMgPSBjcmMoKTtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICBmaWxlcy5wdXNoKG1yZyhwLCB7XG4gICAgICAgICAgICBzaXplOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICB9KSk7XG4gICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICB3emgob3V0LCBmLm8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICBvdXQuc2V0KGYuYywgZi5vICsgYmFkZCk7XG4gICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoLCBmLm8sIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKTtcbiAgICB9XG4gICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgcGFzcy10aHJvdWdoIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgVW56aXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnppcFBhc3NUaHJvdWdoKCkge1xuICAgIH1cbiAgICBVbnppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIFVuemlwUGFzc1Rocm91Z2guY29tcHJlc3Npb24gPSAwO1xuICAgIHJldHVybiBVbnppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwUGFzc1Rocm91Z2ggfTtcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgQXN5bmNaaXBJbmZsYXRlIGZvclxuICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuICovXG52YXIgVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcEluZmxhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwSW5mbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1VuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNVbnppcEluZmxhdGUoXywgc3opIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoc3ogPCAzMjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBBc3luY0luZmxhdGUoZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5pLnRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBc3luY1VuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5pLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgIGRhdGEgPSBzbGMoZGF0YSwgMCk7XG4gICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIEFzeW5jVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gQXN5bmNVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnppcEluZmxhdGUgfTtcbi8qKlxuICogQSBaSVAgYXJjaGl2ZSBkZWNvbXByZXNzaW9uIHN0cmVhbSB0aGF0IGVtaXRzIGZpbGVzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWRcbiAqL1xudmFyIFVuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBaSVAgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgYSBmaWxlIGluIHRoZSBaSVAgYXJjaGl2ZSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25maWxlID0gY2I7XG4gICAgICAgIHRoaXMuayA9IFtdO1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgICAwOiBVbnppcFBhc3NUaHJvdWdoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnppcHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25maWxlKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKHRoaXMuYyA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLmMsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBjaHVuay5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jIC09IGxlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICAgICAgdGhpcy5kLnB1c2godG9BZGQsICF0aGlzLmMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMua1swXS5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSAwLCBpID0gMCwgaXMgPSB2b2lkIDAsIGJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuaztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gdGhpcy5wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5wKSwgYnVmLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IGJ1Zi5sZW5ndGgsIG9jID0gdGhpcy5jLCBhZGQgPSBvYyAmJiB0aGlzLmQ7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IGI0KGJ1ZiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDQwMzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEsIGlzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IGIyKGJ1ZiwgaSArIDYpLCBjbXBfMSA9IGIyKGJ1ZiwgaSArIDgpLCB1ID0gYmYgJiAyMDQ4LCBkZCA9IGJmICYgOCwgZm5sID0gYjIoYnVmLCBpICsgMjYpLCBlcyA9IGIyKGJ1ZiwgaSArIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBpICsgMzAgKyBmbmwgKyBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoa3NfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmsudW5zaGlmdChjaGtzXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NfMSA9IGI0KGJ1ZiwgaSArIDE4KSwgc3VfMSA9IGI0KGJ1ZiwgaSArIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl8xID0gc3RyRnJvbVU4KGJ1Zi5zdWJhcnJheShpICsgMzAsIGkgKz0gMzAgKyBmbmwpLCAhdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA9PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBkZCA/IFstMl0gOiB6NjRlKGJ1ZiwgaSksIHNjXzEgPSBfYVswXSwgc3VfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NfMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gc2NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZV8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZuXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNtcF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZV8xLm9uZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5vbmRhdGEobnVsbCwgZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHIgPSBfdGhpc18xLm9bY21wXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY21wXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEgPSBzY18xIDwgMCA/IG5ldyBjdHIoZm5fMSkgOiBuZXcgY3RyKGZuXzEsIHNjXzEsIHN1XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHsgZmlsZV8xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzMgPSBjaGtzXzI7IF9pIDwgY2hrc18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXQgPSBjaGtzXzNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGRhdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzXzEua1swXSA9PSBjaGtzXzIgJiYgX3RoaXNfMS5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZF8xICYmIGRfMS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLnNpemUgPSBzY18xLCBmaWxlXzEub3JpZ2luYWxTaXplID0gc3VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbmZpbGUoZmlsZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4ODA3NEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpICs9IDEyICsgKG9jID09IC0yICYmIDgpLCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWcgPT0gMHgyMDE0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgLT0gNCwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGwgLSA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgICAgICAgICAgaWYgKG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXQgPSBmID8gYnVmLnN1YmFycmF5KDAsIGlzIC0gMTIgLSAob2MgPT0gLTIgJiYgOCkgLSAoYjQoYnVmLCBpcyAtIDE2KSA9PSAweDgwNzRCNTAgJiYgNCkpIDogYnVmLnN1YmFycmF5KDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpXG4gICAgICAgICAgICAgICAgICAgIGFkZC5wdXNoKGRhdCwgISFmKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua1srKGYgPT0gMildLnB1c2goZGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmICYgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGJ1Zi5zdWJhcnJheShpKSwgZmluYWwpO1xuICAgICAgICAgICAgdGhpcy5wID0gYnVmLnN1YmFycmF5KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYylcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZWNvZGVyIHdpdGggdGhlIHN0cmVhbSwgYWxsb3dpbmcgZm9yIGZpbGVzIGNvbXByZXNzZWQgd2l0aFxuICAgICAqIHRoZSBjb21wcmVzc2lvbiB0eXBlIHByb3ZpZGVkIHRvIGJlIGV4cGFuZGVkIGNvcnJlY3RseVxuICAgICAqIEBwYXJhbSBkZWNvZGVyIFRoZSBkZWNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5vW2RlY29kZXIuY29tcHJlc3Npb25dID0gZGVjb2RlcjtcbiAgICB9O1xuICAgIHJldHVybiBVbnppcDtcbn0oKSk7XG5leHBvcnQgeyBVbnppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZVxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCB0aGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW1tZWRpYXRlbHkgdGVybWluYXRlIHRoZSB1bnppcHBpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB2YXIgbGZ0ID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYihudWxsLCB7fSk7XG4gICAgdmFyIGMgPSBsZnQ7XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIGUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICBpZiAoYjQoZGF0YSwgZSkgIT0gMHg2MDY0QjUwKSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBkO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjXzEpXG4gICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICBlbHNlIGlmIChjXzEgPT0gOCkge1xuICAgICAgICAgICAgdmFyIGluZmwgPSBkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyk7XG4gICAgICAgICAgICBpZiAoc2MgPCAzMjAwMDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgaW5mbGF0ZVN5bmMoaW5mbCwgbmV3IHU4KHN1KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2JsKCd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMSwgbnVsbCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICBfbG9vcF8zKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZS4gUHJlZmVyIHVzaW5nIGB1bnppcGAgZm9yIGJldHRlclxuICogcGVyZm9ybWFuY2Ugd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgcmF3IGNvbXByZXNzZWQgWklQIGZpbGVcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZmlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwU3luYyhkYXRhKSB7XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgfVxuICAgIDtcbiAgICB2YXIgYyA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTU7XG4gICAgaWYgKHopIHtcbiAgICAgICAgZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIGlmIChiNChkYXRhLCBlKSAhPSAweDYwNjRCNTApXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgIGMgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMiA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICBpZiAoIWNfMilcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IHNsYyhkYXRhLCBiLCBiICsgc2MpO1xuICAgICAgICBlbHNlIGlmIChjXzIgPT0gOClcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGluZmxhdGVTeW5jKGRhdGEuc3ViYXJyYXkoYiwgYiArIHNjKSwgbmV3IHU4KHN1KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93ICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMjtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuIl0sIm5hbWVzIjpbImNoMiIsIndrIiwiYyIsImlkIiwibXNnIiwidHJhbnNmZXIiLCJjYiIsInciLCJXb3JrZXIiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwidHlwZSIsIm9uZXJyb3IiLCJlIiwiZXJyb3IiLCJvbm1lc3NhZ2UiLCJkYXRhIiwicG9zdE1lc3NhZ2UiLCJ1OCIsIlVpbnQ4QXJyYXkiLCJ1MTYiLCJVaW50MTZBcnJheSIsInUzMiIsIlVpbnQzMkFycmF5IiwiZmxlYiIsImZkZWIiLCJjbGltIiwiZnJlYiIsImViIiwic3RhcnQiLCJiIiwiaSIsInIiLCJqIiwiX2EiLCJmbCIsInJldmZsIiwiX2IiLCJmZCIsInJldmZkIiwicmV2IiwieCIsImhNYXAiLCJjZCIsIm1iIiwicyIsImxlbmd0aCIsImwiLCJsZSIsImNvIiwicnZiIiwic3YiLCJyXzEiLCJ2IiwibSIsImZsdCIsImZkdCIsImZsbSIsImZscm0iLCJmZG0iLCJmZHJtIiwibWF4IiwiYSIsImJpdHMiLCJkIiwicCIsIm8iLCJiaXRzMTYiLCJzaGZ0Iiwic2xjIiwibiIsInNldCIsInN1YmFycmF5IiwiaW5mbHQiLCJkYXQiLCJidWYiLCJzdCIsInNsIiwibm9CdWYiLCJub1N0IiwiY2J1ZiIsImJsIiwibmJ1ZiIsIk1hdGgiLCJmaW5hbCIsImYiLCJwb3MiLCJidCIsImxtIiwiZG0iLCJsYnQiLCJkYnQiLCJ0YnRzIiwidCIsImhMaXQiLCJoY0xlbiIsInRsIiwibGR0IiwiY2x0IiwiY2xiIiwiY2xibXNrIiwiY2xtIiwibHQiLCJkdCIsImxtcyIsImRtcyIsImxwb3MiLCJzeW0iLCJhZGQiLCJkc3ltIiwiZW5kIiwid2JpdHMiLCJ3Yml0czE2IiwiaFRyZWUiLCJwdXNoIiwidDIiLCJzbGljZSIsImV0Iiwic29ydCIsImkwIiwiaTEiLCJpMiIsIm1heFN5bSIsInRyIiwibWJ0IiwibG4iLCJsZnQiLCJjc3QiLCJpMl8xIiwiaTJfMiIsImkyXzMiLCJsYyIsImNsIiwiY2xpIiwiY2xuIiwiY2xzIiwiY2xlbiIsImNmIiwid2ZibGsiLCJvdXQiLCJ3YmxrIiwic3ltcyIsImxmIiwiZGYiLCJsaSIsImJzIiwiZGx0IiwibWxiIiwiZGR0IiwibWRiIiwiX2MiLCJsY2x0IiwibmxjIiwiX2QiLCJsY2R0IiwibmRjIiwibGNmcmVxIiwiX2UiLCJsY3QiLCJtbGNiIiwibmxjYyIsImZsZW4iLCJmdGxlbiIsImR0bGVuIiwibGwiLCJkbCIsImxsbSIsImxjdHMiLCJpdCIsImNsY3QiLCJsZW4iLCJkc3QiLCJkZW8iLCJkZmx0IiwibHZsIiwicGx2bCIsInByZSIsInBvc3QiLCJsc3QiLCJjZWlsIiwib3B0IiwibXNrXzEiLCJwcmV2IiwiaGVhZCIsImJzMV8xIiwiYnMyXzEiLCJoc2giLCJsY18xIiwid2kiLCJodiIsImltb2QiLCJwaW1vZCIsInJlbSIsImNoXzEiLCJkaWYiLCJtYXhuIiwibWluIiwibWF4ZCIsIm1sIiwibmwiLCJtbWQiLCJtZCIsInRpIiwicHRpIiwibGluIiwiZGluIiwiY3JjdCIsIkludDMyQXJyYXkiLCJrIiwiY3JjIiwiY3IiLCJhZGxlciIsImRvcHQiLCJsZXZlbCIsIm1lbSIsImxvZyIsIm1yZyIsIndjbG4iLCJmbiIsImZuU3RyIiwidGQiLCJ0b1N0cmluZyIsImtzIiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsInNwbGl0Iiwic3RfMSIsInByb3RvdHlwZSIsInNwSW5kIiwiY2giLCJjYmZzIiwiY29uc3RydWN0b3IiLCJidWZmZXIiLCJ3cmtyIiwiZm5zIiwiaW5pdCIsInRkXzEiLCJiSW5mbHQiLCJpbmZsYXRlU3luYyIsInBiZiIsImd1OCIsImJEZmx0IiwiZGVmbGF0ZVN5bmMiLCJnemUiLCJnemgiLCJnemhsIiwid2J5dGVzIiwiZ3V6ZSIsImd6cyIsImd6bCIsInpsZSIsInpsaCIsInp1bGUiLCJ6bHYiLCJzaXplIiwiY2JpZnkiLCJvcHRzIiwiZXJyIiwidGVybWluYXRlIiwiY29uc3VtZSIsImFzdHJtIiwic3RybSIsIm9uZGF0YSIsImV2IiwiYXN0cm1pZnkiLCJjYWxsIiwiYjIiLCJiNCIsImI4IiwiZmlsZW5hbWUiLCJtdGltZSIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNoYXJDb2RlQXQiLCJmbGciLCJ6cyIsImx2IiwiQXN5bmNDbXBTdHJtIiwiRGVmbGF0ZSIsImNodW5rIiwiQXN5bmNEZWZsYXRlIiwiZGVmbGF0ZSIsIkluZmxhdGUiLCJidHMiLCJBc3luY0luZmxhdGUiLCJpbmZsYXRlIiwiR3ppcCIsInJhdyIsIkFzeW5jR3ppcCIsImd6aXAiLCJnemlwU3luYyIsIkd1bnppcCIsIkFzeW5jR3VuemlwIiwiZ3VuemlwIiwiZ3VuemlwU3luYyIsIlpsaWIiLCJBc3luY1psaWIiLCJ6bGliIiwiemxpYlN5bmMiLCJVbnpsaWIiLCJBc3luY1VuemxpYiIsInVuemxpYiIsInVuemxpYlN5bmMiLCJjb21wcmVzcyIsIkFzeW5jQ29tcHJlc3MiLCJjb21wcmVzc1N5bmMiLCJDb21wcmVzcyIsIkRlY29tcHJlc3MiLCJHIiwiSSIsIloiLCJfdGhpc18xIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJBc3luY0RlY29tcHJlc3MiLCJkZWNvbXByZXNzIiwiZGVjb21wcmVzc1N5bmMiLCJmbHRuIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwidGUiLCJUZXh0RW5jb2RlciIsIlRleHREZWNvZGVyIiwidGRzIiwiZGVjb2RlIiwic3RyZWFtIiwiZHV0ZjgiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJEZWNvZGVVVEY4IiwibnAiLCJFbmNvZGVVVEY4Iiwic3RyVG9VOCIsInN0ciIsImxhdGluMSIsImFyXzEiLCJlbmNvZGUiLCJhciIsImFpIiwic3RyRnJvbVU4IiwiZXh0IiwiZGJmIiwic2x6aCIsInpoIiwieiIsImZubCIsImVzIiwiejY0ZSIsInNjIiwic3UiLCJvZmYiLCJleGZsIiwiZXgiLCJ3emgiLCJ1IiwiY2UiLCJleHRyYSIsImNvbCIsImV4bCIsIm9zIiwiZmxhZyIsImNvbXByZXNzaW9uIiwieSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImF0dHJzIiwiZXhmIiwid3pmIiwiWmlwUGFzc1Rocm91Z2giLCJwcm9jZXNzIiwiWmlwRGVmbGF0ZSIsIkFzeW5jWmlwRGVmbGF0ZSIsIlppcCIsImZpbGUiLCJjb20iLCJjb21tZW50IiwiaGwiLCJoZWFkZXIiLCJjaGtzIiwicEFsbCIsIl9pIiwiY2hrc18xIiwiY2hrIiwiaW5kIiwidWYiLCJueHQiLCJkZCIsInNwbGljZSIsInppcCIsIk9iamVjdCIsImtleXMiLCJ0b3QiLCJzbGZ0IiwiZmlsZXMiLCJ0ZXJtIiwidEFsbCIsImNiZiIsIm9lIiwiY2RsIiwiYmFkZCIsImxvYyIsIl9sb29wXzEiLCJtcyIsImNibCIsInppcFN5bmMiLCJVbnppcFBhc3NUaHJvdWdoIiwiVW56aXBJbmZsYXRlIiwiQXN5bmNVbnppcEluZmxhdGUiLCJfIiwic3oiLCJVbnppcCIsIm9uZmlsZSIsInRvQWRkIiwiaXMiLCJvYyIsIl9sb29wXzIiLCJzaWciLCJ0aGlzXzEiLCJiZiIsImNtcF8xIiwiY2hrc18yIiwidW5zaGlmdCIsInNjXzEiLCJzdV8xIiwiZm5fMSIsImRfMSIsImZpbGVfMSIsIm5hbWUiLCJjdHIiLCJjaGtzXzMiLCJvcmlnaW5hbFNpemUiLCJzdGF0ZV8xIiwicmVnaXN0ZXIiLCJkZWNvZGVyIiwidW56aXAiLCJfbG9vcF8zIiwiY18xIiwibm8iLCJpbmZsIiwidW56aXBTeW5jIiwiY18yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/fflate/esm/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\");\n/* harmony import */ var _components_RocketScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @components/RocketScene */ \"(app-pages-browser)/./components/RocketScene.tsx\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/web/KeyboardControls.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Environment.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\nconst page = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_3__.KeyboardControls, {\n            map: [\n                {\n                    name: \"forward\",\n                    keys: [\n                        \"ArrowUp\",\n                        \"KeyW\"\n                    ]\n                },\n                {\n                    name: \"backward\",\n                    keys: [\n                        \"ArrowDown\",\n                        \"KeyS\"\n                    ]\n                },\n                {\n                    name: \"leftward\",\n                    keys: [\n                        \"ArrowLeft\",\n                        \"KeyA\"\n                    ]\n                },\n                {\n                    name: \"rightward\",\n                    keys: [\n                        \"ArrowRight\",\n                        \"KeyD\"\n                    ]\n                },\n                {\n                    name: \"jump\",\n                    keys: [\n                        \"Space\"\n                    ]\n                }\n            ],\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.Canvas, {\n                style: {\n                    width: \"100vw\",\n                    height: \"100vh\",\n                    position: \"fixed\",\n                    inset: 0\n                },\n                flat: true,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_5__.Environment, {\n                        background: false,\n                        files: \"adams_place_bridge_1k.hdr\"\n                    }, void 0, false, {\n                        fileName: \"/Users/robinvanvoorden/Websites/three-js-research/app/page.tsx\",\n                        lineNumber: 30,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_RocketScene__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/robinvanvoorden/Websites/three-js-research/app/page.tsx\",\n                        lineNumber: 32,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/robinvanvoorden/Websites/three-js-research/app/page.tsx\",\n                lineNumber: 21,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/robinvanvoorden/Websites/three-js-research/app/page.tsx\",\n            lineNumber: 12,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/robinvanvoorden/Websites/three-js-research/app/page.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (page);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFaUQ7QUFDTDtBQUVNO0FBQ2dCO0FBRWxFLE1BQU1LLE9BQU87SUFDWCxxQkFDRSw4REFBQ0M7a0JBQ0MsNEVBQUNGLCtEQUFnQkE7WUFDZkcsS0FBSztnQkFDSDtvQkFBRUMsTUFBTTtvQkFBV0MsTUFBTTt3QkFBQzt3QkFBVztxQkFBTztnQkFBQztnQkFDN0M7b0JBQUVELE1BQU07b0JBQVlDLE1BQU07d0JBQUM7d0JBQWE7cUJBQU87Z0JBQUM7Z0JBQ2hEO29CQUFFRCxNQUFNO29CQUFZQyxNQUFNO3dCQUFDO3dCQUFhO3FCQUFPO2dCQUFDO2dCQUNoRDtvQkFBRUQsTUFBTTtvQkFBYUMsTUFBTTt3QkFBQzt3QkFBYztxQkFBTztnQkFBQztnQkFDbEQ7b0JBQUVELE1BQU07b0JBQVFDLE1BQU07d0JBQUM7cUJBQVE7Z0JBQUM7YUFDakM7c0JBRUQsNEVBQUNSLHNEQUFNQTtnQkFDTFMsT0FBTztvQkFDTEMsT0FBTztvQkFDUEMsUUFBUTtvQkFDUkMsVUFBVTtvQkFDVkMsT0FBTztnQkFDVDtnQkFDQUMsSUFBSTs7a0NBRUosOERBQUNaLDBEQUFXQTt3QkFBQ2EsWUFBWTt3QkFBT0MsT0FBTTs7Ozs7O2tDQUV0Qyw4REFBQ2YsK0RBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLdEI7QUFFQSwrREFBZUcsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBDYW52YXMgfSBmcm9tIFwiQHJlYWN0LXRocmVlL2ZpYmVyXCI7XG5cbmltcG9ydCBSb2NrZXRTY2VuZSBmcm9tIFwiQGNvbXBvbmVudHMvUm9ja2V0U2NlbmVcIjtcbmltcG9ydCB7IEVudmlyb25tZW50LCBLZXlib2FyZENvbnRyb2xzIH0gZnJvbSBcIkByZWFjdC10aHJlZS9kcmVpXCI7XG5cbmNvbnN0IHBhZ2UgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxLZXlib2FyZENvbnRyb2xzXG4gICAgICAgIG1hcD17W1xuICAgICAgICAgIHsgbmFtZTogXCJmb3J3YXJkXCIsIGtleXM6IFtcIkFycm93VXBcIiwgXCJLZXlXXCJdIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImJhY2t3YXJkXCIsIGtleXM6IFtcIkFycm93RG93blwiLCBcIktleVNcIl0gfSxcbiAgICAgICAgICB7IG5hbWU6IFwibGVmdHdhcmRcIiwga2V5czogW1wiQXJyb3dMZWZ0XCIsIFwiS2V5QVwiXSB9LFxuICAgICAgICAgIHsgbmFtZTogXCJyaWdodHdhcmRcIiwga2V5czogW1wiQXJyb3dSaWdodFwiLCBcIktleURcIl0gfSxcbiAgICAgICAgICB7IG5hbWU6IFwianVtcFwiLCBrZXlzOiBbXCJTcGFjZVwiXSB9LFxuICAgICAgICBdfVxuICAgICAgPlxuICAgICAgICA8Q2FudmFzXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMHZ3XCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgICAgICAgICBpbnNldDogMCxcbiAgICAgICAgICB9fVxuICAgICAgICAgIGZsYXRcbiAgICAgICAgPlxuICAgICAgICAgIDxFbnZpcm9ubWVudCBiYWNrZ3JvdW5kPXtmYWxzZX0gZmlsZXM9XCJhZGFtc19wbGFjZV9icmlkZ2VfMWsuaGRyXCIgLz5cblxuICAgICAgICAgIDxSb2NrZXRTY2VuZSAvPlxuICAgICAgICA8L0NhbnZhcz5cbiAgICAgIDwvS2V5Ym9hcmRDb250cm9scz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBhZ2U7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJDYW52YXMiLCJSb2NrZXRTY2VuZSIsIkVudmlyb25tZW50IiwiS2V5Ym9hcmRDb250cm9scyIsInBhZ2UiLCJkaXYiLCJtYXAiLCJuYW1lIiwia2V5cyIsInN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJwb3NpdGlvbiIsImluc2V0IiwiZmxhdCIsImJhY2tncm91bmQiLCJmaWxlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: function() { return /* binding */ EXRLoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"(app-pages-browser)/./node_modules/fflate/esm/browser.js\");\n\n\nconst hasColorSpace = \"colorSpace\" in new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(\"EXRLoader.parse: skipped unknown header attribute type '\".concat(attributeType, \"'.\"));\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2SDtBQUN6RjtBQUNwQyxNQUFNUyxnQkFBZ0IsZ0JBQWdCLElBQUlULDBDQUFPQTtBQUNqRCxNQUFNVSxrQkFBa0JULG9EQUFpQkE7SUFLdkNVLE1BQU1DLE1BQU0sRUFBRTtRQUNaLE1BQU1DLGVBQWUsS0FBSztRQUMxQixNQUFNQyxjQUFjRCxnQkFBZ0I7UUFDcEMsTUFBTUUsY0FBYztRQUNwQixNQUFNQyxjQUFjO1FBQ3BCLE1BQU1DLGNBQWMsQ0FBQyxLQUFLRixXQUFVLElBQUs7UUFDekMsTUFBTUcsY0FBYyxLQUFLRjtRQUN6QixNQUFNRyxjQUFjRCxjQUFjO1FBQ2xDLE1BQU1FLFFBQVE7UUFDZCxNQUFNQyxXQUFXLEtBQUtELFFBQVE7UUFDOUIsTUFBTUUsV0FBVyxDQUFDLEtBQUtGLEtBQUksSUFBSztRQUNoQyxNQUFNRyxxQkFBcUI7UUFDM0IsTUFBTUMsb0JBQW9CO1FBQzFCLE1BQU1DLG9CQUFvQixJQUFJRCxvQkFBb0JEO1FBQ2xELE1BQU1HLGFBQWE7UUFDbkIsTUFBTUMsZUFBZTtRQUNyQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLGFBQWE7UUFDbkIsTUFBTUMsWUFBWTtRQUNsQixNQUFNQyxpQkFBaUI7UUFDdkIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxVQUFVO1FBQ2hCLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsTUFBTTtRQUNaLE1BQU1DLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQyxXQUFXO1FBQ3BDLFNBQVNDLHFCQUFxQkMsTUFBTSxFQUFFQyxHQUFHO1lBQ3ZDLElBQUlDLElBQUk7WUFDUixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSTlCLGNBQWMsRUFBRThCLEVBQUc7Z0JBQ3JDLElBQUlBLEtBQUssS0FBS0gsTUFB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QUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7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QUNoQixJQUFJVCxRQUNGQSxPQUFPSSxTQUFTQztRQUNwQjtRQUNBLE9BQU8sS0FBSyxDQUFDUCxLQUFLQyxLQUFLSSxnQkFBZ0JGLFlBQVlDO0lBQ3JEO0lBbjBDQVEsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUM1TixJQUFJLEdBQUc5TSxnREFBYUE7SUFDM0I7QUFpMENGO0FBR0UsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9FWFJMb2FkZXIuanM/NTM3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlLCBEYXRhVGV4dHVyZUxvYWRlciwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBSR0JBRm9ybWF0LCBSZWRGb3JtYXQsIExpbmVhckZpbHRlciwgRGF0YVV0aWxzIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB1bnpsaWJTeW5jIH0gZnJvbSBcImZmbGF0ZVwiO1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IFwiY29sb3JTcGFjZVwiIGluIG5ldyBUZXh0dXJlKCk7XG5jbGFzcyBFWFJMb2FkZXIgZXh0ZW5kcyBEYXRhVGV4dHVyZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLnR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICB9XG4gIHBhcnNlKGJ1ZmZlcikge1xuICAgIGNvbnN0IFVTSE9SVF9SQU5HRSA9IDEgPDwgMTY7XG4gICAgY29uc3QgQklUTUFQX1NJWkUgPSBVU0hPUlRfUkFOR0UgPj4gMztcbiAgICBjb25zdCBIVUZfRU5DQklUUyA9IDE2O1xuICAgIGNvbnN0IEhVRl9ERUNCSVRTID0gMTQ7XG4gICAgY29uc3QgSFVGX0VOQ1NJWkUgPSAoMSA8PCBIVUZfRU5DQklUUykgKyAxO1xuICAgIGNvbnN0IEhVRl9ERUNTSVpFID0gMSA8PCBIVUZfREVDQklUUztcbiAgICBjb25zdCBIVUZfREVDTUFTSyA9IEhVRl9ERUNTSVpFIC0gMTtcbiAgICBjb25zdCBOQklUUyA9IDE2O1xuICAgIGNvbnN0IEFfT0ZGU0VUID0gMSA8PCBOQklUUyAtIDE7XG4gICAgY29uc3QgTU9EX01BU0sgPSAoMSA8PCBOQklUUykgLSAxO1xuICAgIGNvbnN0IFNIT1JUX1pFUk9DT0RFX1JVTiA9IDU5O1xuICAgIGNvbnN0IExPTkdfWkVST0NPREVfUlVOID0gNjM7XG4gICAgY29uc3QgU0hPUlRFU1RfTE9OR19SVU4gPSAyICsgTE9OR19aRVJPQ09ERV9SVU4gLSBTSE9SVF9aRVJPQ09ERV9SVU47XG4gICAgY29uc3QgVUxPTkdfU0laRSA9IDg7XG4gICAgY29uc3QgRkxPQVQzMl9TSVpFID0gNDtcbiAgICBjb25zdCBJTlQzMl9TSVpFID0gNDtcbiAgICBjb25zdCBJTlQxNl9TSVpFID0gMjtcbiAgICBjb25zdCBJTlQ4X1NJWkUgPSAxO1xuICAgIGNvbnN0IFNUQVRJQ19IVUZGTUFOID0gMDtcbiAgICBjb25zdCBERUZMQVRFID0gMTtcbiAgICBjb25zdCBVTktOT1dOID0gMDtcbiAgICBjb25zdCBMT1NTWV9EQ1QgPSAxO1xuICAgIGNvbnN0IFJMRSA9IDI7XG4gICAgY29uc3QgbG9nQmFzZSA9IE1hdGgucG93KDIuNzE4MjgxOCwgMi4yKTtcbiAgICBmdW5jdGlvbiByZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCkge1xuICAgICAgdmFyIGsgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBVU0hPUlRfUkFOR0U7ICsraSkge1xuICAgICAgICBpZiAoaSA9PSAwIHx8IGJpdG1hcFtpID4+IDNdICYgMSA8PCAoaSAmIDcpKSB7XG4gICAgICAgICAgbHV0W2srK10gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbiA9IGsgLSAxO1xuICAgICAgd2hpbGUgKGsgPCBVU0hPUlRfUkFOR0UpXG4gICAgICAgIGx1dFtrKytdID0gMDtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZDbGVhckRlY1RhYmxlKGhkZWMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0RFQ1NJWkU7IGkrKykge1xuICAgICAgICBoZGVjW2ldID0ge307XG4gICAgICAgIGhkZWNbaV0ubGVuID0gMDtcbiAgICAgICAgaGRlY1tpXS5saXQgPSAwO1xuICAgICAgICBoZGVjW2ldLnAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBnZXRCaXRzUmV0dXJuID0geyBsOiAwLCBjOiAwLCBsYzogMCB9O1xuICAgIGZ1bmN0aW9uIGdldEJpdHMobkJpdHMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpIHtcbiAgICAgIHdoaWxlIChsYyA8IG5CaXRzKSB7XG4gICAgICAgIGMgPSBjIDw8IDggfCBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgbGMgKz0gODtcbiAgICAgIH1cbiAgICAgIGxjIC09IG5CaXRzO1xuICAgICAgZ2V0Qml0c1JldHVybi5sID0gYyA+PiBsYyAmICgxIDw8IG5CaXRzKSAtIDE7XG4gICAgICBnZXRCaXRzUmV0dXJuLmMgPSBjO1xuICAgICAgZ2V0Qml0c1JldHVybi5sYyA9IGxjO1xuICAgIH1cbiAgICBjb25zdCBodWZUYWJsZUJ1ZmZlciA9IG5ldyBBcnJheSg1OSk7XG4gICAgZnVuY3Rpb24gaHVmQ2Fub25pY2FsQ29kZVRhYmxlKGhjb2RlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA1ODsgKytpKVxuICAgICAgICBodWZUYWJsZUJ1ZmZlcltpXSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9FTkNTSVpFOyArK2kpXG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2hjb2RlW2ldXSArPSAxO1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDU4OyBpID4gMDsgLS1pKSB7XG4gICAgICAgIHZhciBuYyA9IGMgKyBodWZUYWJsZUJ1ZmZlcltpXSA+PiAxO1xuICAgICAgICBodWZUYWJsZUJ1ZmZlcltpXSA9IGM7XG4gICAgICAgIGMgPSBuYztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSkge1xuICAgICAgICB2YXIgbCA9IGhjb2RlW2ldO1xuICAgICAgICBpZiAobCA+IDApXG4gICAgICAgICAgaGNvZGVbaV0gPSBsIHwgaHVmVGFibGVCdWZmZXJbbF0rKyA8PCA2O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGhjb2RlKSB7XG4gICAgICB2YXIgcCA9IGluT2Zmc2V0O1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgdmFyIGxjID0gMDtcbiAgICAgIGZvciAoOyBpbSA8PSBpTTsgaW0rKykge1xuICAgICAgICBpZiAocC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBnZXRCaXRzKDYsIGMsIGxjLCB1SW50OEFycmF5MiwgcCk7XG4gICAgICAgIHZhciBsID0gZ2V0Qml0c1JldHVybi5sO1xuICAgICAgICBjID0gZ2V0Qml0c1JldHVybi5jO1xuICAgICAgICBsYyA9IGdldEJpdHNSZXR1cm4ubGM7XG4gICAgICAgIGhjb2RlW2ltXSA9IGw7XG4gICAgICAgIGlmIChsID09IExPTkdfWkVST0NPREVfUlVOKSB7XG4gICAgICAgICAgaWYgKHAudmFsdWUgLSBpbk9mZnNldC52YWx1ZSA+IG5pKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdldEJpdHMoOCwgYywgbGMsIHVJbnQ4QXJyYXkyLCBwKTtcbiAgICAgICAgICB2YXIgemVydW4gPSBnZXRCaXRzUmV0dXJuLmwgKyBTSE9SVEVTVF9MT05HX1JVTjtcbiAgICAgICAgICBjID0gZ2V0Qml0c1JldHVybi5jO1xuICAgICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sYztcbiAgICAgICAgICBpZiAoaW0gKyB6ZXJ1biA+IGlNICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSlcbiAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICBpbS0tO1xuICAgICAgICB9IGVsc2UgaWYgKGwgPj0gU0hPUlRfWkVST0NPREVfUlVOKSB7XG4gICAgICAgICAgdmFyIHplcnVuID0gbCAtIFNIT1JUX1pFUk9DT0RFX1JVTiArIDI7XG4gICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHplcnVuLS0pXG4gICAgICAgICAgICBoY29kZVtpbSsrXSA9IDA7XG4gICAgICAgICAgaW0tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaHVmQ2Fub25pY2FsQ29kZVRhYmxlKGhjb2RlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmTGVuZ3RoKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlICYgNjM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkNvZGUoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgPj4gNjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQnVpbGREZWNUYWJsZShoY29kZSwgaW0sIGlNLCBoZGVjb2QpIHtcbiAgICAgIGZvciAoOyBpbSA8PSBpTTsgaW0rKykge1xuICAgICAgICB2YXIgYyA9IGh1ZkNvZGUoaGNvZGVbaW1dKTtcbiAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoaGNvZGVbaW1dKTtcbiAgICAgICAgaWYgKGMgPj4gbCkge1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsID4gSFVGX0RFQ0JJVFMpIHtcbiAgICAgICAgICB2YXIgcGwgPSBoZGVjb2RbYyA+PiBsIC0gSFVGX0RFQ0JJVFNdO1xuICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwbC5saXQrKztcbiAgICAgICAgICBpZiAocGwucCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwbC5wO1xuICAgICAgICAgICAgcGwucCA9IG5ldyBBcnJheShwbC5saXQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbC5saXQgLSAxOyArK2kpIHtcbiAgICAgICAgICAgICAgcGwucFtpXSA9IHBbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsLnAgPSBuZXcgQXJyYXkoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsLnBbcGwubGl0IC0gMV0gPSBpbTtcbiAgICAgICAgfSBlbHNlIGlmIChsKSB7XG4gICAgICAgICAgdmFyIHBsT2Zmc2V0ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMSA8PCBIVUZfREVDQklUUyAtIGw7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFsoYyA8PCBIVUZfREVDQklUUyAtIGwpICsgcGxPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKHBsLmxlbiB8fCBwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YWJsZSBlbnRyeVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGwubGVuID0gbDtcbiAgICAgICAgICAgIHBsLmxpdCA9IGltO1xuICAgICAgICAgICAgcGxPZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBnZXRDaGFyUmV0dXJuID0geyBjOiAwLCBsYzogMCB9O1xuICAgIGZ1bmN0aW9uIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCkge1xuICAgICAgYyA9IGMgPDwgOCB8IHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgbGMgKz0gODtcbiAgICAgIGdldENoYXJSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRDaGFyUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGNvbnN0IGdldENvZGVSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Q29kZShwbywgcmxjLCBjLCBsYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dEJ1ZmZlck9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICBpZiAocG8gPT0gcmxjKSB7XG4gICAgICAgIGlmIChsYyA8IDgpIHtcbiAgICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuICAgICAgICB9XG4gICAgICAgIGxjIC09IDg7XG4gICAgICAgIHZhciBjcyA9IGMgPj4gbGM7XG4gICAgICAgIHZhciBjcyA9IG5ldyBVaW50OEFycmF5KFtjc10pWzBdO1xuICAgICAgICBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlICsgY3MgPiBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlIC0gMV07XG4gICAgICAgIHdoaWxlIChjcy0tID4gMCkge1xuICAgICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG91dEJ1ZmZlck9mZnNldC52YWx1ZSA8IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlKytdID0gcG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnZXRDb2RlUmV0dXJuLmMgPSBjO1xuICAgICAgZ2V0Q29kZVJldHVybi5sYyA9IGxjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVSW50MTYodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmIDY1NTM1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnQxNih2YWx1ZSkge1xuICAgICAgdmFyIHJlZiA9IFVJbnQxNih2YWx1ZSk7XG4gICAgICByZXR1cm4gcmVmID4gMzI3NjcgPyByZWYgLSA2NTUzNiA6IHJlZjtcbiAgICB9XG4gICAgY29uc3Qgd2RlYzE0UmV0dXJuID0geyBhOiAwLCBiOiAwIH07XG4gICAgZnVuY3Rpb24gd2RlYzE0KGwsIGgpIHtcbiAgICAgIHZhciBscyA9IEludDE2KGwpO1xuICAgICAgdmFyIGhzID0gSW50MTYoaCk7XG4gICAgICB2YXIgaGkgPSBocztcbiAgICAgIHZhciBhaSA9IGxzICsgKGhpICYgMSkgKyAoaGkgPj4gMSk7XG4gICAgICB2YXIgYXMgPSBhaTtcbiAgICAgIHZhciBicyA9IGFpIC0gaGk7XG4gICAgICB3ZGVjMTRSZXR1cm4uYSA9IGFzO1xuICAgICAgd2RlYzE0UmV0dXJuLmIgPSBicztcbiAgICB9XG4gICAgZnVuY3Rpb24gd2RlYzE2KGwsIGgpIHtcbiAgICAgIHZhciBtID0gVUludDE2KGwpO1xuICAgICAgdmFyIGQgPSBVSW50MTYoaCk7XG4gICAgICB2YXIgYmIgPSBtIC0gKGQgPj4gMSkgJiBNT0RfTUFTSztcbiAgICAgIHZhciBhYSA9IGQgKyBiYiAtIEFfT0ZGU0VUICYgTU9EX01BU0s7XG4gICAgICB3ZGVjMTRSZXR1cm4uYSA9IGFhO1xuICAgICAgd2RlYzE0UmV0dXJuLmIgPSBiYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2F2MkRlY29kZShidWZmZXIyLCBqLCBueCwgb3gsIG55LCBveSwgbXgpIHtcbiAgICAgIHZhciB3MTQgPSBteCA8IDEgPDwgMTQ7XG4gICAgICB2YXIgbiA9IG54ID4gbnkgPyBueSA6IG54O1xuICAgICAgdmFyIHAgPSAxO1xuICAgICAgdmFyIHAyO1xuICAgICAgd2hpbGUgKHAgPD0gbilcbiAgICAgICAgcCA8PD0gMTtcbiAgICAgIHAgPj49IDE7XG4gICAgICBwMiA9IHA7XG4gICAgICBwID4+PSAxO1xuICAgICAgd2hpbGUgKHAgPj0gMSkge1xuICAgICAgICB2YXIgcHkgPSAwO1xuICAgICAgICB2YXIgZXkgPSBweSArIG95ICogKG55IC0gcDIpO1xuICAgICAgICB2YXIgb3kxID0gb3kgKiBwO1xuICAgICAgICB2YXIgb3kyID0gb3kgKiBwMjtcbiAgICAgICAgdmFyIG94MSA9IG94ICogcDtcbiAgICAgICAgdmFyIG94MiA9IG94ICogcDI7XG4gICAgICAgIHZhciBpMDAsIGkwMSwgaTEwLCBpMTE7XG4gICAgICAgIGZvciAoOyBweSA8PSBleTsgcHkgKz0gb3kyKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHk7XG4gICAgICAgICAgdmFyIGV4ID0gcHkgKyBveCAqIChueCAtIHAyKTtcbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgdmFyIHAxMCA9IHB4ICsgb3kxO1xuICAgICAgICAgICAgdmFyIHAxMSA9IHAxMCArIG94MTtcbiAgICAgICAgICAgIGlmICh3MTQpIHtcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTAgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcDAxICsgal0sIGJ1ZmZlcjJbcDExICsgal0pO1xuICAgICAgICAgICAgICBpMDEgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTExID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNChpMDAsIGkwMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNChpMTAsIGkxMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDEwICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTAgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcDAxICsgal0sIGJ1ZmZlcjJbcDExICsgal0pO1xuICAgICAgICAgICAgICBpMDEgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTExID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNihpMDAsIGkwMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNihpMTAsIGkxMSk7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDEwICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnggJiBwKSB7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTE7XG4gICAgICAgICAgICBpZiAodzE0KVxuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcDEwICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IGkwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG55ICYgcCkge1xuICAgICAgICAgIHZhciBweCA9IHB5O1xuICAgICAgICAgIHZhciBleCA9IHB5ICsgb3ggKiAobnggLSBwMik7XG4gICAgICAgICAgZm9yICg7IHB4IDw9IGV4OyBweCArPSBveDIpIHtcbiAgICAgICAgICAgIHZhciBwMDEgPSBweCArIG94MTtcbiAgICAgICAgICAgIGlmICh3MTQpXG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDAxICsgal0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AwMSArIGpdKTtcbiAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgYnVmZmVyMltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gaTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwMiA9IHA7XG4gICAgICAgIHAgPj49IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkRlY29kZShlbmNvZGluZ1RhYmxlLCBkZWNvZGluZ1RhYmxlLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBybGMsIG5vLCBvdXRCdWZmZXIsIG91dE9mZnNldCkge1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgdmFyIGxjID0gMDtcbiAgICAgIHZhciBvdXRCdWZmZXJFbmRPZmZzZXQgPSBubztcbiAgICAgIHZhciBpbk9mZnNldEVuZCA9IE1hdGgudHJ1bmMoaW5PZmZzZXQudmFsdWUgKyAobmkgKyA3KSAvIDgpO1xuICAgICAgd2hpbGUgKGluT2Zmc2V0LnZhbHVlIDwgaW5PZmZzZXRFbmQpIHtcbiAgICAgICAgZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuICAgICAgICB3aGlsZSAobGMgPj0gSFVGX0RFQ0JJVFMpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBjID4+IGxjIC0gSFVGX0RFQ0JJVFMgJiBIVUZfREVDTUFTSztcbiAgICAgICAgICB2YXIgcGwgPSBkZWNvZGluZ1RhYmxlW2luZGV4XTtcbiAgICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgICBsYyAtPSBwbC5sZW47XG4gICAgICAgICAgICBnZXRDb2RlKHBsLmxpdCwgcmxjLCBjLCBsYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcGwucCkge1xuICAgICAgICAgICAgICB0aHJvdyBcImh1ZkRlY29kZSBpc3N1ZXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBsLmxpdDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBsID0gaHVmTGVuZ3RoKGVuY29kaW5nVGFibGVbcGwucFtqXV0pO1xuICAgICAgICAgICAgICB3aGlsZSAobGMgPCBsICYmIGluT2Zmc2V0LnZhbHVlIDwgaW5PZmZzZXRFbmQpIHtcbiAgICAgICAgICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmM7XG4gICAgICAgICAgICAgICAgbGMgPSBnZXRDaGFyUmV0dXJuLmxjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsYyA+PSBsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGh1ZkNvZGUoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSkgPT0gKGMgPj4gbGMgLSBsICYgKDEgPDwgbCkgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgbGMgLT0gbDtcbiAgICAgICAgICAgICAgICAgIGdldENvZGUoXG4gICAgICAgICAgICAgICAgICAgIHBsLnBbal0sXG4gICAgICAgICAgICAgICAgICAgIHJsYyxcbiAgICAgICAgICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICAgICAgICAgbGMsXG4gICAgICAgICAgICAgICAgICAgIHVJbnQ4QXJyYXkyLFxuICAgICAgICAgICAgICAgICAgICBpbkRhdGFWaWV3LFxuICAgICAgICAgICAgICAgICAgICBpbk9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICBvdXRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlckVuZE9mZnNldFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGM7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqID09IHBsLmxpdCkge1xuICAgICAgICAgICAgICB0aHJvdyBcImh1ZkRlY29kZSBpc3N1ZXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpID0gOCAtIG5pICYgNztcbiAgICAgIGMgPj49IGk7XG4gICAgICBsYyAtPSBpO1xuICAgICAgd2hpbGUgKGxjID4gMCkge1xuICAgICAgICB2YXIgcGwgPSBkZWNvZGluZ1RhYmxlW2MgPDwgSFVGX0RFQ0JJVFMgLSBsYyAmIEhVRl9ERUNNQVNLXTtcbiAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICBnZXRDb2RlKHBsLmxpdCwgcmxjLCBjLCBsYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBvdXRCdWZmZXIsIG91dE9mZnNldCwgb3V0QnVmZmVyRW5kT2Zmc2V0KTtcbiAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jO1xuICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcImh1ZkRlY29kZSBpc3N1ZXNcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZlVuY29tcHJlc3ModUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuQ29tcHJlc3NlZCwgb3V0QnVmZmVyLCBuUmF3KSB7XG4gICAgICB2YXIgb3V0T2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgICAgdmFyIGluaXRpYWxJbk9mZnNldCA9IGluT2Zmc2V0LnZhbHVlO1xuICAgICAgdmFyIGltID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgdmFyIGlNID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaW5PZmZzZXQudmFsdWUgKz0gNDtcbiAgICAgIHZhciBuQml0cyA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGluT2Zmc2V0LnZhbHVlICs9IDQ7XG4gICAgICBpZiAoaW0gPCAwIHx8IGltID49IEhVRl9FTkNTSVpFIHx8IGlNIDwgMCB8fCBpTSA+PSBIVUZfRU5DU0laRSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIEhVRl9FTkNTSVpFXCI7XG4gICAgICB9XG4gICAgICB2YXIgZnJlcSA9IG5ldyBBcnJheShIVUZfRU5DU0laRSk7XG4gICAgICB2YXIgaGRlYyA9IG5ldyBBcnJheShIVUZfREVDU0laRSk7XG4gICAgICBodWZDbGVhckRlY1RhYmxlKGhkZWMpO1xuICAgICAgdmFyIG5pID0gbkNvbXByZXNzZWQgLSAoaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQpO1xuICAgICAgaHVmVW5wYWNrRW5jVGFibGUodUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuaSwgaW0sIGlNLCBmcmVxKTtcbiAgICAgIGlmIChuQml0cyA+IDggKiAobkNvbXByZXNzZWQgLSAoaW5PZmZzZXQudmFsdWUgLSBpbml0aWFsSW5PZmZzZXQpKSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVuY29tcHJlc3NcIjtcbiAgICAgIH1cbiAgICAgIGh1ZkJ1aWxkRGVjVGFibGUoZnJlcSwgaW0sIGlNLCBoZGVjKTtcbiAgICAgIGh1ZkRlY29kZShmcmVxLCBoZGVjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5CaXRzLCBpTSwgblJhdywgb3V0QnVmZmVyLCBvdXRPZmZzZXQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseUx1dChsdXQsIGRhdGEsIG5EYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5EYXRhOyArK2kpIHtcbiAgICAgICAgZGF0YVtpXSA9IGx1dFtkYXRhW2ldXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlZGljdG9yKHNvdXJjZSkge1xuICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBzb3VyY2UubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgdmFyIGQgPSBzb3VyY2VbdCAtIDFdICsgc291cmNlW3RdIC0gMTI4O1xuICAgICAgICBzb3VyY2VbdF0gPSBkO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcmxlYXZlU2NhbGFyKHNvdXJjZSwgb3V0KSB7XG4gICAgICB2YXIgdDEgPSAwO1xuICAgICAgdmFyIHQyID0gTWF0aC5mbG9vcigoc291cmNlLmxlbmd0aCArIDEpIC8gMik7XG4gICAgICB2YXIgcyA9IDA7XG4gICAgICB2YXIgc3RvcCA9IHNvdXJjZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHMgPiBzdG9wKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdXRbcysrXSA9IHNvdXJjZVt0MSsrXTtcbiAgICAgICAgaWYgKHMgPiBzdG9wKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBvdXRbcysrXSA9IHNvdXJjZVt0MisrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlUnVuTGVuZ3RoKHNvdXJjZSkge1xuICAgICAgdmFyIHNpemUgPSBzb3VyY2UuYnl0ZUxlbmd0aDtcbiAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRGF0YVZpZXcoc291cmNlKTtcbiAgICAgIHdoaWxlIChzaXplID4gMCkge1xuICAgICAgICB2YXIgbCA9IHJlYWRlci5nZXRJbnQ4KHArKyk7XG4gICAgICAgIGlmIChsIDwgMCkge1xuICAgICAgICAgIHZhciBjb3VudCA9IC1sO1xuICAgICAgICAgIHNpemUgLT0gY291bnQgKyAxO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2gocmVhZGVyLmdldFVpbnQ4KHArKykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY291bnQgPSBsO1xuICAgICAgICAgIHNpemUgLT0gMjtcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZWFkZXIuZ2V0VWludDgocCsrKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb3NzeURjdERlY29kZShjc2NTZXQsIHJvd1B0cnMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlcikge1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpO1xuICAgICAgdmFyIHdpZHRoID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFswXV0ud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFswXV0uaGVpZ2h0O1xuICAgICAgdmFyIG51bUNvbXAgPSAzO1xuICAgICAgdmFyIG51bUZ1bGxCbG9ja3NYID0gTWF0aC5mbG9vcih3aWR0aCAvIDgpO1xuICAgICAgdmFyIG51bUJsb2Nrc1ggPSBNYXRoLmNlaWwod2lkdGggLyA4KTtcbiAgICAgIHZhciBudW1CbG9ja3NZID0gTWF0aC5jZWlsKGhlaWdodCAvIDgpO1xuICAgICAgdmFyIGxlZnRvdmVyWCA9IHdpZHRoIC0gKG51bUJsb2Nrc1ggLSAxKSAqIDg7XG4gICAgICB2YXIgbGVmdG92ZXJZID0gaGVpZ2h0IC0gKG51bUJsb2Nrc1kgLSAxKSAqIDg7XG4gICAgICB2YXIgY3VyckFjQ29tcCA9IHsgdmFsdWU6IDAgfTtcbiAgICAgIHZhciBjdXJyRGNDb21wID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIGRjdERhdGEgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgaGFsZlppZ0Jsb2NrID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIHJvd0Jsb2NrID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIHJvd09mZnNldHMgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICByb3dPZmZzZXRzW2NvbXAyXSA9IHJvd1B0cnNbY3NjU2V0LmlkeFtjb21wMl1dO1xuICAgICAgICBjdXJyRGNDb21wW2NvbXAyXSA9IGNvbXAyIDwgMSA/IDAgOiBjdXJyRGNDb21wW2NvbXAyIC0gMV0gKyBudW1CbG9ja3NYICogbnVtQmxvY2tzWTtcbiAgICAgICAgZGN0RGF0YVtjb21wMl0gPSBuZXcgRmxvYXQzMkFycmF5KDY0KTtcbiAgICAgICAgaGFsZlppZ0Jsb2NrW2NvbXAyXSA9IG5ldyBVaW50MTZBcnJheSg2NCk7XG4gICAgICAgIHJvd0Jsb2NrW2NvbXAyXSA9IG5ldyBVaW50MTZBcnJheShudW1CbG9ja3NYICogNjQpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgYmxvY2t5ID0gMDsgYmxvY2t5IDwgbnVtQmxvY2tzWTsgKytibG9ja3kpIHtcbiAgICAgICAgdmFyIG1heFkgPSA4O1xuICAgICAgICBpZiAoYmxvY2t5ID09IG51bUJsb2Nrc1kgLSAxKVxuICAgICAgICAgIG1heFkgPSBsZWZ0b3Zlclk7XG4gICAgICAgIHZhciBtYXhYID0gODtcbiAgICAgICAgZm9yIChsZXQgYmxvY2t4ID0gMDsgYmxvY2t4IDwgbnVtQmxvY2tzWDsgKytibG9ja3gpIHtcbiAgICAgICAgICBpZiAoYmxvY2t4ID09IG51bUJsb2Nrc1ggLSAxKVxuICAgICAgICAgICAgbWF4WCA9IGxlZnRvdmVyWDtcbiAgICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgICAgaGFsZlppZ0Jsb2NrW2NvbXAyXS5maWxsKDApO1xuICAgICAgICAgICAgaGFsZlppZ0Jsb2NrW2NvbXAyXVswXSA9IGRjQnVmZmVyW2N1cnJEY0NvbXBbY29tcDJdKytdO1xuICAgICAgICAgICAgdW5SbGVBQyhjdXJyQWNDb21wLCBhY0J1ZmZlciwgaGFsZlppZ0Jsb2NrW2NvbXAyXSk7XG4gICAgICAgICAgICB1blppZ1phZyhoYWxmWmlnQmxvY2tbY29tcDJdLCBkY3REYXRhW2NvbXAyXSk7XG4gICAgICAgICAgICBkY3RJbnZlcnNlKGRjdERhdGFbY29tcDJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAge1xuICAgICAgICAgICAgY3NjNzA5SW52ZXJzZShkY3REYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICAgIGNvbnZlcnRUb0hhbGYoZGN0RGF0YVtjb21wMl0sIHJvd0Jsb2NrW2NvbXAyXSwgYmxvY2t4ICogNjQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0MiA9IDA7XG4gICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgY29uc3QgdHlwZTIgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXAyXV0udHlwZTtcbiAgICAgICAgICBmb3IgKGxldCB5MiA9IDggKiBibG9ja3k7IHkyIDwgOCAqIGJsb2NreSArIG1heFk7ICsreTIpIHtcbiAgICAgICAgICAgIG9mZnNldDIgPSByb3dPZmZzZXRzW2NvbXAyXVt5Ml07XG4gICAgICAgICAgICBmb3IgKGxldCBibG9ja3ggPSAwOyBibG9ja3ggPCBudW1GdWxsQmxvY2tzWDsgKytibG9ja3gpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gYmxvY2t4ICogNjQgKyAoeTIgJiA3KSAqIDg7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMCAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDBdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAxICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMV0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDIgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAyXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMyAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDNdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA0ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNF0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDUgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA1XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDZdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA3ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgN10sIHRydWUpO1xuICAgICAgICAgICAgICBvZmZzZXQyICs9IDggKiBJTlQxNl9TSVpFICogdHlwZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudW1GdWxsQmxvY2tzWCAhPSBudW1CbG9ja3NYKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5MiA9IDggKiBibG9ja3k7IHkyIDwgOCAqIGJsb2NreSArIG1heFk7ICsreTIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MyA9IHJvd09mZnNldHNbY29tcDJdW3kyXSArIDggKiBudW1GdWxsQmxvY2tzWCAqIElOVDE2X1NJWkUgKiB0eXBlMjtcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gbnVtRnVsbEJsb2Nrc1ggKiA2NCArICh5MiAmIDcpICogODtcbiAgICAgICAgICAgICAgZm9yIChsZXQgeDIgPSAwOyB4MiA8IG1heFg7ICsreDIpIHtcbiAgICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MyArIHgyICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgeDJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGhhbGZSb3cgPSBuZXcgVWludDE2QXJyYXkod2lkdGgpO1xuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpO1xuICAgICAgZm9yICh2YXIgY29tcCA9IDA7IGNvbXAgPCBudW1Db21wOyArK2NvbXApIHtcbiAgICAgICAgY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wXV0uZGVjb2RlZCA9IHRydWU7XG4gICAgICAgIHZhciB0eXBlID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wXV0udHlwZTtcbiAgICAgICAgaWYgKGNoYW5uZWxEYXRhW2NvbXBdLnR5cGUgIT0gMilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSByb3dPZmZzZXRzW2NvbXBdW3ldO1xuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgaGFsZlJvd1t4XSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQyICsgeCAqIElOVDE2X1NJWkUgKiB0eXBlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBkYXRhVmlldy5zZXRGbG9hdDMyKG9mZnNldDIgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIGRlY29kZUZsb2F0MTYoaGFsZlJvd1t4XSksIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2spIHtcbiAgICAgIHZhciBhY1ZhbHVlO1xuICAgICAgdmFyIGRjdENvbXAgPSAxO1xuICAgICAgd2hpbGUgKGRjdENvbXAgPCA2NCkge1xuICAgICAgICBhY1ZhbHVlID0gYWNCdWZmZXJbY3VyckFjQ29tcC52YWx1ZV07XG4gICAgICAgIGlmIChhY1ZhbHVlID09IDY1MjgwKSB7XG4gICAgICAgICAgZGN0Q29tcCA9IDY0O1xuICAgICAgICB9IGVsc2UgaWYgKGFjVmFsdWUgPj4gOCA9PSAyNTUpIHtcbiAgICAgICAgICBkY3RDb21wICs9IGFjVmFsdWUgJiAyNTU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFsZlppZ0Jsb2NrW2RjdENvbXBdID0gYWNWYWx1ZTtcbiAgICAgICAgICBkY3RDb21wKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VyckFjQ29tcC52YWx1ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1blppZ1phZyhzcmMsIGRzdCkge1xuICAgICAgZHN0WzBdID0gZGVjb2RlRmxvYXQxNihzcmNbMF0pO1xuICAgICAgZHN0WzFdID0gZGVjb2RlRmxvYXQxNihzcmNbMV0pO1xuICAgICAgZHN0WzJdID0gZGVjb2RlRmxvYXQxNihzcmNbNV0pO1xuICAgICAgZHN0WzNdID0gZGVjb2RlRmxvYXQxNihzcmNbNl0pO1xuICAgICAgZHN0WzRdID0gZGVjb2RlRmxvYXQxNihzcmNbMTRdKTtcbiAgICAgIGRzdFs1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE1XSk7XG4gICAgICBkc3RbNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1syN10pO1xuICAgICAgZHN0WzddID0gZGVjb2RlRmxvYXQxNihzcmNbMjhdKTtcbiAgICAgIGRzdFs4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzJdKTtcbiAgICAgIGRzdFs5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzRdKTtcbiAgICAgIGRzdFsxMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s3XSk7XG4gICAgICBkc3RbMTFdID0gZGVjb2RlRmxvYXQxNihzcmNbMTNdKTtcbiAgICAgIGRzdFsxMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNl0pO1xuICAgICAgZHN0WzEzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzI2XSk7XG4gICAgICBkc3RbMTRdID0gZGVjb2RlRmxvYXQxNihzcmNbMjldKTtcbiAgICAgIGRzdFsxNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Ml0pO1xuICAgICAgZHN0WzE2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzNdKTtcbiAgICAgIGRzdFsxN10gPSBkZWNvZGVGbG9hdDE2KHNyY1s4XSk7XG4gICAgICBkc3RbMThdID0gZGVjb2RlRmxvYXQxNihzcmNbMTJdKTtcbiAgICAgIGRzdFsxOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxN10pO1xuICAgICAgZHN0WzIwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzI1XSk7XG4gICAgICBkc3RbMjFdID0gZGVjb2RlRmxvYXQxNihzcmNbMzBdKTtcbiAgICAgIGRzdFsyMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0MV0pO1xuICAgICAgZHN0WzIzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQzXSk7XG4gICAgICBkc3RbMjRdID0gZGVjb2RlRmxvYXQxNihzcmNbOV0pO1xuICAgICAgZHN0WzI1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzExXSk7XG4gICAgICBkc3RbMjZdID0gZGVjb2RlRmxvYXQxNihzcmNbMThdKTtcbiAgICAgIGRzdFsyN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syNF0pO1xuICAgICAgZHN0WzI4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzMxXSk7XG4gICAgICBkc3RbMjldID0gZGVjb2RlRmxvYXQxNihzcmNbNDBdKTtcbiAgICAgIGRzdFszMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0NF0pO1xuICAgICAgZHN0WzMxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzUzXSk7XG4gICAgICBkc3RbMzJdID0gZGVjb2RlRmxvYXQxNihzcmNbMTBdKTtcbiAgICAgIGRzdFszM10gPSBkZWNvZGVGbG9hdDE2KHNyY1sxOV0pO1xuICAgICAgZHN0WzM0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzIzXSk7XG4gICAgICBkc3RbMzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMzJdKTtcbiAgICAgIGRzdFszNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szOV0pO1xuICAgICAgZHN0WzM3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ1XSk7XG4gICAgICBkc3RbMzhdID0gZGVjb2RlRmxvYXQxNihzcmNbNTJdKTtcbiAgICAgIGRzdFszOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1NF0pO1xuICAgICAgZHN0WzQwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzIwXSk7XG4gICAgICBkc3RbNDFdID0gZGVjb2RlRmxvYXQxNihzcmNbMjJdKTtcbiAgICAgIGRzdFs0Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1szM10pO1xuICAgICAgZHN0WzQzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzM4XSk7XG4gICAgICBkc3RbNDRdID0gZGVjb2RlRmxvYXQxNihzcmNbNDZdKTtcbiAgICAgIGRzdFs0NV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1MV0pO1xuICAgICAgZHN0WzQ2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU1XSk7XG4gICAgICBkc3RbNDddID0gZGVjb2RlRmxvYXQxNihzcmNbNjBdKTtcbiAgICAgIGRzdFs0OF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMV0pO1xuICAgICAgZHN0WzQ5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM0XSk7XG4gICAgICBkc3RbNTBdID0gZGVjb2RlRmxvYXQxNihzcmNbMzddKTtcbiAgICAgIGRzdFs1MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0N10pO1xuICAgICAgZHN0WzUyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzUwXSk7XG4gICAgICBkc3RbNTNdID0gZGVjb2RlRmxvYXQxNihzcmNbNTZdKTtcbiAgICAgIGRzdFs1NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1OV0pO1xuICAgICAgZHN0WzU1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzYxXSk7XG4gICAgICBkc3RbNTZdID0gZGVjb2RlRmxvYXQxNihzcmNbMzVdKTtcbiAgICAgIGRzdFs1N10gPSBkZWNvZGVGbG9hdDE2KHNyY1szNl0pO1xuICAgICAgZHN0WzU4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ4XSk7XG4gICAgICBkc3RbNTldID0gZGVjb2RlRmxvYXQxNihzcmNbNDldKTtcbiAgICAgIGRzdFs2MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1N10pO1xuICAgICAgZHN0WzYxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU4XSk7XG4gICAgICBkc3RbNjJdID0gZGVjb2RlRmxvYXQxNihzcmNbNjJdKTtcbiAgICAgIGRzdFs2M10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2M10pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkY3RJbnZlcnNlKGRhdGEpIHtcbiAgICAgIGNvbnN0IGEgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gNCk7XG4gICAgICBjb25zdCBiID0gMC41ICogTWF0aC5jb3MoMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGMgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gOCk7XG4gICAgICBjb25zdCBkID0gMC41ICogTWF0aC5jb3MoMyAqIDMuMTQxNTkgLyAxNik7XG4gICAgICBjb25zdCBlID0gMC41ICogTWF0aC5jb3MoNSAqIDMuMTQxNTkgLyAxNik7XG4gICAgICBjb25zdCBmID0gMC41ICogTWF0aC5jb3MoMyAqIDMuMTQxNTkgLyA4KTtcbiAgICAgIGNvbnN0IGcgPSAwLjUgKiBNYXRoLmNvcyg3ICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIHZhciBhbHBoYSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciBiZXRhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIHRoZXRhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIGdhbW1hID0gbmV3IEFycmF5KDQpO1xuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgODsgKytyb3cpIHtcbiAgICAgICAgdmFyIHJvd1B0ciA9IHJvdyAqIDg7XG4gICAgICAgIGFscGhhWzBdID0gYyAqIGRhdGFbcm93UHRyICsgMl07XG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbcm93UHRyICsgMl07XG4gICAgICAgIGFscGhhWzJdID0gYyAqIGRhdGFbcm93UHRyICsgNl07XG4gICAgICAgIGFscGhhWzNdID0gZiAqIGRhdGFbcm93UHRyICsgNl07XG4gICAgICAgIGJldGFbMF0gPSBiICogZGF0YVtyb3dQdHIgKyAxXSArIGQgKiBkYXRhW3Jvd1B0ciArIDNdICsgZSAqIGRhdGFbcm93UHRyICsgNV0gKyBnICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZyAqIGRhdGFbcm93UHRyICsgM10gLSBiICogZGF0YVtyb3dQdHIgKyA1XSAtIGUgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbcm93UHRyICsgMV0gLSBiICogZGF0YVtyb3dQdHIgKyAzXSArIGcgKiBkYXRhW3Jvd1B0ciArIDVdICsgZCAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbM10gPSBnICogZGF0YVtyb3dQdHIgKyAxXSAtIGUgKiBkYXRhW3Jvd1B0ciArIDNdICsgZCAqIGRhdGFbcm93UHRyICsgNV0gLSBiICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbcm93UHRyICsgMF0gKyBkYXRhW3Jvd1B0ciArIDRdKTtcbiAgICAgICAgdGhldGFbM10gPSBhICogKGRhdGFbcm93UHRyICsgMF0gLSBkYXRhW3Jvd1B0ciArIDRdKTtcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdO1xuICAgICAgICB0aGV0YVsyXSA9IGFscGhhWzFdIC0gYWxwaGFbMl07XG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXTtcbiAgICAgICAgZ2FtbWFbMV0gPSB0aGV0YVszXSArIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVsyXSA9IHRoZXRhWzNdIC0gdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAwXSA9IGdhbW1hWzBdICsgYmV0YVswXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAxXSA9IGdhbW1hWzFdICsgYmV0YVsxXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAyXSA9IGdhbW1hWzJdICsgYmV0YVsyXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyAzXSA9IGdhbW1hWzNdICsgYmV0YVszXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA0XSA9IGdhbW1hWzNdIC0gYmV0YVszXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA1XSA9IGdhbW1hWzJdIC0gYmV0YVsyXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA2XSA9IGdhbW1hWzFdIC0gYmV0YVsxXTtcbiAgICAgICAgZGF0YVtyb3dQdHIgKyA3XSA9IGdhbW1hWzBdIC0gYmV0YVswXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGNvbHVtbiA9IDA7IGNvbHVtbiA8IDg7ICsrY29sdW1uKSB7XG4gICAgICAgIGFscGhhWzBdID0gYyAqIGRhdGFbMTYgKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVsxXSA9IGYgKiBkYXRhWzE2ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbMl0gPSBjICogZGF0YVs0OCArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzNdID0gZiAqIGRhdGFbNDggKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzBdID0gYiAqIGRhdGFbOCArIGNvbHVtbl0gKyBkICogZGF0YVsyNCArIGNvbHVtbl0gKyBlICogZGF0YVs0MCArIGNvbHVtbl0gKyBnICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMV0gPSBkICogZGF0YVs4ICsgY29sdW1uXSAtIGcgKiBkYXRhWzI0ICsgY29sdW1uXSAtIGIgKiBkYXRhWzQwICsgY29sdW1uXSAtIGUgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVsyXSA9IGUgKiBkYXRhWzggKyBjb2x1bW5dIC0gYiAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZyAqIGRhdGFbNDAgKyBjb2x1bW5dICsgZCAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzNdID0gZyAqIGRhdGFbOCArIGNvbHVtbl0gLSBlICogZGF0YVsyNCArIGNvbHVtbl0gKyBkICogZGF0YVs0MCArIGNvbHVtbl0gLSBiICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIHRoZXRhWzBdID0gYSAqIChkYXRhW2NvbHVtbl0gKyBkYXRhWzMyICsgY29sdW1uXSk7XG4gICAgICAgIHRoZXRhWzNdID0gYSAqIChkYXRhW2NvbHVtbl0gLSBkYXRhWzMyICsgY29sdW1uXSk7XG4gICAgICAgIHRoZXRhWzFdID0gYWxwaGFbMF0gKyBhbHBoYVszXTtcbiAgICAgICAgdGhldGFbMl0gPSBhbHBoYVsxXSAtIGFscGhhWzJdO1xuICAgICAgICBnYW1tYVswXSA9IHRoZXRhWzBdICsgdGhldGFbMV07XG4gICAgICAgIGdhbW1hWzFdID0gdGhldGFbM10gKyB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbMl0gPSB0aGV0YVszXSAtIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVszXSA9IHRoZXRhWzBdIC0gdGhldGFbMV07XG4gICAgICAgIGRhdGFbMCArIGNvbHVtbl0gPSBnYW1tYVswXSArIGJldGFbMF07XG4gICAgICAgIGRhdGFbOCArIGNvbHVtbl0gPSBnYW1tYVsxXSArIGJldGFbMV07XG4gICAgICAgIGRhdGFbMTYgKyBjb2x1bW5dID0gZ2FtbWFbMl0gKyBiZXRhWzJdO1xuICAgICAgICBkYXRhWzI0ICsgY29sdW1uXSA9IGdhbW1hWzNdICsgYmV0YVszXTtcbiAgICAgICAgZGF0YVszMiArIGNvbHVtbl0gPSBnYW1tYVszXSAtIGJldGFbM107XG4gICAgICAgIGRhdGFbNDAgKyBjb2x1bW5dID0gZ2FtbWFbMl0gLSBiZXRhWzJdO1xuICAgICAgICBkYXRhWzQ4ICsgY29sdW1uXSA9IGdhbW1hWzFdIC0gYmV0YVsxXTtcbiAgICAgICAgZGF0YVs1NiArIGNvbHVtbl0gPSBnYW1tYVswXSAtIGJldGFbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNzYzcwOUludmVyc2UoZGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIHZhciB5ID0gZGF0YVswXVtpXTtcbiAgICAgICAgdmFyIGNiID0gZGF0YVsxXVtpXTtcbiAgICAgICAgdmFyIGNyID0gZGF0YVsyXVtpXTtcbiAgICAgICAgZGF0YVswXVtpXSA9IHkgKyAxLjU3NDcgKiBjcjtcbiAgICAgICAgZGF0YVsxXVtpXSA9IHkgLSAwLjE4NzMgKiBjYiAtIDAuNDY4MiAqIGNyO1xuICAgICAgICBkYXRhWzJdW2ldID0geSArIDEuODU1NiAqIGNiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VG9IYWxmKHNyYywgZHN0LCBpZHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICBkc3RbaWR4ICsgaV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQodG9MaW5lYXIoc3JjW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvTGluZWFyKGZsb2F0KSB7XG4gICAgICBpZiAoZmxvYXQgPD0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zaWduKGZsb2F0KSAqIE1hdGgucG93KE1hdGguYWJzKGZsb2F0KSwgMi4yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3cobG9nQmFzZSwgTWF0aC5hYnMoZmxvYXQpIC0gMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NSQVcoaW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhpbmZvLmFycmF5LmJ1ZmZlciwgaW5mby5vZmZzZXQudmFsdWUsIGluZm8uc2l6ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NSTEUoaW5mbykge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLnZpZXdlci5idWZmZXIuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSBuZXcgVWludDhBcnJheShkZWNvZGVSdW5MZW5ndGgoY29tcHJlc3NlZCkpO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgICAgcHJlZGljdG9yKHJhd0J1ZmZlcik7XG4gICAgICBpbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NaSVAoaW5mbykge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSk7XG4gICAgICB2YXIgcmF3QnVmZmVyID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIubGVuZ3RoKTtcbiAgICAgIHByZWRpY3RvcihyYXdCdWZmZXIpO1xuICAgICAgaW50ZXJsZWF2ZVNjYWxhcihyYXdCdWZmZXIsIHRtcEJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUElaKGluZm8pIHtcbiAgICAgIHZhciBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG4gICAgICB2YXIgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShpbmZvLndpZHRoICogaW5mby5zY2FubGluZUJsb2NrU2l6ZSAqIChpbmZvLmNoYW5uZWxzICogaW5mby50eXBlKSk7XG4gICAgICB2YXIgYml0bWFwID0gbmV3IFVpbnQ4QXJyYXkoQklUTUFQX1NJWkUpO1xuICAgICAgdmFyIG91dEJ1ZmZlckVuZCA9IDA7XG4gICAgICB2YXIgcGl6Q2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoaW5mby5jaGFubmVscyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7IGkrKykge1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXSA9IHt9O1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcInN0YXJ0XCJdID0gb3V0QnVmZmVyRW5kO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcImVuZFwiXSA9IHBpekNoYW5uZWxEYXRhW2ldW1wic3RhcnRcIl07XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wibnhcIl0gPSBpbmZvLndpZHRoO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcIm55XCJdID0gaW5mby5saW5lcztcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJzaXplXCJdID0gaW5mby50eXBlO1xuICAgICAgICBvdXRCdWZmZXJFbmQgKz0gcGl6Q2hhbm5lbERhdGFbaV0ubnggKiBwaXpDaGFubmVsRGF0YVtpXS5ueSAqIHBpekNoYW5uZWxEYXRhW2ldLnNpemU7XG4gICAgICB9XG4gICAgICB2YXIgbWluTm9uWmVybyA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIHZhciBtYXhOb25aZXJvID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaWYgKG1heE5vblplcm8gPj0gQklUTUFQX1NJWkUpIHtcbiAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCBQSVpfQ09NUFJFU1NJT04gQklUTUFQX1NJWkVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5Ob25aZXJvIDw9IG1heE5vblplcm8pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhOb25aZXJvIC0gbWluTm9uWmVybyArIDE7IGkrKykge1xuICAgICAgICAgIGJpdG1hcFtpICsgbWluTm9uWmVyb10gPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGx1dCA9IG5ldyBVaW50MTZBcnJheShVU0hPUlRfUkFOR0UpO1xuICAgICAgdmFyIG1heFZhbHVlID0gcmV2ZXJzZUx1dEZyb21CaXRtYXAoYml0bWFwLCBsdXQpO1xuICAgICAgdmFyIGxlbmd0aCA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGh1ZlVuY29tcHJlc3MoaW5mby5hcnJheSwgaW5EYXRhVmlldywgaW5PZmZzZXQsIGxlbmd0aCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJFbmQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gcGl6Q2hhbm5lbERhdGFbaV07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTsgKytqKSB7XG4gICAgICAgICAgd2F2MkRlY29kZShvdXRCdWZmZXIsIGNkLnN0YXJ0ICsgaiwgY2QubngsIGNkLnNpemUsIGNkLm55LCBjZC5ueCAqIGNkLnNpemUsIG1heFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXBwbHlMdXQobHV0LCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgICB2YXIgdG1wT2Zmc2V0MiA9IDA7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkob3V0QnVmZmVyLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgaW5mby5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgdmFyIGNkID0gcGl6Q2hhbm5lbERhdGFbY107XG4gICAgICAgICAgdmFyIG4gPSBjZC5ueCAqIGNkLnNpemU7XG4gICAgICAgICAgdmFyIGNwID0gbmV3IFVpbnQ4QXJyYXkob3V0QnVmZmVyLmJ1ZmZlciwgY2QuZW5kICogSU5UMTZfU0laRSwgbiAqIElOVDE2X1NJWkUpO1xuICAgICAgICAgIHRtcEJ1ZmZlci5zZXQoY3AsIHRtcE9mZnNldDIpO1xuICAgICAgICAgIHRtcE9mZnNldDIgKz0gbiAqIElOVDE2X1NJWkU7XG4gICAgICAgICAgY2QuZW5kICs9IG47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQWFIoaW5mbykge1xuICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSk7XG4gICAgICB2YXIgcmF3QnVmZmVyID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgIGNvbnN0IHN6ID0gaW5mby5saW5lcyAqIGluZm8uY2hhbm5lbHMgKiBpbmZvLndpZHRoO1xuICAgICAgY29uc3QgdG1wQnVmZmVyID0gaW5mby50eXBlID09IDEgPyBuZXcgVWludDE2QXJyYXkoc3opIDogbmV3IFVpbnQzMkFycmF5KHN6KTtcbiAgICAgIGxldCB0bXBCdWZmZXJFbmQgPSAwO1xuICAgICAgbGV0IHdyaXRlUHRyID0gMDtcbiAgICAgIGNvbnN0IHB0ciA9IG5ldyBBcnJheSg0KTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaW5mby5saW5lczsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgaW5mby5jaGFubmVsczsgYysrKSB7XG4gICAgICAgICAgbGV0IHBpeGVsID0gMDtcbiAgICAgICAgICBzd2l0Y2ggKGluZm8udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsxXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgOCB8IHJhd0J1ZmZlcltwdHJbMV0rK107XG4gICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZjtcbiAgICAgICAgICAgICAgICB0bXBCdWZmZXJbd3JpdGVQdHJdID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgd3JpdGVQdHIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcHRyWzBdID0gdG1wQnVmZmVyRW5kO1xuICAgICAgICAgICAgICBwdHJbMV0gPSBwdHJbMF0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICBwdHJbMl0gPSBwdHJbMV0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICB0bXBCdWZmZXJFbmQgPSBwdHJbMl0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZm8ud2lkdGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSByYXdCdWZmZXJbcHRyWzBdKytdIDw8IDI0IHwgcmF3QnVmZmVyW3B0clsxXSsrXSA8PCAxNiB8IHJhd0J1ZmZlcltwdHJbMl0rK10gPDwgODtcbiAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICB3cml0ZVB0cisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc0RXQShpbmZvKSB7XG4gICAgICB2YXIgaW5EYXRhVmlldyA9IGluZm8udmlld2VyO1xuICAgICAgdmFyIGluT2Zmc2V0ID0geyB2YWx1ZTogaW5mby5vZmZzZXQudmFsdWUgfTtcbiAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheShpbmZvLndpZHRoICogaW5mby5saW5lcyAqIChpbmZvLmNoYW5uZWxzICogaW5mby50eXBlICogSU5UMTZfU0laRSkpO1xuICAgICAgdmFyIGR3YUhlYWRlciA9IHtcbiAgICAgICAgdmVyc2lvbjogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHVua25vd25VbmNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdW5rbm93bkNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgYWNDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGRjQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZVVuY29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVSYXdTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdG90YWxBY1VuY29tcHJlc3NlZENvdW50OiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdG90YWxEY1VuY29tcHJlc3NlZENvdW50OiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgYWNDb21wcmVzc2lvbjogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldClcbiAgICAgIH07XG4gICAgICBpZiAoZHdhSGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiBcIiArIEVYUkhlYWRlci5jb21wcmVzc2lvbiArIFwiIHZlcnNpb24gXCIgKyBkd2FIZWFkZXIudmVyc2lvbiArIFwiIGlzIHVuc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbFJ1bGVzID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgcnVsZVNpemUgPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCkgLSBJTlQxNl9TSVpFO1xuICAgICAgd2hpbGUgKHJ1bGVTaXplID4gMCkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoaW5EYXRhVmlldy5idWZmZXIsIGluT2Zmc2V0KTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VVaW50OChpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9IHZhbHVlID4+IDIgJiAzO1xuICAgICAgICB2YXIgY3NjID0gKHZhbHVlID4+IDQpIC0gMTtcbiAgICAgICAgdmFyIGluZGV4ID0gbmV3IEludDhBcnJheShbY3NjXSlbMF07XG4gICAgICAgIHZhciB0eXBlID0gcGFyc2VVaW50OChpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICAgIGNoYW5uZWxSdWxlcy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY29tcHJlc3Npb25cbiAgICAgICAgfSk7XG4gICAgICAgIHJ1bGVTaXplIC09IG5hbWUubGVuZ3RoICsgMztcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVscyA9IEVYUkhlYWRlci5jaGFubmVscztcbiAgICAgIHZhciBjaGFubmVsRGF0YSA9IG5ldyBBcnJheShpbmZvLmNoYW5uZWxzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW2ldID0ge307XG4gICAgICAgIHZhciBjaGFubmVsID0gY2hhbm5lbHNbaV07XG4gICAgICAgIGNkLm5hbWUgPSBjaGFubmVsLm5hbWU7XG4gICAgICAgIGNkLmNvbXByZXNzaW9uID0gVU5LTk9XTjtcbiAgICAgICAgY2QuZGVjb2RlZCA9IGZhbHNlO1xuICAgICAgICBjZC50eXBlID0gY2hhbm5lbC5waXhlbFR5cGU7XG4gICAgICAgIGNkLnBMaW5lYXIgPSBjaGFubmVsLnBMaW5lYXI7XG4gICAgICAgIGNkLndpZHRoID0gaW5mby53aWR0aDtcbiAgICAgICAgY2QuaGVpZ2h0ID0gaW5mby5saW5lcztcbiAgICAgIH1cbiAgICAgIHZhciBjc2NTZXQgPSB7XG4gICAgICAgIGlkeDogbmV3IEFycmF5KDMpXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgb2Zmc2V0MiA9IDA7IG9mZnNldDIgPCBpbmZvLmNoYW5uZWxzOyArK29mZnNldDIpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbb2Zmc2V0Ml07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbFJ1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSBjaGFubmVsUnVsZXNbaV07XG4gICAgICAgICAgaWYgKGNkLm5hbWUgPT0gcnVsZS5uYW1lKSB7XG4gICAgICAgICAgICBjZC5jb21wcmVzc2lvbiA9IHJ1bGUuY29tcHJlc3Npb247XG4gICAgICAgICAgICBpZiAocnVsZS5pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgIGNzY1NldC5pZHhbcnVsZS5pbmRleF0gPSBvZmZzZXQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2Qub2Zmc2V0ID0gb2Zmc2V0MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSA+IDApIHtcbiAgICAgICAgc3dpdGNoIChkd2FIZWFkZXIuYWNDb21wcmVzc2lvbikge1xuICAgICAgICAgIGNhc2UgU1RBVElDX0hVRkZNQU46XG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCk7XG4gICAgICAgICAgICBodWZVbmNvbXByZXNzKFxuICAgICAgICAgICAgICBpbmZvLmFycmF5LFxuICAgICAgICAgICAgICBpbkRhdGFWaWV3LFxuICAgICAgICAgICAgICBpbk9mZnNldCxcbiAgICAgICAgICAgICAgZHdhSGVhZGVyLmFjQ29tcHJlc3NlZFNpemUsXG4gICAgICAgICAgICAgIGFjQnVmZmVyLFxuICAgICAgICAgICAgICBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBERUZMQVRFOlxuICAgICAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgICAgICAgdmFyIGFjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplID4gMCkge1xuICAgICAgICB2YXIgemxpYkluZm8gPSB7XG4gICAgICAgICAgYXJyYXk6IGluZm8uYXJyYXksXG4gICAgICAgICAgb2Zmc2V0OiBpbk9mZnNldCxcbiAgICAgICAgICBzaXplOiBkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkodW5jb21wcmVzc1pJUCh6bGliSW5mbykuYnVmZmVyKTtcbiAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemU7XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLnJsZVJhd1NpemUgPiAwKSB7XG4gICAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIucmxlQ29tcHJlc3NlZFNpemUpO1xuICAgICAgICB2YXIgZGF0YSA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICAgIHZhciBybGVCdWZmZXIgPSBkZWNvZGVSdW5MZW5ndGgoZGF0YS5idWZmZXIpO1xuICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIucmxlQ29tcHJlc3NlZFNpemU7XG4gICAgICB9XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kID0gMDtcbiAgICAgIHZhciByb3dPZmZzZXRzID0gbmV3IEFycmF5KGNoYW5uZWxEYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd09mZnNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcm93T2Zmc2V0c1tpXSA9IG5ldyBBcnJheSgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyArK3kpIHtcbiAgICAgICAgZm9yICh2YXIgY2hhbiA9IDA7IGNoYW4gPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsrY2hhbikge1xuICAgICAgICAgIHJvd09mZnNldHNbY2hhbl0ucHVzaChvdXRCdWZmZXJFbmQpO1xuICAgICAgICAgIG91dEJ1ZmZlckVuZCArPSBjaGFubmVsRGF0YVtjaGFuXS53aWR0aCAqIGluZm8udHlwZSAqIElOVDE2X1NJWkU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvc3N5RGN0RGVjb2RlKGNzY1NldCwgcm93T2Zmc2V0cywgY2hhbm5lbERhdGEsIGFjQnVmZmVyLCBkY0J1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbERhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbaV07XG4gICAgICAgIGlmIChjZC5kZWNvZGVkKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzd2l0Y2ggKGNkLmNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgY2FzZSBSTEU6XG4gICAgICAgICAgICB2YXIgcm93ID0gMDtcbiAgICAgICAgICAgIHZhciBybGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyArK3kpIHtcbiAgICAgICAgICAgICAgdmFyIHJvd09mZnNldEJ5dGVzID0gcm93T2Zmc2V0c1tpXVtyb3ddO1xuICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNkLndpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBieXRlID0gMDsgYnl0ZSA8IElOVDE2X1NJWkUgKiBjZC50eXBlOyArK2J5dGUpIHtcbiAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlcltyb3dPZmZzZXRCeXRlcysrXSA9IHJsZUJ1ZmZlcltybGVPZmZzZXQgKyBieXRlICogY2Qud2lkdGggKiBjZC5oZWlnaHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBybGVPZmZzZXQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb3crKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgTE9TU1lfRENUOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgY2hhbm5lbCBjb21wcmVzc2lvblwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KG91dEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpIHtcbiAgICAgIHZhciB1aW50QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMik7XG4gICAgICB2YXIgZW5kT2Zmc2V0ID0gMDtcbiAgICAgIHdoaWxlICh1aW50QnVmZmVyW29mZnNldDIudmFsdWUgKyBlbmRPZmZzZXRdICE9IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ICs9IDE7XG4gICAgICB9XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludEJ1ZmZlci5zbGljZShvZmZzZXQyLnZhbHVlLCBvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0KSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldCArIDE7XG4gICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSkge1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpLnNsaWNlKG9mZnNldDIudmFsdWUsIG9mZnNldDIudmFsdWUgKyBzaXplKSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIHNpemU7XG4gICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlUmF0aW9uYWwoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZWNvZGUoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgSW50MzIgPSBkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UMzJfU0laRTtcbiAgICAgIHJldHVybiBJbnQzMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50MzIgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDMyX1NJWkU7XG4gICAgICByZXR1cm4gVWludDMyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheTIsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50OCA9IHVJbnQ4QXJyYXkyW29mZnNldDIudmFsdWVdO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQ4X1NJWkU7XG4gICAgICByZXR1cm4gVWludDg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50OCA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldDIudmFsdWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQ4X1NJWkU7XG4gICAgICByZXR1cm4gVWludDg7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlSW50NjQgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgbGV0IGludDtcbiAgICAgIGlmIChcImdldEJpZ0ludDY0XCIgaW4gRGF0YVZpZXcucHJvdG90eXBlKSB7XG4gICAgICAgIGludCA9IE51bWJlcihkYXRhVmlldy5nZXRCaWdJbnQ2NChvZmZzZXQyLnZhbHVlLCB0cnVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnQgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0Mi52YWx1ZSArIDQsIHRydWUpICsgTnVtYmVyKGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKSA8PCAzMik7XG4gICAgICB9XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IFVMT05HX1NJWkU7XG4gICAgICByZXR1cm4gaW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgZmxvYXQgPSBkYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBGTE9BVDMyX1NJWkU7XG4gICAgICByZXR1cm4gZmxvYXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHJldHVybiBEYXRhVXRpbHMudG9IYWxmRmxvYXQocGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZUZsb2F0MTYoYmluYXJ5KSB7XG4gICAgICB2YXIgZXhwb25lbnQgPSAoYmluYXJ5ICYgMzE3NDQpID4+IDEwLCBmcmFjdGlvbiA9IGJpbmFyeSAmIDEwMjM7XG4gICAgICByZXR1cm4gKGJpbmFyeSA+PiAxNSA/IC0xIDogMSkgKiAoZXhwb25lbnQgPyBleHBvbmVudCA9PT0gMzEgPyBmcmFjdGlvbiA/IE5hTiA6IEluZmluaXR5IDogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNSkgKiAoMSArIGZyYWN0aW9uIC8gMTAyNCkgOiA2MTAzNTE1NjI1ZS0xNCAqIChmcmFjdGlvbiAvIDEwMjQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50MTYoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBVaW50MTYgPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IElOVDE2X1NJWkU7XG4gICAgICByZXR1cm4gVWludDE2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZsb2F0MTYoYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgcmV0dXJuIGRlY29kZUZsb2F0MTYocGFyc2VVaW50MTYoYnVmZmVyMiwgb2Zmc2V0MikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNobGlzdChkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSkge1xuICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gb2Zmc2V0Mi52YWx1ZTtcbiAgICAgIHZhciBjaGFubmVscyA9IFtdO1xuICAgICAgd2hpbGUgKG9mZnNldDIudmFsdWUgPCBzdGFydE9mZnNldCArIHNpemUgLSAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKTtcbiAgICAgICAgdmFyIHBpeGVsVHlwZSA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICB2YXIgcExpbmVhciA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IDM7XG4gICAgICAgIHZhciB4U2FtcGxpbmcgPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgdmFyIHlTYW1wbGluZyA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICBjaGFubmVscy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBpeGVsVHlwZSxcbiAgICAgICAgICBwTGluZWFyLFxuICAgICAgICAgIHhTYW1wbGluZyxcbiAgICAgICAgICB5U2FtcGxpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IDE7XG4gICAgICByZXR1cm4gY2hhbm5lbHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hyb21hdGljaXRpZXMoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciByZWRYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciByZWRZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBncmVlblggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGdyZWVuWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgYmx1ZVggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGJsdWVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB3aGl0ZVggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHdoaXRlWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWRYLFxuICAgICAgICByZWRZLFxuICAgICAgICBncmVlblgsXG4gICAgICAgIGdyZWVuWSxcbiAgICAgICAgYmx1ZVgsXG4gICAgICAgIGJsdWVZLFxuICAgICAgICB3aGl0ZVgsXG4gICAgICAgIHdoaXRlWVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDb21wcmVzc2lvbihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGNvbXByZXNzaW9uQ29kZXMgPSBbXG4gICAgICAgIFwiTk9fQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJSTEVfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJaSVBTX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiWklQX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiUElaX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiUFhSMjRfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJCNDRfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJCNDRBX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiRFdBQV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkRXQUJfQ09NUFJFU1NJT05cIlxuICAgICAgXTtcbiAgICAgIHZhciBjb21wcmVzc2lvbiA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIGNvbXByZXNzaW9uQ29kZXNbY29tcHJlc3Npb25dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeE1pbiA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5TWluID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHhNYXggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeU1heCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiB7IHhNaW4sIHlNaW4sIHhNYXgsIHlNYXggfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VMaW5lT3JkZXIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBsaW5lT3JkZXJzID0gW1wiSU5DUkVBU0lOR19ZXCJdO1xuICAgICAgdmFyIGxpbmVPcmRlciA9IHBhcnNlVWludDgoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIGxpbmVPcmRlcnNbbGluZU9yZGVyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWMmYoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVjNmKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeiA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVZhbHVlKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCB0eXBlLCBzaXplKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcInN0cmluZ3ZlY3RvclwiIHx8IHR5cGUgPT09IFwiaWNjUHJvZmlsZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZpeGVkTGVuZ3RoU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNobGlzdFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNobGlzdChkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2hyb21hdGljaXRpZXNcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY29tcHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gcGFyc2VDb21wcmVzc2lvbihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYm94MmlcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VCb3gyaShkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZU9yZGVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTGluZU9yZGVyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInYyZlwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidjNmXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjNmKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbnRcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicmF0aW9uYWxcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidGltZWNvZGVcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicHJldmlld1wiKSB7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIFwic2tpcHBlZFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBzaXplO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUhlYWRlcihkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgY29uc3QgRVhSSGVhZGVyMiA9IHt9O1xuICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMigwLCB0cnVlKSAhPSAyMDAwMDYzMCkge1xuICAgICAgICB0aHJvdyBcIlRIUkVFLkVYUkxvYWRlcjogcHJvdmlkZWQgZmlsZSBkb2Vzbid0IGFwcGVhciB0byBiZSBpbiBPcGVuRVhSIGZvcm1hdC5cIjtcbiAgICAgIH1cbiAgICAgIEVYUkhlYWRlcjIudmVyc2lvbiA9IGRhdGFWaWV3LmdldFVpbnQ4KDQpO1xuICAgICAgY29uc3Qgc3BlYyA9IGRhdGFWaWV3LmdldFVpbnQ4KDUpO1xuICAgICAgRVhSSGVhZGVyMi5zcGVjID0ge1xuICAgICAgICBzaW5nbGVUaWxlOiAhIShzcGVjICYgMiksXG4gICAgICAgIGxvbmdOYW1lOiAhIShzcGVjICYgNCksXG4gICAgICAgIGRlZXBGb3JtYXQ6ICEhKHNwZWMgJiA4KSxcbiAgICAgICAgbXVsdGlQYXJ0OiAhIShzcGVjICYgMTYpXG4gICAgICB9O1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IDg7XG4gICAgICB2YXIga2VlcFJlYWRpbmcgPSB0cnVlO1xuICAgICAgd2hpbGUgKGtlZXBSZWFkaW5nKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT0gMCkge1xuICAgICAgICAgIGtlZXBSZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVR5cGUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVTaXplID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVWYWx1ZSA9IHBhcnNlVmFsdWUoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIGF0dHJpYnV0ZVR5cGUsIGF0dHJpYnV0ZVNpemUpO1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVYUkxvYWRlci5wYXJzZTogc2tpcHBlZCB1bmtub3duIGhlYWRlciBhdHRyaWJ1dGUgdHlwZSAnJHthdHRyaWJ1dGVUeXBlfScuYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEVYUkhlYWRlcjJbYXR0cmlidXRlTmFtZV0gPSBhdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoc3BlYyAmIH40KSAhPSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFWFJIZWFkZXI6XCIsIEVYUkhlYWRlcjIpO1xuICAgICAgICB0aHJvdyBcIlRIUkVFLkVYUkxvYWRlcjogcHJvdmlkZWQgZmlsZSBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gRVhSSGVhZGVyMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dXBEZWNvZGVyKEVYUkhlYWRlcjIsIGRhdGFWaWV3LCB1SW50OEFycmF5Miwgb2Zmc2V0Miwgb3V0cHV0VHlwZSkge1xuICAgICAgY29uc3QgRVhSRGVjb2RlcjIgPSB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIHZpZXdlcjogZGF0YVZpZXcsXG4gICAgICAgIGFycmF5OiB1SW50OEFycmF5MixcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQyLFxuICAgICAgICB3aWR0aDogRVhSSGVhZGVyMi5kYXRhV2luZG93LnhNYXggLSBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueE1pbiArIDEsXG4gICAgICAgIGhlaWdodDogRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNYXggLSBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1pbiArIDEsXG4gICAgICAgIGNoYW5uZWxzOiBFWFJIZWFkZXIyLmNoYW5uZWxzLmxlbmd0aCxcbiAgICAgICAgYnl0ZXNQZXJMaW5lOiBudWxsLFxuICAgICAgICBsaW5lczogbnVsbCxcbiAgICAgICAgaW5wdXRTaXplOiBudWxsLFxuICAgICAgICB0eXBlOiBFWFJIZWFkZXIyLmNoYW5uZWxzWzBdLnBpeGVsVHlwZSxcbiAgICAgICAgdW5jb21wcmVzczogbnVsbCxcbiAgICAgICAgZ2V0dGVyOiBudWxsLFxuICAgICAgICBmb3JtYXQ6IG51bGwsXG4gICAgICAgIFtoYXNDb2xvclNwYWNlID8gXCJjb2xvclNwYWNlXCIgOiBcImVuY29kaW5nXCJdOiBudWxsXG4gICAgICB9O1xuICAgICAgc3dpdGNoIChFWFJIZWFkZXIyLmNvbXByZXNzaW9uKSB7XG4gICAgICAgIGNhc2UgXCJOT19DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1JBVztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJMRV9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1JMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpJUFNfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJaSVBfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzWklQO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUElaX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAzMjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1BJWjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBYUjI0X0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxNjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1BYUjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRXQUFfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDMyO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzRFdBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFdBQl9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMjU2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzRFdBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiBcIiArIEVYUkhlYWRlcjIuY29tcHJlc3Npb24gKyBcIiBpcyB1bnN1cHBvcnRlZFwiO1xuICAgICAgfVxuICAgICAgRVhSRGVjb2RlcjIuc2NhbmxpbmVCbG9ja1NpemUgPSBFWFJEZWNvZGVyMi5saW5lcztcbiAgICAgIGlmIChFWFJEZWNvZGVyMi50eXBlID09IDEpIHtcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZUZsb2F0MTY7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBJTlQxNl9TSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gcGFyc2VVaW50MTY7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBJTlQxNl9TSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRVhSRGVjb2RlcjIudHlwZSA9PSAyKSB7XG4gICAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gcGFyc2VGbG9hdDMyO1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gZGVjb2RlRmxvYXQzMjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IEZMT0FUMzJfU0laRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IHVuc3VwcG9ydGVkIHBpeGVsVHlwZSBcIiArIEVYUkRlY29kZXIyLnR5cGUgKyBcIiBmb3IgXCIgKyBFWFJIZWFkZXIyLmNvbXByZXNzaW9uICsgXCIuXCI7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5ibG9ja0NvdW50ID0gKEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWF4ICsgMSkgLyBFWFJEZWNvZGVyMi5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRVhSRGVjb2RlcjIuYmxvY2tDb3VudDsgaSsrKVxuICAgICAgICBwYXJzZUludDY0KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzID0gRVhSRGVjb2RlcjIuY2hhbm5lbHMgPT0gMyA/IDQgOiBFWFJEZWNvZGVyMi5jaGFubmVscztcbiAgICAgIGNvbnN0IHNpemUgPSBFWFJEZWNvZGVyMi53aWR0aCAqIEVYUkRlY29kZXIyLmhlaWdodCAqIEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzO1xuICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgICAgaWYgKEVYUkRlY29kZXIyLmNoYW5uZWxzIDwgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMpXG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkuZmlsbCgxLCAwLCBzaXplKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheSA9IG5ldyBVaW50MTZBcnJheShzaXplKTtcbiAgICAgICAgICBpZiAoRVhSRGVjb2RlcjIuY2hhbm5lbHMgPCBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheS5maWxsKDE1MzYwLCAwLCBzaXplKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuRVhSTG9hZGVyOiB1bnN1cHBvcnRlZCB0eXBlOiBcIiwgb3V0cHV0VHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5ieXRlc1BlckxpbmUgPSBFWFJEZWNvZGVyMi53aWR0aCAqIEVYUkRlY29kZXIyLmlucHV0U2l6ZSAqIEVYUkRlY29kZXIyLmNoYW5uZWxzO1xuICAgICAgaWYgKEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzID09IDQpXG4gICAgICAgIEVYUkRlY29kZXIyLmZvcm1hdCA9IFJHQkFGb3JtYXQ7XG4gICAgICBlbHNlXG4gICAgICAgIEVYUkRlY29kZXIyLmZvcm1hdCA9IFJlZEZvcm1hdDtcbiAgICAgIGlmIChoYXNDb2xvclNwYWNlKVxuICAgICAgICBFWFJEZWNvZGVyMi5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgZWxzZVxuICAgICAgICBFWFJEZWNvZGVyMi5lbmNvZGluZyA9IDNlMztcbiAgICAgIHJldHVybiBFWFJEZWNvZGVyMjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyRGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBjb25zdCB1SW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBvZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgY29uc3QgRVhSSGVhZGVyID0gcGFyc2VIZWFkZXIoYnVmZmVyRGF0YVZpZXcsIGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBjb25zdCBFWFJEZWNvZGVyID0gc2V0dXBEZWNvZGVyKEVYUkhlYWRlciwgYnVmZmVyRGF0YVZpZXcsIHVJbnQ4QXJyYXksIG9mZnNldCwgdGhpcy50eXBlKTtcbiAgICBjb25zdCB0bXBPZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgY29uc3QgY2hhbm5lbE9mZnNldHMgPSB7IFI6IDAsIEc6IDEsIEI6IDIsIEE6IDMsIFk6IDAgfTtcbiAgICBmb3IgKGxldCBzY2FubGluZUJsb2NrSWR4ID0gMDsgc2NhbmxpbmVCbG9ja0lkeCA8IEVYUkRlY29kZXIuaGVpZ2h0IC8gRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTsgc2NhbmxpbmVCbG9ja0lkeCsrKSB7XG4gICAgICBjb25zdCBsaW5lID0gcGFyc2VVaW50MzIoYnVmZmVyRGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICBFWFJEZWNvZGVyLnNpemUgPSBwYXJzZVVpbnQzMihidWZmZXJEYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgIEVYUkRlY29kZXIubGluZXMgPSBsaW5lICsgRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZSA+IEVYUkRlY29kZXIuaGVpZ2h0ID8gRVhSRGVjb2Rlci5oZWlnaHQgLSBsaW5lIDogRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IEVYUkRlY29kZXIuc2l6ZSA8IEVYUkRlY29kZXIubGluZXMgKiBFWFJEZWNvZGVyLmJ5dGVzUGVyTGluZTtcbiAgICAgIGNvbnN0IHZpZXdlciA9IGlzQ29tcHJlc3NlZCA/IEVYUkRlY29kZXIudW5jb21wcmVzcyhFWFJEZWNvZGVyKSA6IHVuY29tcHJlc3NSQVcoRVhSRGVjb2Rlcik7XG4gICAgICBvZmZzZXQudmFsdWUgKz0gRVhSRGVjb2Rlci5zaXplO1xuICAgICAgZm9yIChsZXQgbGluZV95ID0gMDsgbGluZV95IDwgRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTsgbGluZV95KyspIHtcbiAgICAgICAgY29uc3QgdHJ1ZV95ID0gbGluZV95ICsgc2NhbmxpbmVCbG9ja0lkeCAqIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgICAgIGlmICh0cnVlX3kgPj0gRVhSRGVjb2Rlci5oZWlnaHQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZvciAobGV0IGNoYW5uZWxJRCA9IDA7IGNoYW5uZWxJRCA8IEVYUkRlY29kZXIuY2hhbm5lbHM7IGNoYW5uZWxJRCsrKSB7XG4gICAgICAgICAgY29uc3QgY09mZiA9IGNoYW5uZWxPZmZzZXRzW0VYUkhlYWRlci5jaGFubmVsc1tjaGFubmVsSURdLm5hbWVdO1xuICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgRVhSRGVjb2Rlci53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICB0bXBPZmZzZXQudmFsdWUgPSAobGluZV95ICogKEVYUkRlY29kZXIuY2hhbm5lbHMgKiBFWFJEZWNvZGVyLndpZHRoKSArIGNoYW5uZWxJRCAqIEVYUkRlY29kZXIud2lkdGggKyB4KSAqIEVYUkRlY29kZXIuaW5wdXRTaXplO1xuICAgICAgICAgICAgY29uc3Qgb3V0SW5kZXggPSAoRVhSRGVjb2Rlci5oZWlnaHQgLSAxIC0gdHJ1ZV95KSAqIChFWFJEZWNvZGVyLndpZHRoICogRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscykgKyB4ICogRVhSRGVjb2Rlci5vdXRwdXRDaGFubmVscyArIGNPZmY7XG4gICAgICAgICAgICBFWFJEZWNvZGVyLmJ5dGVBcnJheVtvdXRJbmRleF0gPSBFWFJEZWNvZGVyLmdldHRlcih2aWV3ZXIsIHRtcE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBoZWFkZXI6IEVYUkhlYWRlcixcbiAgICAgIHdpZHRoOiBFWFJEZWNvZGVyLndpZHRoLFxuICAgICAgaGVpZ2h0OiBFWFJEZWNvZGVyLmhlaWdodCxcbiAgICAgIGRhdGE6IEVYUkRlY29kZXIuYnl0ZUFycmF5LFxuICAgICAgZm9ybWF0OiBFWFJEZWNvZGVyLmZvcm1hdCxcbiAgICAgIFtoYXNDb2xvclNwYWNlID8gXCJjb2xvclNwYWNlXCIgOiBcImVuY29kaW5nXCJdOiBFWFJEZWNvZGVyW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl0sXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9O1xuICB9XG4gIHNldERhdGFUeXBlKHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHRleHR1cmUsIHRleERhdGEpIHtcbiAgICAgIGlmIChoYXNDb2xvclNwYWNlKVxuICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSB0ZXhEYXRhLmNvbG9yU3BhY2U7XG4gICAgICBlbHNlXG4gICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSB0ZXhEYXRhLmVuY29kaW5nO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICB0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XG4gICAgICBpZiAob25Mb2FkKVxuICAgICAgICBvbkxvYWQodGV4dHVyZSwgdGV4RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5sb2FkKHVybCwgb25Mb2FkQ2FsbGJhY2ssIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICB9XG59XG5leHBvcnQge1xuICBFWFJMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FWFJMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiVGV4dHVyZSIsIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIlJHQkFGb3JtYXQiLCJSZWRGb3JtYXQiLCJMaW5lYXJGaWx0ZXIiLCJEYXRhVXRpbHMiLCJ1bnpsaWJTeW5jIiwiaGFzQ29sb3JTcGFjZSIsIkVYUkxvYWRlciIsInBhcnNlIiwiYnVmZmVyIiwiVVNIT1JUX1JBTkdFIiwiQklUTUFQX1NJWkUiLCJIVUZfRU5DQklUUyIsIkhVRl9ERUNCSVRTIiwiSFVGX0VOQ1NJWkUiLCJIVUZfREVDU0laRSIsIkhVRl9ERUNNQVNLIiwiTkJJVFMiLCJBX09GRlNFVCIsIk1PRF9NQVNLIiwiU0hPUlRfWkVST0NPREVfUlVOIiwiTE9OR19aRVJPQ09ERV9SVU4iLCJTSE9SVEVTVF9MT05HX1JVTiIsIlVMT05HX1NJWkUiLCJGTE9BVDMyX1NJWkUiLCJJTlQzMl9TSVpFIiwiSU5UMTZfU0laRSIsIklOVDhfU0laRSIsIlNUQVRJQ19IVUZGTUFOIiwiREVGTEFURSIsIlVOS05PV04iLCJMT1NTWV9EQ1QiLCJSTEUiLCJsb2dCYXNlIiwiTWF0aCIsInBvdyIsInJldmVyc2VMdXRGcm9tQml0bWFwIiwiYml0bWFwIiwibHV0IiwiayIsImkiLCJuIiwiaHVmQ2xlYXJEZWNUYWJsZSIsImhkZWMiLCJsZW4iLCJsaXQiLCJwIiwiZ2V0Qml0c1JldHVybiIsImwiLCJjIiwibGMiLCJnZXRCaXRzIiwibkJpdHMiLCJ1SW50OEFycmF5MiIsImluT2Zmc2V0IiwicGFyc2VVaW50OEFycmF5IiwiaHVmVGFibGVCdWZmZXIiLCJBcnJheSIsImh1ZkNhbm9uaWNhbENvZGVUYWJsZSIsImhjb2RlIiwibmMiLCJodWZVbnBhY2tFbmNUYWJsZSIsImluRGF0YVZpZXciLCJuaSIsImltIiwiaU0iLCJ2YWx1ZSIsInplcnVuIiwiaHVmTGVuZ3RoIiwiY29kZSIsImh1ZkNvZGUiLCJodWZCdWlsZERlY1RhYmxlIiwiaGRlY29kIiwicGwiLCJwbE9mZnNldCIsImdldENoYXJSZXR1cm4iLCJnZXRDaGFyIiwiZ2V0Q29kZVJldHVybiIsImdldENvZGUiLCJwbyIsInJsYyIsIm91dEJ1ZmZlciIsIm91dEJ1ZmZlck9mZnNldCIsIm91dEJ1ZmZlckVuZE9mZnNldCIsImNzIiwiVWludDhBcnJheSIsInMiLCJVSW50MTYiLCJJbnQxNiIsInJlZiIsIndkZWMxNFJldHVybiIsImEiLCJiIiwid2RlYzE0IiwiaCIsImxzIiwiaHMiLCJoaSIsImFpIiwiYXMiLCJicyIsIndkZWMxNiIsIm0iLCJkIiwiYmIiLCJhYSIsIndhdjJEZWNvZGUiLCJidWZmZXIyIiwiaiIsIm54Iiwib3giLCJueSIsIm95IiwibXgiLCJ3MTQiLCJwMiIsInB5IiwiZXkiLCJveTEiLCJveTIiLCJveDEiLCJveDIiLCJpMDAiLCJpMDEiLCJpMTAiLCJpMTEiLCJweCIsImV4IiwicDAxIiwicDEwIiwicDExIiwiaHVmRGVjb2RlIiwiZW5jb2RpbmdUYWJsZSIsImRlY29kaW5nVGFibGUiLCJubyIsIm91dE9mZnNldCIsImluT2Zmc2V0RW5kIiwidHJ1bmMiLCJpbmRleCIsImh1ZlVuY29tcHJlc3MiLCJuQ29tcHJlc3NlZCIsIm5SYXciLCJpbml0aWFsSW5PZmZzZXQiLCJwYXJzZVVpbnQzMiIsImZyZXEiLCJhcHBseUx1dCIsImRhdGEiLCJuRGF0YSIsInByZWRpY3RvciIsInNvdXJjZSIsInQiLCJsZW5ndGgiLCJpbnRlcmxlYXZlU2NhbGFyIiwib3V0IiwidDEiLCJ0MiIsImZsb29yIiwic3RvcCIsImRlY29kZVJ1bkxlbmd0aCIsInNpemUiLCJieXRlTGVuZ3RoIiwicmVhZGVyIiwiRGF0YVZpZXciLCJnZXRJbnQ4IiwiY291bnQiLCJwdXNoIiwiZ2V0VWludDgiLCJsb3NzeURjdERlY29kZSIsImNzY1NldCIsInJvd1B0cnMiLCJjaGFubmVsRGF0YSIsImFjQnVmZmVyIiwiZGNCdWZmZXIiLCJkYXRhVmlldyIsIndpZHRoIiwiaWR4IiwiaGVpZ2h0IiwibnVtQ29tcCIsIm51bUZ1bGxCbG9ja3NYIiwibnVtQmxvY2tzWCIsImNlaWwiLCJudW1CbG9ja3NZIiwibGVmdG92ZXJYIiwibGVmdG92ZXJZIiwiY3VyckFjQ29tcCIsImN1cnJEY0NvbXAiLCJkY3REYXRhIiwiaGFsZlppZ0Jsb2NrIiwicm93QmxvY2siLCJyb3dPZmZzZXRzIiwiY29tcDIiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImJsb2NreSIsIm1heFkiLCJtYXhYIiwiYmxvY2t4IiwiZmlsbCIsInVuUmxlQUMiLCJ1blppZ1phZyIsImRjdEludmVyc2UiLCJjc2M3MDlJbnZlcnNlIiwiY29udmVydFRvSGFsZiIsIm9mZnNldDIiLCJ0eXBlMiIsInR5cGUiLCJ5MiIsInNyYyIsInNldFVpbnQxNiIsIm9mZnNldDMiLCJ4MiIsImhhbGZSb3ciLCJjb21wIiwiZGVjb2RlZCIsInkiLCJ4IiwiZ2V0VWludDE2Iiwic2V0RmxvYXQzMiIsImRlY29kZUZsb2F0MTYiLCJhY1ZhbHVlIiwiZGN0Q29tcCIsImRzdCIsImNvcyIsImUiLCJmIiwiZyIsImFscGhhIiwiYmV0YSIsInRoZXRhIiwiZ2FtbWEiLCJyb3ciLCJyb3dQdHIiLCJjb2x1bW4iLCJjYiIsImNyIiwidG9IYWxmRmxvYXQiLCJ0b0xpbmVhciIsImZsb2F0Iiwic2lnbiIsImFicyIsInVuY29tcHJlc3NSQVciLCJpbmZvIiwiYXJyYXkiLCJvZmZzZXQiLCJ1bmNvbXByZXNzUkxFIiwiY29tcHJlc3NlZCIsInZpZXdlciIsInNsaWNlIiwicmF3QnVmZmVyIiwidG1wQnVmZmVyIiwidW5jb21wcmVzc1pJUCIsInVuY29tcHJlc3NQSVoiLCJzY2FubGluZUJsb2NrU2l6ZSIsImNoYW5uZWxzIiwib3V0QnVmZmVyRW5kIiwicGl6Q2hhbm5lbERhdGEiLCJsaW5lcyIsIm1pbk5vblplcm8iLCJwYXJzZVVpbnQxNiIsIm1heE5vblplcm8iLCJwYXJzZVVpbnQ4IiwibWF4VmFsdWUiLCJjZCIsInN0YXJ0IiwidG1wT2Zmc2V0MiIsImNwIiwiZW5kIiwic2V0IiwidW5jb21wcmVzc1BYUiIsInN6IiwiVWludDMyQXJyYXkiLCJ0bXBCdWZmZXJFbmQiLCJ3cml0ZVB0ciIsInB0ciIsInBpeGVsIiwiZGlmZiIsInVuY29tcHJlc3NEV0EiLCJkd2FIZWFkZXIiLCJ2ZXJzaW9uIiwicGFyc2VJbnQ2NCIsInVua25vd25VbmNvbXByZXNzZWRTaXplIiwidW5rbm93bkNvbXByZXNzZWRTaXplIiwiYWNDb21wcmVzc2VkU2l6ZSIsImRjQ29tcHJlc3NlZFNpemUiLCJybGVDb21wcmVzc2VkU2l6ZSIsInJsZVVuY29tcHJlc3NlZFNpemUiLCJybGVSYXdTaXplIiwidG90YWxBY1VuY29tcHJlc3NlZENvdW50IiwidG90YWxEY1VuY29tcHJlc3NlZENvdW50IiwiYWNDb21wcmVzc2lvbiIsIkVYUkhlYWRlciIsImNvbXByZXNzaW9uIiwiY2hhbm5lbFJ1bGVzIiwicnVsZVNpemUiLCJuYW1lIiwicGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyIsImNzYyIsIkludDhBcnJheSIsImNoYW5uZWwiLCJwaXhlbFR5cGUiLCJwTGluZWFyIiwicnVsZSIsInpsaWJJbmZvIiwicmxlQnVmZmVyIiwiY2hhbiIsInJsZU9mZnNldCIsInJvd09mZnNldEJ5dGVzIiwiYnl0ZSIsInVpbnRCdWZmZXIiLCJlbmRPZmZzZXQiLCJzdHJpbmdWYWx1ZSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicGFyc2VGaXhlZExlbmd0aFN0cmluZyIsInBhcnNlUmF0aW9uYWwiLCJwYXJzZUludDMyIiwicGFyc2VUaW1lY29kZSIsIkludDMyIiwiZ2V0SW50MzIiLCJVaW50MzIiLCJnZXRVaW50MzIiLCJVaW50OCIsImludCIsInByb3RvdHlwZSIsIk51bWJlciIsImdldEJpZ0ludDY0IiwicGFyc2VGbG9hdDMyIiwiZ2V0RmxvYXQzMiIsImRlY29kZUZsb2F0MzIiLCJiaW5hcnkiLCJleHBvbmVudCIsImZyYWN0aW9uIiwiTmFOIiwiSW5maW5pdHkiLCJVaW50MTYiLCJwYXJzZUZsb2F0MTYiLCJwYXJzZUNobGlzdCIsInN0YXJ0T2Zmc2V0IiwieFNhbXBsaW5nIiwieVNhbXBsaW5nIiwicGFyc2VDaHJvbWF0aWNpdGllcyIsInJlZFgiLCJyZWRZIiwiZ3JlZW5YIiwiZ3JlZW5ZIiwiYmx1ZVgiLCJibHVlWSIsIndoaXRlWCIsIndoaXRlWSIsInBhcnNlQ29tcHJlc3Npb24iLCJjb21wcmVzc2lvbkNvZGVzIiwicGFyc2VCb3gyaSIsInhNaW4iLCJ5TWluIiwieE1heCIsInlNYXgiLCJwYXJzZUxpbmVPcmRlciIsImxpbmVPcmRlcnMiLCJsaW5lT3JkZXIiLCJwYXJzZVYyZiIsInBhcnNlVjNmIiwieiIsInBhcnNlVmFsdWUiLCJwYXJzZUhlYWRlciIsIkVYUkhlYWRlcjIiLCJzcGVjIiwic2luZ2xlVGlsZSIsImxvbmdOYW1lIiwiZGVlcEZvcm1hdCIsIm11bHRpUGFydCIsImtlZXBSZWFkaW5nIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVTaXplIiwiYXR0cmlidXRlVmFsdWUiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwic2V0dXBEZWNvZGVyIiwib3V0cHV0VHlwZSIsIkVYUkRlY29kZXIyIiwiZGF0YVdpbmRvdyIsImJ5dGVzUGVyTGluZSIsImlucHV0U2l6ZSIsInVuY29tcHJlc3MiLCJnZXR0ZXIiLCJmb3JtYXQiLCJibG9ja0NvdW50Iiwib3V0cHV0Q2hhbm5lbHMiLCJieXRlQXJyYXkiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJidWZmZXJEYXRhVmlldyIsInVJbnQ4QXJyYXkiLCJFWFJEZWNvZGVyIiwidG1wT2Zmc2V0IiwiY2hhbm5lbE9mZnNldHMiLCJSIiwiRyIsIkIiLCJBIiwiWSIsInNjYW5saW5lQmxvY2tJZHgiLCJsaW5lIiwiaXNDb21wcmVzc2VkIiwibGluZV95IiwidHJ1ZV95IiwiY2hhbm5lbElEIiwiY09mZiIsIm91dEluZGV4IiwiaGVhZGVyIiwic2V0RGF0YVR5cGUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: function() { return /* binding */ RGBELoader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    console.error(\"THREE.RGBELoader Read Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_write_error:\n                    console.error(\"THREE.RGBELoader Write Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_format_error:\n                    console.error(\"THREE.RGBELoader Bad File Format: \" + (msg || \"\"));\n                    break;\n                default:\n                case rgbe_memory_error:\n                    console.error(\"THREE.RGBELoader: Error: \" + (msg || \"\"));\n            }\n            return RGBE_RETURN_FAILURE;\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                return rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                return rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                return rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {\n            const scanline_width = w;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) {\n                return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    return rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        return rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n            if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n                let data, type;\n                let numElements;\n                switch(this.type){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const floatArray = new Float32Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                        }\n                        data = floatArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const halfArray = new Uint16Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                        }\n                        data = halfArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                        break;\n                    default:\n                        console.error(\"THREE.RGBELoader: unsupported type: \", this.type);\n                        break;\n                }\n                return {\n                    width: w,\n                    height: h,\n                    data,\n                    header: rgbe_header_info.string,\n                    gamma: rgbe_header_info.gamma,\n                    exposure: rgbe_header_info.exposure,\n                    type\n                };\n            }\n        }\n        return null;\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3RixNQUFNSyxtQkFBbUJMLG9EQUFpQkE7SUFLeEMsOERBQThEO0lBQzlETSxNQUFNQyxNQUFNLEVBQUU7UUFDWixNQUFNQyxzQkFBc0IsQ0FBQyxHQUFHQyxrQkFBa0IsR0FBR0MsbUJBQW1CLEdBQUdDLG9CQUFvQixHQUFHQyxvQkFBb0IsR0FBR0MsYUFBYSxTQUFTQyxlQUFlLEVBQUVDLEdBQUc7WUFDakssT0FBUUQ7Z0JBQ04sS0FBS0w7b0JBQ0hPLFFBQVFDLEtBQUssQ0FBQyxrQ0FBbUNGLENBQUFBLE9BQU8sRUFBQztvQkFDekQ7Z0JBQ0YsS0FBS0w7b0JBQ0hNLFFBQVFDLEtBQUssQ0FBQyxtQ0FBb0NGLENBQUFBLE9BQU8sRUFBQztvQkFDMUQ7Z0JBQ0YsS0FBS0o7b0JBQ0hLLFFBQVFDLEtBQUssQ0FBQyx1Q0FBd0NGLENBQUFBLE9BQU8sRUFBQztvQkFDOUQ7Z0JBQ0Y7Z0JBQ0EsS0FBS0g7b0JBQ0hJLFFBQVFDLEtBQUssQ0FBQyw4QkFBK0JGLENBQUFBLE9BQU8sRUFBQztZQUN6RDtZQUNBLE9BQU9QO1FBQ1QsR0FBR1UseUJBQXlCLEdBQUdDLG9CQUFvQixHQUFHQyx3QkFBd0IsR0FBR0MsVUFBVSxNQUFNQyxRQUFRLFNBQVNDLE9BQU8sRUFBRUMsU0FBUyxFQUFFQyxPQUFPO1lBQzNJLE1BQU1DLFlBQVk7WUFDbEJGLFlBQVksQ0FBQ0EsWUFBWSxPQUFPQTtZQUNoQyxJQUFJRyxJQUFJSixRQUFRSyxHQUFHLEVBQUVDLElBQUksQ0FBQyxHQUFHQyxNQUFNLEdBQUdDLElBQUksSUFBSUMsUUFBUUMsT0FBT0MsWUFBWSxDQUFDQyxLQUFLLENBQUMsTUFBTSxJQUFJQyxZQUFZYixRQUFRYyxRQUFRLENBQUNWLEdBQUdB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QUFHRSxDQUNGLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL1JHQkVMb2FkZXIuanM/ZjM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBEYXRhVXRpbHMsIExpbmVhckZpbHRlciB9IGZyb20gXCJ0aHJlZVwiO1xuY2xhc3MgUkdCRUxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZ3JhcGhpY3MuY29ybmVsbC5lZHUvfmJqdy9yZ2JlLmh0bWxcbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgUkdCRV9SRVRVUk5fRkFJTFVSRSA9IC0xLCByZ2JlX3JlYWRfZXJyb3IgPSAxLCByZ2JlX3dyaXRlX2Vycm9yID0gMiwgcmdiZV9mb3JtYXRfZXJyb3IgPSAzLCByZ2JlX21lbW9yeV9lcnJvciA9IDQsIHJnYmVfZXJyb3IgPSBmdW5jdGlvbihyZ2JlX2Vycm9yX2NvZGUsIG1zZykge1xuICAgICAgc3dpdGNoIChyZ2JlX2Vycm9yX2NvZGUpIHtcbiAgICAgICAgY2FzZSByZ2JlX3JlYWRfZXJyb3I6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlJHQkVMb2FkZXIgUmVhZCBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSByZ2JlX3dyaXRlX2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIFdyaXRlIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJnYmVfZm9ybWF0X2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIEJhZCBGaWxlIEZvcm1hdDogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSByZ2JlX21lbW9yeV9lcnJvcjpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUkdCRV9SRVRVUk5fRkFJTFVSRTtcbiAgICB9LCBSR0JFX1ZBTElEX1BST0dSQU1UWVBFID0gMSwgUkdCRV9WQUxJRF9GT1JNQVQgPSAyLCBSR0JFX1ZBTElEX0RJTUVOU0lPTlMgPSA0LCBORVdMSU5FID0gXCJcXG5cIiwgZmdldHMgPSBmdW5jdGlvbihidWZmZXIyLCBsaW5lTGltaXQsIGNvbnN1bWUpIHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEyODtcbiAgICAgIGxpbmVMaW1pdCA9ICFsaW5lTGltaXQgPyAxMDI0IDogbGluZUxpbWl0O1xuICAgICAgbGV0IHAgPSBidWZmZXIyLnBvcywgaSA9IC0xLCBsZW4gPSAwLCBzID0gXCJcIiwgY2h1bmsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSk7XG4gICAgICB3aGlsZSAoMCA+IChpID0gY2h1bmsuaW5kZXhPZihORVdMSU5FKSkgJiYgbGVuIDwgbGluZUxpbWl0ICYmIHAgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcyArPSBjaHVuaztcbiAgICAgICAgbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgcCArPSBjaHVua1NpemU7XG4gICAgICAgIGNodW5rICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjIuc3ViYXJyYXkocCwgcCArIGNodW5rU2l6ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtMSA8IGkpIHtcbiAgICAgICAgaWYgKGZhbHNlICE9PSBjb25zdW1lKVxuICAgICAgICAgIGJ1ZmZlcjIucG9zICs9IGxlbiArIGkgKyAxO1xuICAgICAgICByZXR1cm4gcyArIGNodW5rLnNsaWNlKDAsIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFJHQkVfUmVhZEhlYWRlciA9IGZ1bmN0aW9uKGJ1ZmZlcjIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljX3Rva2VuX3JlID0gL14jXFw/KFxcUyspLywgZ2FtbWFfcmUgPSAvXlxccypHQU1NQVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sIGV4cG9zdXJlX3JlID0gL15cXHMqRVhQT1NVUkVcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLCBmb3JtYXRfcmUgPSAvXlxccypGT1JNQVQ9KFxcUyspXFxzKiQvLCBkaW1lbnNpb25zX3JlID0gL15cXHMqXFwtWVxccysoXFxkKylcXHMrXFwrWFxccysoXFxkKylcXHMqJC8sIGhlYWRlciA9IHtcbiAgICAgICAgdmFsaWQ6IDAsXG4gICAgICAgIHN0cmluZzogXCJcIixcbiAgICAgICAgY29tbWVudHM6IFwiXCIsXG4gICAgICAgIHByb2dyYW10eXBlOiBcIlJHQkVcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBnYW1tYTogMSxcbiAgICAgICAgZXhwb3N1cmU6IDEsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICBsZXQgbGluZSwgbWF0Y2g7XG4gICAgICBpZiAoYnVmZmVyMi5wb3MgPj0gYnVmZmVyMi5ieXRlTGVuZ3RoIHx8ICEobGluZSA9IGZnZXRzKGJ1ZmZlcjIpKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX3JlYWRfZXJyb3IsIFwibm8gaGVhZGVyIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEobWF0Y2ggPSBsaW5lLm1hdGNoKG1hZ2ljX3Rva2VuX3JlKSkpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIGluaXRpYWwgdG9rZW5cIik7XG4gICAgICB9XG4gICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9QUk9HUkFNVFlQRTtcbiAgICAgIGhlYWRlci5wcm9ncmFtdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgaGVhZGVyLnN0cmluZyArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxpbmUgPSBmZ2V0cyhidWZmZXIyKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSBsaW5lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICBpZiAoXCIjXCIgPT09IGxpbmUuY2hhckF0KDApKSB7XG4gICAgICAgICAgaGVhZGVyLmNvbW1lbnRzICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZ2FtbWFfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLmdhbW1hID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZXhwb3N1cmUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdF9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9GT1JNQVQ7XG4gICAgICAgICAgaGVhZGVyLmZvcm1hdCA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZGltZW5zaW9uc19yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9ESU1FTlNJT05TO1xuICAgICAgICAgIGhlYWRlci5oZWlnaHQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIGhlYWRlci53aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUICYmIGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRElNRU5TSU9OUylcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJtaXNzaW5nIGZvcm1hdCBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0RJTUVOU0lPTlMpKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH0sIFJHQkVfUmVhZFBpeGVsc19STEUgPSBmdW5jdGlvbihidWZmZXIyLCB3LCBoKSB7XG4gICAgICBjb25zdCBzY2FubGluZV93aWR0aCA9IHc7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHJ1biBsZW5ndGggZW5jb2RpbmcgaXMgbm90IGFsbG93ZWQgc28gcmVhZCBmbGF0XG4gICAgICAgIHNjYW5saW5lX3dpZHRoIDwgOCB8fCBzY2FubGluZV93aWR0aCA+IDMyNzY3IHx8IC8vIHRoaXMgZmlsZSBpcyBub3QgcnVuIGxlbmd0aCBlbmNvZGVkXG4gICAgICAgIDIgIT09IGJ1ZmZlcjJbMF0gfHwgMiAhPT0gYnVmZmVyMlsxXSB8fCBidWZmZXIyWzJdICYgMTI4XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjYW5saW5lX3dpZHRoICE9PSAoYnVmZmVyMlsyXSA8PCA4IHwgYnVmZmVyMlszXSkpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwid3Jvbmcgc2NhbmxpbmUgd2lkdGhcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhX3JnYmEgPSBuZXcgVWludDhBcnJheSg0ICogdyAqIGgpO1xuICAgICAgaWYgKCFkYXRhX3JnYmEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfbWVtb3J5X2Vycm9yLCBcInVuYWJsZSB0byBhbGxvY2F0ZSBidWZmZXIgc3BhY2VcIik7XG4gICAgICB9XG4gICAgICBsZXQgb2Zmc2V0ID0gMCwgcG9zID0gMDtcbiAgICAgIGNvbnN0IHB0cl9lbmQgPSA0ICogc2NhbmxpbmVfd2lkdGg7XG4gICAgICBjb25zdCByZ2JlU3RhcnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHB0cl9lbmQpO1xuICAgICAgbGV0IG51bV9zY2FubGluZXMgPSBoO1xuICAgICAgd2hpbGUgKG51bV9zY2FubGluZXMgPiAwICYmIHBvcyA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBpZiAocG9zICsgNCA+IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmdiZVN0YXJ0WzBdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsxXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbMl0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzNdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIGlmICgyICE9IHJnYmVTdGFydFswXSB8fCAyICE9IHJnYmVTdGFydFsxXSB8fCAocmdiZVN0YXJ0WzJdIDw8IDggfCByZ2JlU3RhcnRbM10pICE9IHNjYW5saW5lX3dpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIHJnYmUgc2NhbmxpbmUgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHIgPSAwLCBjb3VudDtcbiAgICAgICAgd2hpbGUgKHB0ciA8IHB0cl9lbmQgJiYgcG9zIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgY291bnQgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICBjb25zdCBpc0VuY29kZWRSdW4gPSBjb3VudCA+IDEyODtcbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKVxuICAgICAgICAgICAgY291bnQgLT0gMTI4O1xuICAgICAgICAgIGlmICgwID09PSBjb3VudCB8fCBwdHIgKyBjb3VudCA+IHB0cl9lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcImJhZCBzY2FubGluZSBkYXRhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlVmFsdWUgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBzY2FubGluZV9idWZmZXJbcHRyKytdID0gYnl0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FubGluZV9idWZmZXIuc2V0KGJ1ZmZlcjIuc3ViYXJyYXkocG9zLCBwb3MgKyBjb3VudCksIHB0cik7XG4gICAgICAgICAgICBwdHIgKz0gY291bnQ7XG4gICAgICAgICAgICBwb3MgKz0gY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGwgPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQgb2ZmID0gMDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0XSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDFdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBudW1fc2NhbmxpbmVzLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YV9yZ2JhO1xuICAgIH07XG4gICAgY29uc3QgUkdCRUJ5dGVUb1JHQkZsb2F0ID0gZnVuY3Rpb24oc291cmNlQXJyYXksIHNvdXJjZU9mZnNldCwgZGVzdEFycmF5LCBkZXN0T2Zmc2V0KSB7XG4gICAgICBjb25zdCBlID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgM107XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGUgLSAxMjgpIC8gMjU1O1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAwXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDBdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDFdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAzXSA9IDE7XG4gICAgfTtcbiAgICBjb25zdCBSR0JFQnl0ZVRvUkdCSGFsZiA9IGZ1bmN0aW9uKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdO1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMl0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoMSk7XG4gICAgfTtcbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGJ5dGVBcnJheS5wb3MgPSAwO1xuICAgIGNvbnN0IHJnYmVfaGVhZGVyX2luZm8gPSBSR0JFX1JlYWRIZWFkZXIoYnl0ZUFycmF5KTtcbiAgICBpZiAoUkdCRV9SRVRVUk5fRkFJTFVSRSAhPT0gcmdiZV9oZWFkZXJfaW5mbykge1xuICAgICAgY29uc3QgdyA9IHJnYmVfaGVhZGVyX2luZm8ud2lkdGgsIGggPSByZ2JlX2hlYWRlcl9pbmZvLmhlaWdodCwgaW1hZ2VfcmdiYV9kYXRhID0gUkdCRV9SZWFkUGl4ZWxzX1JMRShieXRlQXJyYXkuc3ViYXJyYXkoYnl0ZUFycmF5LnBvcyksIHcsIGgpO1xuICAgICAgaWYgKFJHQkVfUkVUVVJOX0ZBSUxVUkUgIT09IGltYWdlX3JnYmFfZGF0YSkge1xuICAgICAgICBsZXQgZGF0YSwgdHlwZTtcbiAgICAgICAgbGV0IG51bUVsZW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNDtcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG51bUVsZW1lbnRzICogNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgUkdCRUJ5dGVUb1JHQkZsb2F0KGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGZsb2F0QXJyYXksIGogKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBmbG9hdEFycmF5O1xuICAgICAgICAgICAgdHlwZSA9IEZsb2F0VHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gaW1hZ2VfcmdiYV9kYXRhLmxlbmd0aCAvIDQ7XG4gICAgICAgICAgICBjb25zdCBoYWxmQXJyYXkgPSBuZXcgVWludDE2QXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgICAgICBSR0JFQnl0ZVRvUkdCSGFsZihpbWFnZV9yZ2JhX2RhdGEsIGogKiA0LCBoYWxmQXJyYXksIGogKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBoYWxmQXJyYXk7XG4gICAgICAgICAgICB0eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogdW5zdXBwb3J0ZWQgdHlwZTogXCIsIHRoaXMudHlwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGhlYWRlcjogcmdiZV9oZWFkZXJfaW5mby5zdHJpbmcsXG4gICAgICAgICAgZ2FtbWE6IHJnYmVfaGVhZGVyX2luZm8uZ2FtbWEsXG4gICAgICAgICAgZXhwb3N1cmU6IHJnYmVfaGVhZGVyX2luZm8uZXhwb3N1cmUsXG4gICAgICAgICAgdHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBzd2l0Y2ggKHRleHR1cmUudHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSAzZTM7XG4gICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICB0ZXh0dXJlLmZsaXBZID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJHQkVMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SR0JFTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIkRhdGFVdGlscyIsIkxpbmVhckZpbHRlciIsIlJHQkVMb2FkZXIiLCJwYXJzZSIsImJ1ZmZlciIsIlJHQkVfUkVUVVJOX0ZBSUxVUkUiLCJyZ2JlX3JlYWRfZXJyb3IiLCJyZ2JlX3dyaXRlX2Vycm9yIiwicmdiZV9mb3JtYXRfZXJyb3IiLCJyZ2JlX21lbW9yeV9lcnJvciIsInJnYmVfZXJyb3IiLCJyZ2JlX2Vycm9yX2NvZGUiLCJtc2ciLCJjb25zb2xlIiwiZXJyb3IiLCJSR0JFX1ZBTElEX1BST0dSQU1UWVBFIiwiUkdCRV9WQUxJRF9GT1JNQVQiLCJSR0JFX1ZBTElEX0RJTUVOU0lPTlMiLCJORVdMSU5FIiwiZmdldHMiLCJidWZmZXIyIiwibGluZUxpbWl0IiwiY29uc3VtZSIsImNodW5rU2l6ZSIsInAiLCJwb3MiLCJpIiwibGVuIiwicyIsImNodW5rIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJVaW50MTZBcnJheSIsInN1YmFycmF5IiwiaW5kZXhPZiIsImJ5dGVMZW5ndGgiLCJsZW5ndGgiLCJzbGljZSIsIlJHQkVfUmVhZEhlYWRlciIsIm1hZ2ljX3Rva2VuX3JlIiwiZ2FtbWFfcmUiLCJleHBvc3VyZV9yZSIsImZvcm1hdF9yZSIsImRpbWVuc2lvbnNfcmUiLCJoZWFkZXIiLCJ2YWxpZCIsInN0cmluZyIsImNvbW1lbnRzIiwicHJvZ3JhbXR5cGUiLCJmb3JtYXQiLCJnYW1tYSIsImV4cG9zdXJlIiwid2lkdGgiLCJoZWlnaHQiLCJsaW5lIiwibWF0Y2giLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJSR0JFX1JlYWRQaXhlbHNfUkxFIiwidyIsImgiLCJzY2FubGluZV93aWR0aCIsIlVpbnQ4QXJyYXkiLCJkYXRhX3JnYmEiLCJvZmZzZXQiLCJwdHJfZW5kIiwicmdiZVN0YXJ0Iiwic2NhbmxpbmVfYnVmZmVyIiwibnVtX3NjYW5saW5lcyIsInB0ciIsImNvdW50IiwiaXNFbmNvZGVkUnVuIiwiYnl0ZVZhbHVlIiwic2V0IiwibCIsIm9mZiIsIlJHQkVCeXRlVG9SR0JGbG9hdCIsInNvdXJjZUFycmF5Iiwic291cmNlT2Zmc2V0IiwiZGVzdEFycmF5IiwiZGVzdE9mZnNldCIsImUiLCJzY2FsZSIsIk1hdGgiLCJwb3ciLCJSR0JFQnl0ZVRvUkdCSGFsZiIsInRvSGFsZkZsb2F0IiwibWluIiwiYnl0ZUFycmF5IiwicmdiZV9oZWFkZXJfaW5mbyIsImltYWdlX3JnYmFfZGF0YSIsImRhdGEiLCJ0eXBlIiwibnVtRWxlbWVudHMiLCJmbG9hdEFycmF5IiwiRmxvYXQzMkFycmF5IiwiaiIsImhhbGZBcnJheSIsInNldERhdGFUeXBlIiwidmFsdWUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwiY29sb3JTcGFjZSIsImVuY29kaW5nIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: function() { return /* binding */ GroundProjectedEnv; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            \"#define CUBEUV_TEXEL_WIDTH \".concat(1 / width),\n            \"#define CUBEUV_TEXEL_HEIGHT \".concat(1 / height),\n            \"#define CUBEUV_MAX_MIP \".concat(_lodMax, \".0\")\n        ];\n        const vertexShader = \"\\n        varying vec3 vWorldPosition;\\n        void main() \\n        {\\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\\n            vWorldPosition = worldPosition.xyz;\\n            \\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n        }\\n        \";\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ \"\\n        #define ENVMAP_TYPE_CUBE_UV\\n        varying vec3 vWorldPosition;\\n        uniform float radius;\\n        uniform float height;\\n        uniform float angle;\\n        #ifdef ENVMAP_TYPE_CUBE\\n            uniform samplerCube map;\\n        #else\\n            uniform sampler2D map;\\n        #endif\\n        // From: https://www.shadertoy.com/view/4tsBD7\\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \\n        {\\n            float d = dot ( rd, n );\\n            \\n            if( d > 0.0 ) { return 1e6; }\\n            \\n            vec3  o = ro - c;\\n            float t = - dot( n, o ) / d;\\n            vec3  q = o + rd * t;\\n            \\n            return ( dot( q, q ) < r * r ) ? t : 1e6;\\n        }\\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \\n        {\\n            vec3 oc = ro - ce;\\n            float b = dot( oc, rd );\\n            float c = dot( oc, oc ) - ra * ra;\\n            float h = b * b - c;\\n            \\n            if( h < 0.0 ) { return -1.0; }\\n            \\n            h = sqrt( h );\\n            \\n            return - b + h;\\n        }\\n        vec3 project() \\n        {\\n            vec3 p = normalize( vWorldPosition );\\n            vec3 camPos = cameraPosition;\\n            camPos.y -= height;\\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\\n            if( intersection > 0.0 ) {\\n                \\n                vec3 h = vec3( 0.0, - height, 0.0 );\\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\\n            } else {\\n                p = vec3( 0.0, 1.0, 0.0 );\\n            }\\n            return p;\\n        }\\n        #include <common>\\n        #include <cube_uv_reflection_fragment>\\n        void main() \\n        {\\n            vec3 projectedWorldPosition = project();\\n            \\n            #ifdef ENVMAP_TYPE_CUBE\\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\\n            #else\\n                vec3 direction = normalize( projectedWorldPosition );\\n                vec2 uv = equirectUv( direction );\\n                vec3 outcolor = texture2D( map, uv ).rgb;\\n            #endif\\n            gl_FragColor = vec4( outcolor, 1.0 );\\n            #include <tonemapping_fragment>\\n            #include <\".concat(parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\", \">\\n        }\\n        \");\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdGO0FBQ3hGLE1BQU1LLGdCQUFnQixDQUFDQyxNQUFRQSxPQUFPQSxJQUFJRCxhQUFhO0FBQ3ZELE1BQU1FLDJCQUEyQlAsdUNBQUlBO0lBb0huQyxJQUFJUSxPQUFPQSxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDQyxRQUFRLENBQUNDLFFBQVEsQ0FBQ0YsTUFBTSxDQUFDRyxLQUFLLEdBQUdIO0lBQ3hDO0lBQ0EsSUFBSUEsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDQyxRQUFRLENBQUNDLFFBQVEsQ0FBQ0YsTUFBTSxDQUFDRyxLQUFLO0lBQzVDO0lBQ0EsSUFBSUMsT0FBT0EsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQ0gsUUFBUSxDQUFDQyxRQUFRLENBQUNFLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHQztJQUN4QztJQUNBLElBQUlBLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ0gsUUFBUSxDQUFDQyxRQUFRLENBQUNFLE1BQU0sQ0FBQ0QsS0FBSztJQUM1QztJQTlIQUUsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDNUIsSUFBSUMsSUFBSUM7UUFDUixNQUFNQyxZQUFZYixjQUFjUztRQUNoQyxNQUFNSyxJQUFJLENBQUNGLEtBQUtDLFlBQVksQ0FBQ0YsS0FBS0YsUUFBUU0sS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssS0FBSyxHQUFHUCxRQUFRTSxLQUFLLENBQUNDLEtBQUssS0FBSyxPQUFPSixLQUFLO1FBQ3RILE1BQU1LLFdBQVdILElBQUk7UUFDckIsTUFBTUksVUFBVUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxJQUFJLENBQUNKO1FBQ3JDLE1BQU1LLFlBQVlILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTDtRQUM5QixNQUFNRixRQUFRLElBQUlHLEtBQUtLLEdBQUcsQ0FBQ0YsV0FBVyxLQUFLO1FBQzNDLE1BQU1mLFNBQVMsSUFBSWU7UUFDbkIsTUFBTUcsVUFBVTtZQUNkWixZQUFZLDZCQUE2QjtZQUN4Qyw4QkFBdUMsT0FBVixJQUFJRztZQUNqQywrQkFBeUMsT0FBWCxJQUFJVDtZQUNsQywwQkFBaUMsT0FBUlcsU0FBUTtTQUNuQztRQUNELE1BQU1RLGVBRUg7UUFXSCxNQUFNQyxpQkFBaUJGLFFBQVFHLElBQUksQ0FBQyxRQUFRLFFBQVEsR0FDcEQsMi9FQXFFaUgsT0FBN0ZDLFNBQVNqQywyQ0FBUUEsQ0FBQ2tDLE9BQU8sQ0FBQyxRQUFRLFFBQVEsTUFBTSx3QkFBd0Isc0JBQXFCO1FBR2pILE1BQU16QixXQUFXO1lBQ2YwQixLQUFLO2dCQUFFekIsT0FBT0c7WUFBUTtZQUN0QkYsUUFBUTtnQkFBRUQsT0FBTyxDQUFDSSxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRSCxNQUFNLEtBQUs7WUFBRztZQUNuRUosUUFBUTtnQkFBRUcsT0FBTyxDQUFDSSxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRUCxNQUFNLEtBQUs7WUFBSTtRQUN0RTtRQUNBLE1BQU02QixXQUFXLElBQUluQyxzREFBbUJBLENBQUMsR0FBRztRQUM1QyxNQUFNTyxXQUFXLElBQUlOLGlEQUFjQSxDQUFDO1lBQ2xDTztZQUNBc0I7WUFDQUQ7WUFDQU8sTUFBTWxDLDZDQUFVQTtRQUNsQjtRQUNBLEtBQUssQ0FBQ2lDLFVBQVU1QjtJQUNsQjtBQWFGO0FBR0UsQ0FDRiw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvb2JqZWN0cy9Hcm91bmRQcm9qZWN0ZWRFbnYuanM/MTEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZXNoLCBSRVZJU0lPTiwgSWNvc2FoZWRyb25HZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IGlzQ3ViZVRleHR1cmUgPSAoZGVmKSA9PiBkZWYgJiYgZGVmLmlzQ3ViZVRleHR1cmU7XG5jbGFzcyBHcm91bmRQcm9qZWN0ZWRFbnYgZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaXNDdWJlTWFwID0gaXNDdWJlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBjb25zdCB3ID0gKF9iID0gaXNDdWJlTWFwID8gKF9hID0gdGV4dHVyZS5pbWFnZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpZHRoIDogdGV4dHVyZS5pbWFnZS53aWR0aCkgIT0gbnVsbCA/IF9iIDogMTAyNDtcbiAgICBjb25zdCBjdWJlU2l6ZSA9IHcgLyA0O1xuICAgIGNvbnN0IF9sb2RNYXggPSBNYXRoLmZsb29yKE1hdGgubG9nMihjdWJlU2l6ZSkpO1xuICAgIGNvbnN0IF9jdWJlU2l6ZSA9IE1hdGgucG93KDIsIF9sb2RNYXgpO1xuICAgIGNvbnN0IHdpZHRoID0gMyAqIE1hdGgubWF4KF9jdWJlU2l6ZSwgMTYgKiA3KTtcbiAgICBjb25zdCBoZWlnaHQgPSA0ICogX2N1YmVTaXplO1xuICAgIGNvbnN0IGRlZmluZXMgPSBbXG4gICAgICBpc0N1YmVNYXAgPyBcIiNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRVwiIDogXCJcIixcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9URVhFTF9XSURUSCAkezEgLyB3aWR0aH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX0hFSUdIVCAkezEgLyBoZWlnaHR9YCxcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9NQVhfTUlQICR7X2xvZE1heH0uMGBcbiAgICBdO1xuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gKCBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKSApO1xuICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuICAgICAgICB9XG4gICAgICAgIGBcbiAgICApO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gZGVmaW5lcy5qb2luKFwiXFxuXCIpICsgLyogZ2xzbCAqL1xuICAgIGBcbiAgICAgICAgI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgaGVpZ2h0O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGFuZ2xlO1xuICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSBtYXA7XG4gICAgICAgICNlbHNlXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XG4gICAgICAgICNlbmRpZlxuICAgICAgICAvLyBGcm9tOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNHRzQkQ3XG4gICAgICAgIGZsb2F0IGRpc2tJbnRlcnNlY3RXaXRoQmFja0ZhY2VDdWxsaW5nKCB2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWMzIGMsIHZlYzMgbiwgZmxvYXQgciApIFxuICAgICAgICB7XG4gICAgICAgICAgICBmbG9hdCBkID0gZG90ICggcmQsIG4gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGQgPiAwLjAgKSB7IHJldHVybiAxZTY7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmVjMyAgbyA9IHJvIC0gYztcbiAgICAgICAgICAgIGZsb2F0IHQgPSAtIGRvdCggbiwgbyApIC8gZDtcbiAgICAgICAgICAgIHZlYzMgIHEgPSBvICsgcmQgKiB0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKCBkb3QoIHEsIHEgKSA8IHIgKiByICkgPyB0IDogMWU2O1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9pbnRlcnNlY3RvcnMvaW50ZXJzZWN0b3JzLmh0bVxuICAgICAgICBmbG9hdCBzcGhlcmVJbnRlcnNlY3QoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgY2UsIGZsb2F0IHJhICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgb2MgPSBybyAtIGNlO1xuICAgICAgICAgICAgZmxvYXQgYiA9IGRvdCggb2MsIHJkICk7XG4gICAgICAgICAgICBmbG9hdCBjID0gZG90KCBvYywgb2MgKSAtIHJhICogcmE7XG4gICAgICAgICAgICBmbG9hdCBoID0gYiAqIGIgLSBjO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggaCA8IDAuMCApIHsgcmV0dXJuIC0xLjA7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaCA9IHNxcnQoIGggKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIC0gYiArIGg7XG4gICAgICAgIH1cbiAgICAgICAgdmVjMyBwcm9qZWN0KCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgcCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcbiAgICAgICAgICAgIHZlYzMgY2FtUG9zID0gY2FtZXJhUG9zaXRpb247XG4gICAgICAgICAgICBjYW1Qb3MueSAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBmbG9hdCBpbnRlcnNlY3Rpb24gPSBzcGhlcmVJbnRlcnNlY3QoIGNhbVBvcywgcCwgdmVjMyggMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgaWYoIGludGVyc2VjdGlvbiA+IDAuMCApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2ZWMzIGggPSB2ZWMzKCAwLjAsIC0gaGVpZ2h0LCAwLjAgKTtcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnRlcnNlY3Rpb24yID0gZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIGNhbVBvcywgcCwgaCwgdmVjMyggMC4wLCAxLjAsIDAuMCApLCByYWRpdXMgKTtcbiAgICAgICAgICAgICAgICBwID0gKCBjYW1Qb3MgKyBtaW4oIGludGVyc2VjdGlvbiwgaW50ZXJzZWN0aW9uMiApICogcCApIC8gcmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gdmVjMyggMC4wLCAxLjAsIDAuMCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgI2luY2x1ZGUgPGNvbW1vbj5cbiAgICAgICAgI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cbiAgICAgICAgdm9pZCBtYWluKCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgcHJvamVjdGVkV29ybGRQb3NpdGlvbiA9IHByb2plY3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZUN1YmUoIG1hcCwgcHJvamVjdGVkV29ybGRQb3NpdGlvbiApLnJnYjtcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHByb2plY3RlZFdvcmxkUG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMyIHV2ID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XG4gICAgICAgICAgICAgICAgdmVjMyBvdXRjb2xvciA9IHRleHR1cmUyRCggbWFwLCB1diApLnJnYjtcbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Y29sb3IsIDEuMCApO1xuICAgICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuICAgICAgICAgICAgI2luY2x1ZGUgPCR7cGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkgPj0gMTU0ID8gXCJjb2xvcnNwYWNlX2ZyYWdtZW50XCIgOiBcImVuY29kaW5nc19mcmFnbWVudFwifT5cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgbWFwOiB7IHZhbHVlOiB0ZXh0dXJlIH0sXG4gICAgICBoZWlnaHQ6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgfHwgMTUgfSxcbiAgICAgIHJhZGl1czogeyB2YWx1ZTogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSB8fCAxMDAgfVxuICAgIH07XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeSgxLCAxNik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXMsXG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIHNpZGU6IERvdWJsZVNpZGVcbiAgICB9KTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICB9XG4gIHNldCByYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gIH1cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gIH1cbiAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZSA9IGhlaWdodDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgR3JvdW5kUHJvamVjdGVkRW52XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdW5kUHJvamVjdGVkRW52LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1lc2giLCJSRVZJU0lPTiIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJTaGFkZXJNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJpc0N1YmVUZXh0dXJlIiwiZGVmIiwiR3JvdW5kUHJvamVjdGVkRW52IiwicmFkaXVzIiwibWF0ZXJpYWwiLCJ1bmlmb3JtcyIsInZhbHVlIiwiaGVpZ2h0IiwiY29uc3RydWN0b3IiLCJ0ZXh0dXJlIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJpc0N1YmVNYXAiLCJ3IiwiaW1hZ2UiLCJ3aWR0aCIsImN1YmVTaXplIiwiX2xvZE1heCIsIk1hdGgiLCJmbG9vciIsImxvZzIiLCJfY3ViZVNpemUiLCJwb3ciLCJtYXgiLCJkZWZpbmVzIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJqb2luIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwibWFwIiwiZ2VvbWV0cnkiLCJzaWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js\n"));

/***/ })

});