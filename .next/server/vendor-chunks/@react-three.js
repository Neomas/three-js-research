"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\nconst isRef = (obj)=>obj.current && obj.current.isScene;\nconst resolveScene = (scene)=>isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, blur = 0) {\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    // @ts-ignore\n    const oldBlur = target.backgroundBlurriness || 0;\n    if (background !== \"only\") target.environment = texture;\n    if (background) target.background = texture;\n    // @ts-ignore\n    if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = blur;\n    return ()=>{\n        if (background !== \"only\") target.environment = oldenv;\n        if (background) target.background = oldbg;\n        // @ts-ignore\n        if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = oldBlur;\n    };\n}\nfunction EnvironmentMap({ scene, background = false, blur, map }) {\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (map) return setEnvProps(background, scene, defaultScene, map, blur);\n    }, [\n        defaultScene,\n        scene,\n        map,\n        background,\n        blur\n    ]);\n    return null;\n}\nfunction EnvironmentCube({ background = false, scene, blur, ...rest }) {\n    const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        return setEnvProps(background, scene, defaultScene, texture, blur);\n    }, [\n        texture,\n        background,\n        scene,\n        defaultScene,\n        blur\n    ]);\n    return null;\n}\nfunction EnvironmentPortal({ children, near = 1, far = 1000, resolution = 256, frames = 1, map, background = false, blur, scene, files, path, preset = undefined, extensions }) {\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.gl);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((state)=>state.scene);\n    const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n    const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n        fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n        return fbo;\n    }, [\n        resolution\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (frames === 1) camera.current.update(gl, virtualScene);\n        return setEnvProps(background, scene, defaultScene, fbo.texture, blur);\n    }, [\n        children,\n        virtualScene,\n        fbo.texture,\n        scene,\n        defaultScene,\n        background,\n        frames,\n        gl\n    ]);\n    let count = 1;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.C)(()=>{\n        if (frames === Infinity || count < frames) {\n            camera.current.update(gl, virtualScene);\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.g)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n        ref: camera,\n        args: [\n            near,\n            far,\n            fbo\n        ]\n    }), files || preset ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n        background: true,\n        files: files,\n        preset: preset,\n        path: path,\n        extensions: extensions\n    }) : map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n        background: true,\n        map: map,\n        extensions: extensions\n    }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n    var _props$ground, _props$ground2, _scale, _props$ground3;\n    const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n    const texture = props.map || textureDefault;\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n            GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n        }), []);\n    const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            texture\n        ], [\n        texture\n    ]);\n    const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n    const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n    const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        map: texture\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n        args: args,\n        scale: scale,\n        height: height,\n        radius: radius\n    }));\n}\nfunction Environment(props) {\n    return props.ground ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMrQztBQUNWO0FBQ2xCO0FBQ0c7QUFFckQsTUFBTVcsUUFBUUMsQ0FBQUEsTUFBT0EsSUFBSUMsT0FBTyxJQUFJRCxJQUFJQyxPQUFPLENBQUNDLE9BQU87QUFDdkQsTUFBTUMsZUFBZUMsQ0FBQUEsUUFBU0wsTUFBTUssU0FBU0EsTUFBTUgsT0FBTyxHQUFHRztBQUM3RCxTQUFTQyxZQUFZQyxVQUFVLEVBQUVGLEtBQUssRUFBRUcsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sQ0FBQztJQUNyRSxNQUFNQyxTQUFTUCxhQUFhQyxTQUFTRztJQUNyQyxNQUFNSSxRQUFRRCxPQUFPSixVQUFVO0lBQy9CLE1BQU1NLFNBQVNGLE9BQU9HLFdBQVc7SUFDakMsYUFBYTtJQUNiLE1BQU1DLFVBQVVKLE9BQU9LLG9CQUFvQixJQUFJO0lBQy9DLElBQUlULGVBQWUsUUFBUUksT0FBT0csV0FBVyxHQUFHTDtJQUNoRCxJQUFJRixZQUFZSSxPQUFPSixVQUFVLEdBQUdFO0lBQ3BDLGFBQWE7SUFDYixJQUFJRixjQUFjSSxPQUFPSyxvQkFBb0IsS0FBS0MsV0FBV04sT0FBT0ssb0JBQW9CLEdBQUdOO0lBQzNGLE9BQU87UUFDTCxJQUFJSCxlQUFlLFFBQVFJLE9BQU9HLFdBQVcsR0FBR0Q7UUFDaEQsSUFBSU4sWUFBWUksT0FBT0osVUFBVSxHQUFHSztRQUNwQyxhQUFhO1FBQ2IsSUFBSUwsY0FBY0ksT0FBT0ssb0JBQW9CLEtBQUtDLFdBQVdOLE9BQU9LLG9CQUFvQixHQUFHRDtJQUM3RjtBQUNGO0FBQ0EsU0FBU0csZUFBZSxFQUN0QmIsS0FBSyxFQUNMRSxhQUFhLEtBQUssRUFDbEJHLElBQUksRUFDSlMsR0FBRyxFQUNKO0lBQ0MsTUFBTVgsZUFBZWpCLHFEQUFRQSxDQUFDNkIsQ0FBQUEs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QUNrQyxtQkFBbUIwQixTQUFTLFdBQVcsR0FBRTVELGdEQUFtQixDQUFDZ0MsaUJBQWlCNEI7QUFDM1I7QUFFMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0Vudmlyb25tZW50LmpzPzYwNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lLCBjcmVhdGVQb3J0YWwsIGV4dGVuZCB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBTY2VuZSwgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0LCBIYWxmRmxvYXRUeXBlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgR3JvdW5kUHJvamVjdGVkRW52IH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHVzZUVudmlyb25tZW50IH0gZnJvbSAnLi91c2VFbnZpcm9ubWVudC5qcyc7XG5cbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iai5jdXJyZW50ICYmIG9iai5jdXJyZW50LmlzU2NlbmU7XG5jb25zdCByZXNvbHZlU2NlbmUgPSBzY2VuZSA9PiBpc1JlZihzY2VuZSkgPyBzY2VuZS5jdXJyZW50IDogc2NlbmU7XG5mdW5jdGlvbiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCB0ZXh0dXJlLCBibHVyID0gMCkge1xuICBjb25zdCB0YXJnZXQgPSByZXNvbHZlU2NlbmUoc2NlbmUgfHwgZGVmYXVsdFNjZW5lKTtcbiAgY29uc3Qgb2xkYmcgPSB0YXJnZXQuYmFja2dyb3VuZDtcbiAgY29uc3Qgb2xkZW52ID0gdGFyZ2V0LmVudmlyb25tZW50O1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG9sZEJsdXIgPSB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgfHwgMDtcbiAgaWYgKGJhY2tncm91bmQgIT09ICdvbmx5JykgdGFyZ2V0LmVudmlyb25tZW50ID0gdGV4dHVyZTtcbiAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gdGV4dHVyZTtcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAoYmFja2dyb3VuZCAmJiB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgIT09IHVuZGVmaW5lZCkgdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzID0gYmx1cjtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoYmFja2dyb3VuZCAhPT0gJ29ubHknKSB0YXJnZXQuZW52aXJvbm1lbnQgPSBvbGRlbnY7XG4gICAgaWYgKGJhY2tncm91bmQpIHRhcmdldC5iYWNrZ3JvdW5kID0gb2xkYmc7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChiYWNrZ3JvdW5kICYmIHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyAhPT0gdW5kZWZpbmVkKSB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSBvbGRCbHVyO1xuICB9O1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRNYXAoe1xuICBzY2VuZSxcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBibHVyLFxuICBtYXBcbn0pIHtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXApIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBtYXAsIGJsdXIpO1xuICB9LCBbZGVmYXVsdFNjZW5lLCBzY2VuZSwgbWFwLCBiYWNrZ3JvdW5kLCBibHVyXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRDdWJlKHtcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBzY2VuZSxcbiAgYmx1cixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCB0ZXh0dXJlID0gdXNlRW52aXJvbm1lbnQocmVzdCk7XG4gIGNvbnN0IGRlZmF1bHRTY2VuZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNjZW5lKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gc2V0RW52UHJvcHMoYmFja2dyb3VuZCwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgdGV4dHVyZSwgYmx1cik7XG4gIH0sIFt0ZXh0dXJlLCBiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBibHVyXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRQb3J0YWwoe1xuICBjaGlsZHJlbixcbiAgbmVhciA9IDEsXG4gIGZhciA9IDEwMDAsXG4gIHJlc29sdXRpb24gPSAyNTYsXG4gIGZyYW1lcyA9IDEsXG4gIG1hcCxcbiAgYmFja2dyb3VuZCA9IGZhbHNlLFxuICBibHVyLFxuICBzY2VuZSxcbiAgZmlsZXMsXG4gIHBhdGgsXG4gIHByZXNldCA9IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uc1xufSkge1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBjb25zdCBjYW1lcmEgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFt2aXJ0dWFsU2NlbmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFNjZW5lKCkpO1xuICBjb25zdCBmYm8gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBmYm8gPSBuZXcgV2ViR0xDdWJlUmVuZGVyVGFyZ2V0KHJlc29sdXRpb24pO1xuICAgIGZiby50ZXh0dXJlLnR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICAgIHJldHVybiBmYm87XG4gIH0sIFtyZXNvbHV0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gMSkgY2FtZXJhLmN1cnJlbnQudXBkYXRlKGdsLCB2aXJ0dWFsU2NlbmUpO1xuICAgIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBmYm8udGV4dHVyZSwgYmx1cik7XG4gIH0sIFtjaGlsZHJlbiwgdmlydHVhbFNjZW5lLCBmYm8udGV4dHVyZSwgc2NlbmUsIGRlZmF1bHRTY2VuZSwgYmFja2dyb3VuZCwgZnJhbWVzLCBnbF0pO1xuICBsZXQgY291bnQgPSAxO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpIHtcbiAgICAgIGNhbWVyYS5jdXJyZW50LnVwZGF0ZShnbCwgdmlydHVhbFNjZW5lKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbiwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjdWJlQ2FtZXJhXCIsIHtcbiAgICByZWY6IGNhbWVyYSxcbiAgICBhcmdzOiBbbmVhciwgZmFyLCBmYm9dXG4gIH0pLCBmaWxlcyB8fCBwcmVzZXQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHtcbiAgICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAgIGZpbGVzOiBmaWxlcyxcbiAgICBwcmVzZXQ6IHByZXNldCxcbiAgICBwYXRoOiBwYXRoLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnNcbiAgfSkgOiBtYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwge1xuICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgbWFwOiBtYXAsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICB9KSA6IG51bGwpLCB2aXJ0dWFsU2NlbmUpKTtcbn1cbmZ1bmN0aW9uIEVudmlyb25tZW50R3JvdW5kKHByb3BzKSB7XG4gIHZhciBfcHJvcHMkZ3JvdW5kLCBfcHJvcHMkZ3JvdW5kMiwgX3NjYWxlLCBfcHJvcHMkZ3JvdW5kMztcbiAgY29uc3QgdGV4dHVyZURlZmF1bHQgPSB1c2VFbnZpcm9ubWVudChwcm9wcyk7XG4gIGNvbnN0IHRleHR1cmUgPSBwcm9wcy5tYXAgfHwgdGV4dHVyZURlZmF1bHQ7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBHcm91bmRQcm9qZWN0ZWRFbnZJbXBsOiBHcm91bmRQcm9qZWN0ZWRFbnZcbiAgfSksIFtdKTtcbiAgY29uc3QgYXJncyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gW3RleHR1cmVdLCBbdGV4dHVyZV0pO1xuICBjb25zdCBoZWlnaHQgPSAoX3Byb3BzJGdyb3VuZCA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQuaGVpZ2h0O1xuICBjb25zdCByYWRpdXMgPSAoX3Byb3BzJGdyb3VuZDIgPSBwcm9wcy5ncm91bmQpID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ3JvdW5kMi5yYWRpdXM7XG4gIGNvbnN0IHNjYWxlID0gKF9zY2FsZSA9IChfcHJvcHMkZ3JvdW5kMyA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQzLnNjYWxlKSAhPT0gbnVsbCAmJiBfc2NhbGUgIT09IHZvaWQgMCA/IF9zY2FsZSA6IDEwMDA7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRNYXAsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIG1hcDogdGV4dHVyZVxuICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdW5kUHJvamVjdGVkRW52SW1wbFwiLCB7XG4gICAgYXJnczogYXJncyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgcmFkaXVzOiByYWRpdXNcbiAgfSkpO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnQocHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzLmdyb3VuZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50R3JvdW5kLCBwcm9wcykgOiBwcm9wcy5tYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwgcHJvcHMpIDogcHJvcHMuY2hpbGRyZW4gPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudFBvcnRhbCwgcHJvcHMpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRDdWJlLCBwcm9wcyk7XG59XG5cbmV4cG9ydCB7IEVudmlyb25tZW50LCBFbnZpcm9ubWVudEN1YmUsIEVudmlyb25tZW50TWFwLCBFbnZpcm9ubWVudFBvcnRhbCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwiY3JlYXRlUG9ydGFsIiwiZXh0ZW5kIiwiU2NlbmUiLCJXZWJHTEN1YmVSZW5kZXJUYXJnZXQiLCJIYWxmRmxvYXRUeXBlIiwiR3JvdW5kUHJvamVjdGVkRW52IiwidXNlRW52aXJvbm1lbnQiLCJpc1JlZiIsIm9iaiIsImN1cnJlbnQiLCJpc1NjZW5lIiwicmVzb2x2ZVNjZW5lIiwic2NlbmUiLCJzZXRFbnZQcm9wcyIsImJhY2tncm91bmQiLCJkZWZhdWx0U2NlbmUiLCJ0ZXh0dXJlIiwiYmx1ciIsInRhcmdldCIsIm9sZGJnIiwib2xkZW52IiwiZW52aXJvbm1lbnQiLCJvbGRCbHVyIiwiYmFja2dyb3VuZEJsdXJyaW5lc3MiLCJ1bmRlZmluZWQiLCJFbnZpcm9ubWVudE1hcCIsIm1hcCIsInN0YXRlIiwidXNlTGF5b3V0RWZmZWN0IiwiRW52aXJvbm1lbnRDdWJlIiwicmVzdCIsIkVudmlyb25tZW50UG9ydGFsIiwiY2hpbGRyZW4iLCJuZWFyIiwiZmFyIiwicmVzb2x1dGlvbiIsImZyYW1lcyIsImZpbGVzIiwicGF0aCIsInByZXNldCIsImV4dGVuc2lvbnMiLCJnbCIsImNhbWVyYSIsInVzZVJlZiIsInZpcnR1YWxTY2VuZSIsInVzZVN0YXRlIiwiZmJvIiwidXNlTWVtbyIsInR5cGUiLCJ1cGRhdGUiLCJjb3VudCIsIkluZmluaXR5IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwicmVmIiwiYXJncyIsIkVudmlyb25tZW50R3JvdW5kIiwicHJvcHMiLCJfcHJvcHMkZ3JvdW5kIiwiX3Byb3BzJGdyb3VuZDIiLCJfc2NhbGUiLCJfcHJvcHMkZ3JvdW5kMyIsInRleHR1cmVEZWZhdWx0IiwiR3JvdW5kUHJvamVjdGVkRW52SW1wbCIsImhlaWdodCIsImdyb3VuZCIsInJhZGl1cyIsInNjYWxlIiwiRW52aXJvbm1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/PerspectiveCamera.js":
/*!******************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/PerspectiveCamera.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerspectiveCamera: () => (/* binding */ PerspectiveCamera)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var react_merge_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-merge-refs */ \"(ssr)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\");\n/* harmony import */ var _useFBO_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useFBO.js */ \"(ssr)/./node_modules/@react-three/drei/core/useFBO.js\");\n\n\n\n\n\nconst isFunction = (node)=>typeof node === \"function\";\nconst PerspectiveCamera = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ envMap, resolution = 256, frames = Infinity, makeDefault, children, ...props }, ref)=>{\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)(({ set })=>set);\n    const camera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)(({ camera })=>camera);\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)(({ size })=>size);\n    const cameraRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const groupRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const fbo = (0,_useFBO_js__WEBPACK_IMPORTED_MODULE_4__.useFBO)(resolution);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (!props.manual) {\n            cameraRef.current.aspect = size.width / size.height;\n        }\n    }, [\n        size,\n        props\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        cameraRef.current.updateProjectionMatrix();\n    });\n    let count = 0;\n    let oldEnvMap = null;\n    const functional = isFunction(children);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)((state)=>{\n        if (functional && (frames === Infinity || count < frames)) {\n            groupRef.current.visible = false;\n            state.gl.setRenderTarget(fbo);\n            oldEnvMap = state.scene.background;\n            if (envMap) state.scene.background = envMap;\n            state.gl.render(state.scene, cameraRef.current);\n            state.scene.background = oldEnvMap;\n            state.gl.setRenderTarget(null);\n            groupRef.current.visible = true;\n            count++;\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (makeDefault) {\n            const oldCam = camera;\n            set(()=>({\n                    camera: cameraRef.current\n                }));\n            return ()=>set(()=>({\n                        camera: oldCam\n                    }));\n        }\n    // The camera should not be part of the dependency list because this components camera is a stable reference\n    // that must exchange the default, and clean up after itself on unmount.\n    }, [\n        cameraRef,\n        makeDefault,\n        set\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"perspectiveCamera\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            cameraRef,\n            ref\n        ])\n    }, props), !functional && children), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        ref: groupRef\n    }, functional && children(fbo.texture)));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9QZXJzcGVjdGl2ZUNhbWVyYS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ3lCO0FBQ2Y7QUFDSjtBQUVyQyxNQUFNTSxhQUFhQyxDQUFBQSxPQUFRLE9BQU9BLFNBQVM7QUFDM0MsTUFBTUMsb0JBQW9CLGFBQWEsaUJBQUVQLDZDQUFnQixDQUFDLENBQUMsRUFDekRTLE1BQU0sRUFDTkMsYUFBYSxHQUFHLEVBQ2hCQyxTQUFTQyxRQUFRLEVBQ2pCQyxXQUFXLEVBQ1hDLFFBQVEsRUFDUixHQUFHQyxPQUNKLEVBQUVDO0lBQ0QsTUFBTUMsTUFBTWhCLHFEQUFRQSxDQUFDLENBQUMsRUFDcEJnQixHQUFHLEVBQ0osR0FBS0E7SUFDTixNQUFNQyxTQUFTakIscURBQVFBLENBQUMsQ0FBQyxFQUN2QmlCLE1BQU0sRUFDUCxHQUFLQTtJQUNOLE1BQU1DLE9BQU9sQixxREFBUUEsQ0FBQyxDQUFDLEVBQ3JCa0IsSUFBSSxFQUNMLEdBQUtBO0lBQ04sTUFBTUMsWUFBWXBCLHlDQUFZLENBQUM7SUFDL0IsTUFBTXNCLFdBQVd0Qix5Q0FBWSxDQUFDO0lBQzlCLE1BQU11QixNQUFNbkIsa0RBQU1BLENBQUNNO0lBQ25CVixrREFBcUIsQ0FBQztRQUNwQixJQUFJLENBQUNlLE1BQU1VLE1BQU0sRUFBRTtZQUNqQkwsVUFBVU0sT0FBTyxDQUFDQyxNQUFNLEdBQUdSLEtBQUtTLEtBQUssR0FBR1QsS0FBS1UsTUFBTTtRQUNyRDtJQUNGLEdBQUc7UUFBQ1Y7UUFBTUo7S0FBTTtJQUNoQmYsa0RBQXFCLENBQUM7UUFDcEJvQixVQUFVTSxPQUFPLENBQUNJLHNCQUFzQjtJQUMxQztJQUNBLElBQUlDLFFBQVE7SUFDWixJQUFJQyxZQUFZO0lBQ2hCLE1BQU1DLGFBQWE1QixXQUFXUztJQUM5QloscURBQVFBLENBQUNnQyxDQUFBQTtRQUNQLElBQUlELGNBQWV0QixDQUFBQSxXQUFXQyxZQUFZbUIsUUFBUXBCLE1BQUssR0FBSTtZQUN6RFcsU0FBU0ksT0FBTyxDQUFDUyxPQUFPLEdBQUc7WUFDM0JELE1BQU1FLEVBQUUsQ0FBQ0MsZUFBZSxDQUFDZDtZQUN6QlMsWUFBWUUsTUFBTUksS0FBSyxDQUFDQyxVQUFVO1lBQ2xDLElBQUk5QixRQUFReUIsTUFBTUksS0FBSyxDQUFDQyxVQUFVLEdBQUc5QjtZQUNyQ3lCLE1BQU1FLEVBQUUsQ0FBQ0ksTUFBTSxDQUFDTixNQUFNSSxLQUFLLEVBQUVsQixVQUFVTSxPQUFPO1lBQzlDUSxNQUFNSSxLQUFLLENBQUNDLFVBQVUsR0FBR1A7WUFDekJFLE1BQU1FLEVBQUUsQ0FBQ0MsZUFBZSxDQUFDO1lBQ3pCZixTQUFTSSxPQUFPLENBQUNTLE9BQU8sR0FBRztZQUMzQko7UUFDRjtJQUNGO0lBQ0EvQixrREFBcUIsQ0FBQztRQUNwQixJQUFJYSxhQUFhO1lBQ2YsTUFBTTRCLFNBQVN2QjtZQUNmRCxJQUFJLElBQU87b0JBQ1RDLFFBQVFFLFVBQVVNLE9BQU87Z0JBQzNCO1lBQ0EsT0FBTyxJQUFNVCxJQUFJLElBQU87d0JBQ3RCQyxRQUFRdUI7b0JBQ1Y7UUFDRjtJQUNBLDRHQUE0RztJQUM1Ryx3RUFBd0U7SUFDMUUsR0FBRztRQUFDckI7UUFBV1A7UUFBYUk7S0FBSTtJQUNoQyxPQUFPLFdBQVcsR0FBRWpCLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU0sV0FBVyxHQUFFQSxnREFBbUIsQ0FBQyxxQkFBcUJELDhFQUFRQSxDQUFDO1FBQzNIaUIsS0FBS2IsNERBQVNBLENBQUM7WUFBQ2lCO1lBQVdKO1NBQUk7SUFDakMsR0FBR0QsUUFBUSxDQUFDa0IsY0FBY25CLFdBQVcsV0FBVyxHQUFFZCxnREFBbUIsQ0FBQyxTQUFTO1FBQzdFZ0IsS0FBS007SUFDUCxHQUFHVyxjQUFjbkIsU0FBU1MsSUFBSXFCLE9BQU87QUFDdkM7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1BlcnNwZWN0aXZlQ2FtZXJhLmpzPzQ2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCBtZXJnZVJlZnMgZnJvbSAncmVhY3QtbWVyZ2UtcmVmcyc7XG5pbXBvcnQgeyB1c2VGQk8gfSBmcm9tICcuL3VzZUZCTy5qcyc7XG5cbmNvbnN0IGlzRnVuY3Rpb24gPSBub2RlID0+IHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nO1xuY29uc3QgUGVyc3BlY3RpdmVDYW1lcmEgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGVudk1hcCxcbiAgcmVzb2x1dGlvbiA9IDI1NixcbiAgZnJhbWVzID0gSW5maW5pdHksXG4gIG1ha2VEZWZhdWx0LFxuICBjaGlsZHJlbixcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBzZXQgPSB1c2VUaHJlZSgoe1xuICAgIHNldFxuICB9KSA9PiBzZXQpO1xuICBjb25zdCBjYW1lcmEgPSB1c2VUaHJlZSgoe1xuICAgIGNhbWVyYVxuICB9KSA9PiBjYW1lcmEpO1xuICBjb25zdCBzaXplID0gdXNlVGhyZWUoKHtcbiAgICBzaXplXG4gIH0pID0+IHNpemUpO1xuICBjb25zdCBjYW1lcmFSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGdyb3VwUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmYm8gPSB1c2VGQk8ocmVzb2x1dGlvbik7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwcm9wcy5tYW51YWwpIHtcbiAgICAgIGNhbWVyYVJlZi5jdXJyZW50LmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gIH0sIFtzaXplLCBwcm9wc10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNhbWVyYVJlZi5jdXJyZW50LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfSk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBvbGRFbnZNYXAgPSBudWxsO1xuICBjb25zdCBmdW5jdGlvbmFsID0gaXNGdW5jdGlvbihjaGlsZHJlbik7XG4gIHVzZUZyYW1lKHN0YXRlID0+IHtcbiAgICBpZiAoZnVuY3Rpb25hbCAmJiAoZnJhbWVzID09PSBJbmZpbml0eSB8fCBjb3VudCA8IGZyYW1lcykpIHtcbiAgICAgIGdyb3VwUmVmLmN1cnJlbnQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUuZ2wuc2V0UmVuZGVyVGFyZ2V0KGZibyk7XG4gICAgICBvbGRFbnZNYXAgPSBzdGF0ZS5zY2VuZS5iYWNrZ3JvdW5kO1xuICAgICAgaWYgKGVudk1hcCkgc3RhdGUuc2NlbmUuYmFja2dyb3VuZCA9IGVudk1hcDtcbiAgICAgIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgY2FtZXJhUmVmLmN1cnJlbnQpO1xuICAgICAgc3RhdGUuc2NlbmUuYmFja2dyb3VuZCA9IG9sZEVudk1hcDtcbiAgICAgIHN0YXRlLmdsLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgIGdyb3VwUmVmLmN1cnJlbnQudmlzaWJsZSA9IHRydWU7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1ha2VEZWZhdWx0KSB7XG4gICAgICBjb25zdCBvbGRDYW0gPSBjYW1lcmE7XG4gICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFSZWYuY3VycmVudFxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuICgpID0+IHNldCgoKSA9PiAoe1xuICAgICAgICBjYW1lcmE6IG9sZENhbVxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvLyBUaGUgY2FtZXJhIHNob3VsZCBub3QgYmUgcGFydCBvZiB0aGUgZGVwZW5kZW5jeSBsaXN0IGJlY2F1c2UgdGhpcyBjb21wb25lbnRzIGNhbWVyYSBpcyBhIHN0YWJsZSByZWZlcmVuY2VcbiAgICAvLyB0aGF0IG11c3QgZXhjaGFuZ2UgdGhlIGRlZmF1bHQsIGFuZCBjbGVhbiB1cCBhZnRlciBpdHNlbGYgb24gdW5tb3VudC5cbiAgfSwgW2NhbWVyYVJlZiwgbWFrZURlZmF1bHQsIHNldF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGVyc3BlY3RpdmVDYW1lcmFcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogbWVyZ2VSZWZzKFtjYW1lcmFSZWYsIHJlZl0pXG4gIH0sIHByb3BzKSwgIWZ1bmN0aW9uYWwgJiYgY2hpbGRyZW4pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHtcbiAgICByZWY6IGdyb3VwUmVmXG4gIH0sIGZ1bmN0aW9uYWwgJiYgY2hpbGRyZW4oZmJvLnRleHR1cmUpKSk7XG59KTtcblxuZXhwb3J0IHsgUGVyc3BlY3RpdmVDYW1lcmEgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwidXNlVGhyZWUiLCJ1c2VGcmFtZSIsIm1lcmdlUmVmcyIsInVzZUZCTyIsImlzRnVuY3Rpb24iLCJub2RlIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJmb3J3YXJkUmVmIiwiZW52TWFwIiwicmVzb2x1dGlvbiIsImZyYW1lcyIsIkluZmluaXR5IiwibWFrZURlZmF1bHQiLCJjaGlsZHJlbiIsInByb3BzIiwicmVmIiwic2V0IiwiY2FtZXJhIiwic2l6ZSIsImNhbWVyYVJlZiIsInVzZVJlZiIsImdyb3VwUmVmIiwiZmJvIiwidXNlTGF5b3V0RWZmZWN0IiwibWFudWFsIiwiY3VycmVudCIsImFzcGVjdCIsIndpZHRoIiwiaGVpZ2h0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImNvdW50Iiwib2xkRW52TWFwIiwiZnVuY3Rpb25hbCIsInN0YXRlIiwidmlzaWJsZSIsImdsIiwic2V0UmVuZGVyVGFyZ2V0Iiwic2NlbmUiLCJiYWNrZ3JvdW5kIiwicmVuZGVyIiwib2xkQ2FtIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwidGV4dHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/PerspectiveCamera.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n\n\n\n\nconst CUBEMAP_ROOT = \"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\";\nconst isArray = (arr)=>Array.isArray(arr);\nfunction useEnvironment({ files = [\n    \"/px.png\",\n    \"/nx.png\",\n    \"/py.png\",\n    \"/ny.png\",\n    \"/pz.png\",\n    \"/nz.png\"\n], path = \"\", preset = undefined, encoding = undefined, extensions } = {}) {\n    var _files$split$pop;\n    let loader = null;\n    let isCubeMap = false;\n    let extension;\n    if (preset) {\n        if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj)) throw new Error(\"Preset must be one of: \" + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj).join(\", \"));\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    // Everything else\n    isCubeMap = isArray(files);\n    extension = isArray(files) ? \"cube\" : files.startsWith(\"data:application/exr\") ? \"exr\" : files.startsWith(\"data:application/hdr\") ? \"hdr\" : (_files$split$pop = files.split(\".\").pop()) == null || (_files$split$pop = _files$split$pop.split(\"?\")) == null || (_files$split$pop = _files$split$pop.shift()) == null ? void 0 : _files$split$pop.toLowerCase();\n    loader = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeTextureLoader : extension === \"hdr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_2__.RGBELoader : extension === \"exr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_3__.EXRLoader : null;\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(// @ts-expect-error\n    loader, isCubeMap ? [\n        files\n    ] : files, (loader)=>{\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n    const texture = isCubeMap ? // @ts-ignore\n    loaderResult[0] : loaderResult;\n    texture.mapping = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_1__.EquirectangularReflectionMapping;\n    const sRGBEncoding = 3001;\n    const LinearEncoding = 3000;\n    if (\"colorSpace\" in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? \"srgb\" : \"srgb-linear\";\n    else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? sRGBEncoding : LinearEncoding;\n    return texture;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDb0Q7QUFDOUM7QUFDUztBQUU5RCxNQUFNTyxlQUFlO0FBQ3JCLE1BQU1DLFVBQVVDLENBQUFBLE1BQU9DLE1BQU1GLE9BQU8sQ0FBQ0M7QUFDckMsU0FBU0UsZUFBZSxFQUN0QkMsUUFBUTtJQUFDO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztDQUFVLEVBQzFFQyxPQUFPLEVBQUUsRUFDVEMsU0FBU0MsU0FBUyxFQUNsQkMsV0FBV0QsU0FBUyxFQUNwQkUsVUFBVSxFQUNYLEdBQUcsQ0FBQyxDQUFDO0lBQ0osSUFBSUM7SUFDSixJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsWUFBWTtJQUNoQixJQUFJQztJQUNKLElBQUlQLFFBQVE7UUFDVixJQUFJLENBQUVBLENBQUFBLFVBQVVSLHNFQUFTLEdBQUksTUFBTSxJQUFJZ0IsTUFBTSw0QkFBNEJDLE9BQU9DLElBQUksQ0FBQ2xCLHNFQUFVQSxFQUFFbUIsSUFBSSxDQUFDO1FBQ3RHYixRQUFRTixzRUFBVSxDQUFDUSxPQUFPO1FBQzFCRCxPQUFPTjtJQUNUO0lBRUEsa0JBQWtCO0lBQ2xCYSxZQUFZWixRQUFRSTtJQUNwQlMsWUFBWWIsUUFBUUksU0FBUyxTQUFTQSxNQUFNYyxVQUFVLENBQUMsMEJBQTBCLFFBQVFkLE1BQU1jLFVBQVUsQ0FBQywwQkFBMEIsUUFBUSxDQUFDUixtQkFBbUJOLE1BQU1lLEtBQUssQ0FBQyxLQUFLQyxHQUFHLEVBQUMsS0FBTSxRQUFRLENBQUNWLG1CQUFtQkEsaUJBQWlCUyxLQUFLLENBQUMsSUFBRyxLQUFNLFFBQVEsQ0FBQ1QsbUJBQW1CQSxpQkFBaUJXLEtBQUssRUFBQyxLQUFNLE9BQU8sS0FBSyxJQUFJWCxpQkFBaUJZLFdBQVc7SUFDNVZYLFNBQVNDLFlBQVlqQixvREFBaUJBLEdBQUdrQixjQUFjLFFBQVFqQixvREFBVUEsR0FBR2lCLGNBQWMsUUFBUWhCLG1EQUFTQSxHQUFHO0lBQzlHLElBQUksQ0FBQ2MsUUFBUSxNQUFNLElBQUlHLE1BQU0sa0RBQWtEVjtJQUMvRSxNQUFNbUIsZUFBZS9CLHFEQUFTQSxDQUM5QixtQkFBbUI7SUFDbkJtQixRQUFRQyxZQUFZO1FBQUNSO0tBQU0sR0FBR0EsT0FBT08sQ0FBQUE7UUFDbkNBLE9BQU9hLE9BQU8sSUFBSSxRQUFRYixPQUFPYSxPQUFPLENBQUNuQjtRQUN6QyxJQUFJSSxZQUFZQSxXQUFXRTtJQUM3QjtJQUNBLE1BQU1jLFVBQVViLFlBQ2hCLGFBQWE7SUFDYlcsWUFBWSxDQUFDLEVBQUUsR0FBR0E7SUFDbEJFLFFBQVFDLE9BQU8sR0FBR2QsWUFBWW5CLHdEQUFxQkEsR0FBR0MsbUVBQWdDQTtJQUN0RixNQUFNaUMsZUFBZTtJQUNyQixNQUFNQyxpQkFBaUI7SUFDdkIsSUFBSSxnQkFBZ0JILFNBQVNBLFFBQVFJLFVBQVUsR0FBRyxDQUFDckIsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSUEsV0FBV0ksU0FBUSxJQUFLLFNBQVM7U0FBbUJhLFFBQVFqQixRQUFRLEdBQUcsQ0FBQ0EsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSUEsV0FBV0ksU0FBUSxJQUFLZSxlQUFlQztJQUN4UCxPQUFPSDtBQUNUO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcz83MGM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlVGV4dHVyZUxvYWRlciB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFJHQkVMb2FkZXIsIEVYUkxvYWRlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyBwcmVzZXRzT2JqIH0gZnJvbSAnLi4vaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMnO1xuXG5jb25zdCBDVUJFTUFQX1JPT1QgPSAnaHR0cHM6Ly9yYXcuZ2l0aGFjay5jb20vcG1uZHJzL2RyZWktYXNzZXRzLzQ1NjA2MGEyNmJiZWI4ZmRmNzkzMjZmMjI0YjZkOTliOGJjY2U3MzYvaGRyaS8nO1xuY29uc3QgaXNBcnJheSA9IGFyciA9PiBBcnJheS5pc0FycmF5KGFycik7XG5mdW5jdGlvbiB1c2VFbnZpcm9ubWVudCh7XG4gIGZpbGVzID0gWycvcHgucG5nJywgJy9ueC5wbmcnLCAnL3B5LnBuZycsICcvbnkucG5nJywgJy9wei5wbmcnLCAnL256LnBuZyddLFxuICBwYXRoID0gJycsXG4gIHByZXNldCA9IHVuZGVmaW5lZCxcbiAgZW5jb2RpbmcgPSB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnNcbn0gPSB7fSkge1xuICB2YXIgX2ZpbGVzJHNwbGl0JHBvcDtcbiAgbGV0IGxvYWRlciA9IG51bGw7XG4gIGxldCBpc0N1YmVNYXAgPSBmYWxzZTtcbiAgbGV0IGV4dGVuc2lvbjtcbiAgaWYgKHByZXNldCkge1xuICAgIGlmICghKHByZXNldCBpbiBwcmVzZXRzT2JqKSkgdGhyb3cgbmV3IEVycm9yKCdQcmVzZXQgbXVzdCBiZSBvbmUgb2Y6ICcgKyBPYmplY3Qua2V5cyhwcmVzZXRzT2JqKS5qb2luKCcsICcpKTtcbiAgICBmaWxlcyA9IHByZXNldHNPYmpbcHJlc2V0XTtcbiAgICBwYXRoID0gQ1VCRU1BUF9ST09UO1xuICB9XG5cbiAgLy8gRXZlcnl0aGluZyBlbHNlXG4gIGlzQ3ViZU1hcCA9IGlzQXJyYXkoZmlsZXMpO1xuICBleHRlbnNpb24gPSBpc0FycmF5KGZpbGVzKSA/ICdjdWJlJyA6IGZpbGVzLnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vZXhyJykgPyAnZXhyJyA6IGZpbGVzLnN0YXJ0c1dpdGgoJ2RhdGE6YXBwbGljYXRpb24vaGRyJykgPyAnaGRyJyA6IChfZmlsZXMkc3BsaXQkcG9wID0gZmlsZXMuc3BsaXQoJy4nKS5wb3AoKSkgPT0gbnVsbCB8fCAoX2ZpbGVzJHNwbGl0JHBvcCA9IF9maWxlcyRzcGxpdCRwb3Auc3BsaXQoJz8nKSkgPT0gbnVsbCB8fCAoX2ZpbGVzJHNwbGl0JHBvcCA9IF9maWxlcyRzcGxpdCRwb3Auc2hpZnQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9maWxlcyRzcGxpdCRwb3AudG9Mb3dlckNhc2UoKTtcbiAgbG9hZGVyID0gaXNDdWJlTWFwID8gQ3ViZVRleHR1cmVMb2FkZXIgOiBleHRlbnNpb24gPT09ICdoZHInID8gUkdCRUxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2V4cicgPyBFWFJMb2FkZXIgOiBudWxsO1xuICBpZiAoIWxvYWRlcikgdGhyb3cgbmV3IEVycm9yKCd1c2VFbnZpcm9ubWVudDogVW5yZWNvZ25pemVkIGZpbGUgZXh0ZW5zaW9uOiAnICsgZmlsZXMpO1xuICBjb25zdCBsb2FkZXJSZXN1bHQgPSB1c2VMb2FkZXIoXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgbG9hZGVyLCBpc0N1YmVNYXAgPyBbZmlsZXNdIDogZmlsZXMsIGxvYWRlciA9PiB7XG4gICAgbG9hZGVyLnNldFBhdGggPT0gbnVsbCB8fCBsb2FkZXIuc2V0UGF0aChwYXRoKTtcbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICB9KTtcbiAgY29uc3QgdGV4dHVyZSA9IGlzQ3ViZU1hcCA/XG4gIC8vIEB0cy1pZ25vcmVcbiAgbG9hZGVyUmVzdWx0WzBdIDogbG9hZGVyUmVzdWx0O1xuICB0ZXh0dXJlLm1hcHBpbmcgPSBpc0N1YmVNYXAgPyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcbiAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgY29uc3QgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xuICBpZiAoJ2NvbG9yU3BhY2UnIGluIHRleHR1cmUpIHRleHR1cmUuY29sb3JTcGFjZSA9IChlbmNvZGluZyAhPT0gbnVsbCAmJiBlbmNvZGluZyAhPT0gdm9pZCAwID8gZW5jb2RpbmcgOiBpc0N1YmVNYXApID8gJ3NyZ2InIDogJ3NyZ2ItbGluZWFyJztlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcgIT09IHZvaWQgMCA/IGVuY29kaW5nIDogaXNDdWJlTWFwKSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZXhwb3J0IHsgdXNlRW52aXJvbm1lbnQgfTtcbiJdLCJuYW1lcyI6WyJ1c2VMb2FkZXIiLCJDdWJlUmVmbGVjdGlvbk1hcHBpbmciLCJFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyIsIkN1YmVUZXh0dXJlTG9hZGVyIiwiUkdCRUxvYWRlciIsIkVYUkxvYWRlciIsInByZXNldHNPYmoiLCJDVUJFTUFQX1JPT1QiLCJpc0FycmF5IiwiYXJyIiwiQXJyYXkiLCJ1c2VFbnZpcm9ubWVudCIsImZpbGVzIiwicGF0aCIsInByZXNldCIsInVuZGVmaW5lZCIsImVuY29kaW5nIiwiZXh0ZW5zaW9ucyIsIl9maWxlcyRzcGxpdCRwb3AiLCJsb2FkZXIiLCJpc0N1YmVNYXAiLCJleHRlbnNpb24iLCJFcnJvciIsIk9iamVjdCIsImtleXMiLCJqb2luIiwic3RhcnRzV2l0aCIsInNwbGl0IiwicG9wIiwic2hpZnQiLCJ0b0xvd2VyQ2FzZSIsImxvYWRlclJlc3VsdCIsInNldFBhdGgiLCJ0ZXh0dXJlIiwibWFwcGluZyIsInNSR0JFbmNvZGluZyIsIkxpbmVhckVuY29kaW5nIiwiY29sb3JTcGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useFBO.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useFBO.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFBO: () => (/* binding */ useFBO)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n\n\n\n// 👇 uncomment when TS version supports function overloads\n// export function useFBO(settings?: FBOSettings)\nfunction useFBO(/** Width in pixels, or settings (will render fullscreen by default) */ width, /** Height in pixels */ height, /**Settings */ settings) {\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)((state)=>state.size);\n    const viewport = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)((state)=>state.viewport);\n    const _width = typeof width === \"number\" ? width : size.width * viewport.dpr;\n    const _height = typeof height === \"number\" ? height : size.height * viewport.dpr;\n    const _settings = (typeof width === \"number\" ? settings : width) || {};\n    const { samples = 0, depth, ...targetSettings } = _settings;\n    const target = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const target = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderTarget(_width, _height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n            type: three__WEBPACK_IMPORTED_MODULE_2__.HalfFloatType,\n            ...targetSettings\n        });\n        if (depth) {\n            target.depthTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DepthTexture(_width, _height, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        }\n        target.samples = samples;\n        return target;\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        target.setSize(_width, _height);\n        if (samples) target.samples = samples;\n    }, [\n        samples,\n        target,\n        _width,\n        _height\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>target.dispose();\n    }, []);\n    return target;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VGQk8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNlO0FBRTlDLDJEQUEyRDtBQUMzRCxpREFBaUQ7QUFDakQsU0FBU0csT0FBUSxxRUFBcUUsR0FDdEZDLEtBQUssRUFBRSxxQkFBcUIsR0FDNUJDLE1BQU0sRUFBRSxZQUFZLEdBQ3BCQyxRQUFRO0lBQ04sTUFBTUMsT0FBT0wscURBQVFBLENBQUNNLENBQUFBLFFBQVNBLE1BQU1ELElBQUk7SUFDekMsTUFBTUUsV0FBV1AscURBQVFBLENBQUNNLENBQUFBLFFBQVNBLE1BQU1DLFFBQVE7SUFDakQsTUFBTUMsU0FBUyxPQUFPTixVQUFVLFdBQVdBLFFBQVFHLEtBQUtILEtBQUssR0FBR0ssU0FBU0UsR0FBRztJQUM1RSxNQUFNQyxVQUFVLE9BQU9QLFdBQVcsV0FBV0EsU0FBU0UsS0FBS0YsTUFBTSxHQUFHSSxTQUFTRSxHQUFHO0lBQ2hGLE1BQU1FLFlBQVksQ0FBQyxPQUFPVCxVQUFVLFdBQVdFLFdBQVdGLEtBQUksS0FBTSxDQUFDO0lBQ3JFLE1BQU0sRUFDSlUsVUFBVSxDQUFDLEVBQ1hDLEtBQUssRUFDTCxHQUFHQyxnQkFDSixHQUFHSDtJQUNKLE1BQU1JLFNBQVNqQiwwQ0FBYSxDQUFDO1FBQzNCLE1BQU1pQixTQUFTLElBQUloQixvREFBdUIsQ0FBQ1MsUUFBUUUsU0FBUztZQUMxRFEsV0FBV25CLCtDQUFrQjtZQUM3QnFCLFdBQVdyQiwrQ0FBa0I7WUFDN0JzQixNQUFNdEIsZ0RBQW1CO1lBQ3pCLEdBQUdlLGNBQWM7UUFDbkI7UUFDQSxJQUFJRCxPQUFPO1lBQ1RFLE9BQU9RLFlBQVksR0FBRyxJQUFJeEIsK0NBQWtCLENBQUNTLFFBQVFFLFNBQVNYLDRDQUFlO1FBQy9FO1FBQ0FnQixPQUFPSCxPQUFPLEdBQUdBO1FBQ2pCLE9BQU9HO0lBQ1QsR0FBRyxFQUFFO0lBQ0xqQixrREFBcUIsQ0FBQztRQUNwQmlCLE9BQU9ZLE9BQU8sQ0FBQ25CLFFBQVFFO1FBQ3ZCLElBQUlFLFNBQVNHLE9BQU9ILE9BQU8sR0FBR0E7SUFDaEMsR0FBRztRQUFDQTtRQUFTRztRQUFRUDtRQUFRRTtLQUFRO0lBQ3JDWiw0Q0FBZSxDQUFDO1FBQ2QsT0FBTyxJQUFNaUIsT0FBT2MsT0FBTztJQUM3QixHQUFHLEVBQUU7SUFDTCxPQUFPZDtBQUNUO0FBRWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VGQk8uanM/ZjllNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbi8vIPCfkYcgdW5jb21tZW50IHdoZW4gVFMgdmVyc2lvbiBzdXBwb3J0cyBmdW5jdGlvbiBvdmVybG9hZHNcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VGQk8oc2V0dGluZ3M/OiBGQk9TZXR0aW5ncylcbmZ1bmN0aW9uIHVzZUZCTyggLyoqIFdpZHRoIGluIHBpeGVscywgb3Igc2V0dGluZ3MgKHdpbGwgcmVuZGVyIGZ1bGxzY3JlZW4gYnkgZGVmYXVsdCkgKi9cbndpZHRoLCAvKiogSGVpZ2h0IGluIHBpeGVscyAqL1xuaGVpZ2h0LCAvKipTZXR0aW5ncyAqL1xuc2V0dGluZ3MpIHtcbiAgY29uc3Qgc2l6ZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNpemUpO1xuICBjb25zdCB2aWV3cG9ydCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnZpZXdwb3J0KTtcbiAgY29uc3QgX3dpZHRoID0gdHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyA/IHdpZHRoIDogc2l6ZS53aWR0aCAqIHZpZXdwb3J0LmRwcjtcbiAgY29uc3QgX2hlaWdodCA9IHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInID8gaGVpZ2h0IDogc2l6ZS5oZWlnaHQgKiB2aWV3cG9ydC5kcHI7XG4gIGNvbnN0IF9zZXR0aW5ncyA9ICh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInID8gc2V0dGluZ3MgOiB3aWR0aCkgfHwge307XG4gIGNvbnN0IHtcbiAgICBzYW1wbGVzID0gMCxcbiAgICBkZXB0aCxcbiAgICAuLi50YXJnZXRTZXR0aW5nc1xuICB9ID0gX3NldHRpbmdzO1xuICBjb25zdCB0YXJnZXQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoX3dpZHRoLCBfaGVpZ2h0LCB7XG4gICAgICBtaW5GaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlcixcbiAgICAgIG1hZ0ZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxuICAgICAgdHlwZTogVEhSRUUuSGFsZkZsb2F0VHlwZSxcbiAgICAgIC4uLnRhcmdldFNldHRpbmdzXG4gICAgfSk7XG4gICAgaWYgKGRlcHRoKSB7XG4gICAgICB0YXJnZXQuZGVwdGhUZXh0dXJlID0gbmV3IFRIUkVFLkRlcHRoVGV4dHVyZShfd2lkdGgsIF9oZWlnaHQsIFRIUkVFLkZsb2F0VHlwZSk7XG4gICAgfVxuICAgIHRhcmdldC5zYW1wbGVzID0gc2FtcGxlcztcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdGFyZ2V0LnNldFNpemUoX3dpZHRoLCBfaGVpZ2h0KTtcbiAgICBpZiAoc2FtcGxlcykgdGFyZ2V0LnNhbXBsZXMgPSBzYW1wbGVzO1xuICB9LCBbc2FtcGxlcywgdGFyZ2V0LCBfd2lkdGgsIF9oZWlnaHRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LmRpc3Bvc2UoKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyB1c2VGQk8gfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlRIUkVFIiwidXNlVGhyZWUiLCJ1c2VGQk8iLCJ3aWR0aCIsImhlaWdodCIsInNldHRpbmdzIiwic2l6ZSIsInN0YXRlIiwidmlld3BvcnQiLCJfd2lkdGgiLCJkcHIiLCJfaGVpZ2h0IiwiX3NldHRpbmdzIiwic2FtcGxlcyIsImRlcHRoIiwidGFyZ2V0U2V0dGluZ3MiLCJ0YXJnZXQiLCJ1c2VNZW1vIiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJtaW5GaWx0ZXIiLCJMaW5lYXJGaWx0ZXIiLCJtYWdGaWx0ZXIiLCJ0eXBlIiwiSGFsZkZsb2F0VHlwZSIsImRlcHRoVGV4dHVyZSIsIkRlcHRoVGV4dHVyZSIsIkZsb2F0VHlwZSIsInVzZUxheW91dEVmZmVjdCIsInNldFNpemUiLCJ1c2VFZmZlY3QiLCJkaXNwb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useFBO.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useGLTF.js":
/*!********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useGLTF.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGLTF: () => (/* binding */ useGLTF)\n/* harmony export */ });\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/DRACOLoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/libs/MeshoptDecoder.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/GLTFLoader.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n\n\nlet dracoLoader = null;\nlet decoderPath = \"https://www.gstatic.com/draco/versioned/decoders/1.5.5/\";\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n    return (loader)=>{\n        if (extendLoader) {\n            extendLoader(loader);\n        }\n        if (useDraco) {\n            if (!dracoLoader) {\n                dracoLoader = new three_stdlib__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader();\n            }\n            dracoLoader.setDecoderPath(typeof useDraco === \"string\" ? useDraco : decoderPath);\n            loader.setDRACOLoader(dracoLoader);\n        }\n        if (useMeshopt) {\n            loader.setMeshoptDecoder(typeof three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder === \"function\" ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder)() : three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder);\n        }\n    };\n}\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n    return (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F)(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n}\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader)=>_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.preload(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\nuseGLTF.clear = (input)=>_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F.clear(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, input);\nuseGLTF.setDecoderPath = (path)=>{\n    decoderPath = path;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VHTFRGLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVFO0FBQ3hCO0FBRS9DLElBQUlJLGNBQWM7QUFDbEIsSUFBSUMsY0FBYztBQUNsQixTQUFTQyxXQUFXQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsWUFBWTtJQUNwRCxPQUFPQyxDQUFBQTtRQUNMLElBQUlELGNBQWM7WUFDaEJBLGFBQWFDO1FBQ2Y7UUFDQSxJQUFJSCxVQUFVO1lBQ1osSUFBSSxDQUFDSCxhQUFhO2dCQUNoQkEsY0FBYyxJQUFJSCxxREFBV0E7WUFDL0I7WUFDQUcsWUFBWU8sY0FBYyxDQUFDLE9BQU9KLGFBQWEsV0FBV0EsV0FBV0Y7WUFDckVLLE9BQU9FLGNBQWMsQ0FBQ1I7UUFDeEI7UUFDQSxJQUFJSSxZQUFZO1lBQ2RFLE9BQU9HLGlCQUFpQixDQUFDLE9BQU9YLHdEQUFjQSxLQUFLLGFBQWFBLDREQUFjQSxLQUFLQSx3REFBY0E7UUFDbkc7SUFDRjtBQUNGO0FBQ0EsU0FBU1ksUUFBUUMsSUFBSSxFQUFFUixXQUFXLElBQUksRUFBRVMsYUFBYSxJQUFJLEVBQUVQLFlBQVk7SUFDckUsT0FBT04scURBQVNBLENBQUNILG9EQUFVQSxFQUFFZSxNQUFNVCxXQUFXQyxVQUFVUyxZQUFZUDtBQUN0RTtBQUNBSyxRQUFRRyxPQUFPLEdBQUcsQ0FBQ0YsTUFBTVIsV0FBVyxJQUFJLEVBQUVTLGFBQWEsSUFBSSxFQUFFUCxlQUFpQk4saURBQVNBLENBQUNjLE9BQU8sQ0FBQ2pCLG9EQUFVQSxFQUFFZSxNQUFNVCxXQUFXQyxVQUFVUyxZQUFZUDtBQUNuSkssUUFBUUksS0FBSyxHQUFHQyxDQUFBQSxRQUFTaEIsaURBQVNBLENBQUNlLEtBQUssQ0FBQ2xCLG9EQUFVQSxFQUFFbUI7QUFDckRMLFFBQVFILGNBQWMsR0FBR0ksQ0FBQUE7SUFDdkJWLGNBQWNVO0FBQ2hCO0FBRW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VHTFRGLmpzPzExMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR0xURkxvYWRlciwgRFJBQ09Mb2FkZXIsIE1lc2hvcHREZWNvZGVyIH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbmxldCBkcmFjb0xvYWRlciA9IG51bGw7XG5sZXQgZGVjb2RlclBhdGggPSAnaHR0cHM6Ly93d3cuZ3N0YXRpYy5jb20vZHJhY28vdmVyc2lvbmVkL2RlY29kZXJzLzEuNS41Lyc7XG5mdW5jdGlvbiBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNob3B0LCBleHRlbmRMb2FkZXIpIHtcbiAgcmV0dXJuIGxvYWRlciA9PiB7XG4gICAgaWYgKGV4dGVuZExvYWRlcikge1xuICAgICAgZXh0ZW5kTG9hZGVyKGxvYWRlcik7XG4gICAgfVxuICAgIGlmICh1c2VEcmFjbykge1xuICAgICAgaWYgKCFkcmFjb0xvYWRlcikge1xuICAgICAgICBkcmFjb0xvYWRlciA9IG5ldyBEUkFDT0xvYWRlcigpO1xuICAgICAgfVxuICAgICAgZHJhY29Mb2FkZXIuc2V0RGVjb2RlclBhdGgodHlwZW9mIHVzZURyYWNvID09PSAnc3RyaW5nJyA/IHVzZURyYWNvIDogZGVjb2RlclBhdGgpO1xuICAgICAgbG9hZGVyLnNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKHVzZU1lc2hvcHQpIHtcbiAgICAgIGxvYWRlci5zZXRNZXNob3B0RGVjb2Rlcih0eXBlb2YgTWVzaG9wdERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBNZXNob3B0RGVjb2RlcigpIDogTWVzaG9wdERlY29kZXIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUdMVEYocGF0aCwgdXNlRHJhY28gPSB0cnVlLCB1c2VNZXNoT3B0ID0gdHJ1ZSwgZXh0ZW5kTG9hZGVyKSB7XG4gIHJldHVybiB1c2VMb2FkZXIoR0xURkxvYWRlciwgcGF0aCwgZXh0ZW5zaW9ucyh1c2VEcmFjbywgdXNlTWVzaE9wdCwgZXh0ZW5kTG9hZGVyKSk7XG59XG51c2VHTFRGLnByZWxvYWQgPSAocGF0aCwgdXNlRHJhY28gPSB0cnVlLCB1c2VNZXNoT3B0ID0gdHJ1ZSwgZXh0ZW5kTG9hZGVyKSA9PiB1c2VMb2FkZXIucHJlbG9hZChHTFRGTG9hZGVyLCBwYXRoLCBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNoT3B0LCBleHRlbmRMb2FkZXIpKTtcbnVzZUdMVEYuY2xlYXIgPSBpbnB1dCA9PiB1c2VMb2FkZXIuY2xlYXIoR0xURkxvYWRlciwgaW5wdXQpO1xudXNlR0xURi5zZXREZWNvZGVyUGF0aCA9IHBhdGggPT4ge1xuICBkZWNvZGVyUGF0aCA9IHBhdGg7XG59O1xuXG5leHBvcnQgeyB1c2VHTFRGIH07XG4iXSwibmFtZXMiOlsiR0xURkxvYWRlciIsIkRSQUNPTG9hZGVyIiwiTWVzaG9wdERlY29kZXIiLCJ1c2VMb2FkZXIiLCJkcmFjb0xvYWRlciIsImRlY29kZXJQYXRoIiwiZXh0ZW5zaW9ucyIsInVzZURyYWNvIiwidXNlTWVzaG9wdCIsImV4dGVuZExvYWRlciIsImxvYWRlciIsInNldERlY29kZXJQYXRoIiwic2V0RFJBQ09Mb2FkZXIiLCJzZXRNZXNob3B0RGVjb2RlciIsInVzZUdMVEYiLCJwYXRoIiwidXNlTWVzaE9wdCIsInByZWxvYWQiLCJjbGVhciIsImlucHV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useGLTF.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n    apartment: \"lebombo_1k.hdr\",\n    city: \"potsdamer_platz_1k.hdr\",\n    dawn: \"kiara_1_dawn_1k.hdr\",\n    forest: \"forest_slope_1k.hdr\",\n    lobby: \"st_fagans_interior_1k.hdr\",\n    night: \"dikhololo_night_1k.hdr\",\n    park: \"rooitou_park_1k.hdr\",\n    studio: \"studio_small_03_1k.hdr\",\n    sunset: \"venice_sunset_1k.hdr\",\n    warehouse: \"empty_warehouse_01_1k.hdr\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWE7SUFDakJDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFdBQVc7QUFDYjtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvZW52aXJvbm1lbnQtYXNzZXRzLmpzPzE2NTEiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJlc2V0c09iaiA9IHtcbiAgYXBhcnRtZW50OiAnbGVib21ib18xay5oZHInLFxuICBjaXR5OiAncG90c2RhbWVyX3BsYXR6XzFrLmhkcicsXG4gIGRhd246ICdraWFyYV8xX2Rhd25fMWsuaGRyJyxcbiAgZm9yZXN0OiAnZm9yZXN0X3Nsb3BlXzFrLmhkcicsXG4gIGxvYmJ5OiAnc3RfZmFnYW5zX2ludGVyaW9yXzFrLmhkcicsXG4gIG5pZ2h0OiAnZGlraG9sb2xvX25pZ2h0XzFrLmhkcicsXG4gIHBhcms6ICdyb29pdG91X3BhcmtfMWsuaGRyJyxcbiAgc3R1ZGlvOiAnc3R1ZGlvX3NtYWxsXzAzXzFrLmhkcicsXG4gIHN1bnNldDogJ3ZlbmljZV9zdW5zZXRfMWsuaGRyJyxcbiAgd2FyZWhvdXNlOiAnZW1wdHlfd2FyZWhvdXNlXzAxXzFrLmhkcidcbn07XG5cbmV4cG9ydCB7IHByZXNldHNPYmogfTtcbiJdLCJuYW1lcyI6WyJwcmVzZXRzT2JqIiwiYXBhcnRtZW50IiwiY2l0eSIsImRhd24iLCJmb3Jlc3QiLCJsb2JieSIsIm5pZ2h0IiwicGFyayIsInN0dWRpbyIsInN1bnNldCIsIndhcmVob3VzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/web/KeyboardControls.js":
/*!****************************************************************!*\
  !*** ./node_modules/@react-three/drei/web/KeyboardControls.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyboardControls: () => (/* binding */ KeyboardControls),\n/* harmony export */   useKeyboardControls: () => (/* binding */ useKeyboardControls)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zustand/middleware */ \"(ssr)/./node_modules/zustand/esm/middleware.js\");\n\n\n\n// These are removed in Zustand v4\n// unknown\n// Zustand v3 marked deprecations in 3.x, but there's no visible upgrade path\nconst context = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction KeyboardControls({ map, children, onChange, domElement }) {\n    const key = map.map((item)=>item.name + item.keys).join(\"-\");\n    const useControls = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return (0,zustand__WEBPACK_IMPORTED_MODULE_1__[\"default\"])((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_2__.subscribeWithSelector)(()=>map.reduce((prev, cur)=>({\n                    ...prev,\n                    [cur.name]: false\n                }), {})));\n    }, [\n        key\n    ]);\n    const api = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>[\n            useControls.subscribe,\n            useControls.getState,\n            useControls\n        ], [\n        key\n    ]);\n    const set = useControls.setState;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const config = map.map(({ name, keys, up })=>({\n                keys,\n                up,\n                fn: (value)=>{\n                    // Set zustand state\n                    set({\n                        [name]: value\n                    });\n                    // Inform callback\n                    if (onChange) onChange(name, value, api[1]());\n                }\n            }));\n        const keyMap = config.reduce((out, { keys, fn, up = true })=>{\n            keys.forEach((key)=>out[key] = {\n                    fn,\n                    pressed: false,\n                    up\n                });\n            return out;\n        }, {});\n        const downHandler = ({ key, code })=>{\n            const obj = keyMap[key] || keyMap[code];\n            if (!obj) return;\n            const { fn, pressed, up } = obj;\n            obj.pressed = true;\n            if (up || !pressed) fn(true);\n        };\n        const upHandler = ({ key, code })=>{\n            const obj = keyMap[key] || keyMap[code];\n            if (!obj) return;\n            const { fn, up } = obj;\n            obj.pressed = false;\n            if (up) fn(false);\n        };\n        const source = domElement || window;\n        source.addEventListener(\"keydown\", downHandler, {\n            passive: true\n        });\n        source.addEventListener(\"keyup\", upHandler, {\n            passive: true\n        });\n        return ()=>{\n            source.removeEventListener(\"keydown\", downHandler);\n            source.removeEventListener(\"keyup\", upHandler);\n        };\n    }, [\n        domElement,\n        key\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: api,\n        children: children\n    });\n}\nfunction useKeyboardControls(sel) {\n    const [sub, get, store] = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (sel) return store(sel);\n    else return [\n        sub,\n        get\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvd2ViL0tleWJvYXJkQ29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ0Y7QUFDOEI7QUFFM0Qsa0NBQWtDO0FBQ2xDLFVBQVU7QUFFViw2RUFBNkU7QUFFN0UsTUFBTUcsVUFBVSxhQUFhLGlCQUFFSCxnREFBbUIsQ0FBQztBQUNuRCxTQUFTSyxpQkFBaUIsRUFDeEJDLEdBQUcsRUFDSEMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLFVBQVUsRUFDWDtJQUNDLE1BQU1DLE1BQU1KLElBQUlBLEdBQUcsQ0FBQ0ssQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxHQUFHRCxLQUFLRSxJQUFJLEVBQUVDLElBQUksQ0FBQztJQUN4RCxNQUFNQyxjQUFjZiwwQ0FBYSxDQUFDO1FBQ2hDLE9BQU9DLG1EQUFNQSxDQUFDQyx5RUFBcUJBLENBQUMsSUFBTUksSUFBSVcsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE1BQVM7b0JBQ25FLEdBQUdELElBQUk7b0JBQ1AsQ0FBQ0MsSUFBSVAsSUFBSSxDQUFDLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDO0lBQ1AsR0FBRztRQUFDRjtLQUFJO0lBQ1IsTUFBTVUsTUFBTXBCLDBDQUFhLENBQUMsSUFBTTtZQUFDZSxZQUFZTSxTQUFTO1lBQUVOLFlBQVlPLFFBQVE7WUFBRVA7U0FBWSxFQUFFO1FBQUNMO0tBQUk7SUFDakcsTUFBTWEsTUFBTVIsWUFBWVMsUUFBUTtJQUNoQ3hCLDRDQUFlLENBQUM7UUFDZCxNQUFNMEIsU0FBU3BCLElBQUlBLEdBQUcsQ0FBQyxDQUFDLEVBQ3RCTSxJQUFJLEVBQ0pDLElBQUksRUFDSmMsRUFBRSxFQUNILEdBQU07Z0JBQ0xkO2dCQUNBYztnQkFDQUMsSUFBSUMsQ0FBQUE7b0JBQ0Ysb0JBQW9CO29CQUNwQk4sSUFBSTt3QkFDRixDQUFDWCxLQUFLLEVBQUVpQjtvQkFDVjtvQkFDQSxrQkFBa0I7b0JBQ2xCLElBQUlyQixVQUFVQSxTQUFTSSxNQUFNaUIsT0FBT1QsR0FBRyxDQUFDLEVBQUU7Z0JBQzVDO1lBQ0Y7UUFDQSxNQUFNVSxTQUFTSixPQUFPVCxNQUFNLENBQUMsQ0FBQ2MsS0FBSyxFQUNqQ2xCLElBQUksRUFDSmUsRUFBRSxFQUNGRCxLQUFLLElBQUksRUFDVjtZQUNDZCxLQUFLbUIsT0FBTyxDQUFDdEIsQ0FBQUEsTUFBT3FCLEdBQUcsQ0FBQ3JCLElBQUksR0FBRztvQkFDN0JrQjtvQkFDQUssU0FBUztvQkFDVE47Z0JBQ0Y7WUFDQSxPQUFPSTtRQUNULEdBQUcsQ0FBQztRQUNKLE1BQU1HLGNBQWMsQ0FBQyxFQUNuQnhCLEdBQUcsRUFDSHlCLElBQUksRUFDTDtZQUNDLE1BQU1DLE1BQU1OLE1BQU0sQ0FBQ3BCLElBQUksSUFBSW9CLE1BQU0sQ0FBQ0ssS0FBSztZQUN2QyxJQUFJLENBQUNDLEtBQUs7WUFDVixNQUFNLEVBQ0pSLEVBQUUsRUFDRkssT0FBTyxFQUNQTixFQUFFLEVBQ0gsR0FBR1M7WUFDSkEsSUFBSUgsT0FBTyxHQUFHO1lBQ2QsSUFBSU4sTUFBTSxDQUFDTSxTQUFTTCxHQUFHO1FBQ3pCO1FBQ0EsTUFBTVMsWUFBWSxDQUFDLEVBQ2pCM0IsR0FBRyxFQUNIeUIsSUFBSSxFQUNMO1lBQ0MsTUFBTUMsTUFBTU4sTUFBTSxDQUFDcEIsSUFBSSxJQUFJb0IsTUFBTSxDQUFDSyxLQUFLO1lBQ3ZDLElBQUksQ0FBQ0MsS0FBSztZQUNWLE1BQU0sRUFDSlIsRUFBRSxFQUNGRCxFQUFFLEVBQ0gsR0FBR1M7WUFDSkEsSUFBSUgsT0FBTyxHQUFHO1lBQ2QsSUFBSU4sSUFBSUMsR0FBRztRQUNiO1FBQ0EsTUFBTVUsU0FBUzdCLGNBQWM4QjtRQUM3QkQsT0FBT0UsZ0JBQWdCLENBQUMsV0FBV04sYUFBYTtZQUM5Q08sU0FBUztRQUNYO1FBQ0FILE9BQU9FLGdCQUFnQixDQUFDLFNBQVNILFdBQVc7WUFDMUNJLFNBQVM7UUFDWDtRQUNBLE9BQU87WUFDTEgsT0FBT0ksbUJBQW1CLENBQUMsV0FBV1I7WUFDdENJLE9BQU9JLG1CQUFtQixDQUFDLFNBQVNMO1FBQ3RDO0lBQ0YsR0FBRztRQUFDNUI7UUFBWUM7S0FBSTtJQUNwQixPQUFPLFdBQVcsR0FBRVYsZ0RBQW1CLENBQUNHLFFBQVF5QyxRQUFRLEVBQUU7UUFDeERmLE9BQU9UO1FBQ1BiLFVBQVVBO0lBQ1o7QUFDRjtBQUNBLFNBQVNzQyxvQkFBb0JDLEdBQUc7SUFDOUIsTUFBTSxDQUFDQyxLQUFLQyxLQUFLQyxNQUFNLEdBQUdqRCw2Q0FBZ0IsQ0FBQ0c7SUFDM0MsSUFBSTJDLEtBQUssT0FBT0csTUFBTUg7U0FBVSxPQUFPO1FBQUNDO1FBQUtDO0tBQUk7QUFDbkQ7QUFFaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS93ZWIvS2V5Ym9hcmRDb250cm9scy5qcz80ZmJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjcmVhdGUgZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBzdWJzY3JpYmVXaXRoU2VsZWN0b3IgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xuXG4vLyBUaGVzZSBhcmUgcmVtb3ZlZCBpbiBadXN0YW5kIHY0XG4vLyB1bmtub3duXG5cbi8vIFp1c3RhbmQgdjMgbWFya2VkIGRlcHJlY2F0aW9ucyBpbiAzLngsIGJ1dCB0aGVyZSdzIG5vIHZpc2libGUgdXBncmFkZSBwYXRoXG5cbmNvbnN0IGNvbnRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gS2V5Ym9hcmRDb250cm9scyh7XG4gIG1hcCxcbiAgY2hpbGRyZW4sXG4gIG9uQ2hhbmdlLFxuICBkb21FbGVtZW50XG59KSB7XG4gIGNvbnN0IGtleSA9IG1hcC5tYXAoaXRlbSA9PiBpdGVtLm5hbWUgKyBpdGVtLmtleXMpLmpvaW4oJy0nKTtcbiAgY29uc3QgdXNlQ29udHJvbHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlKHN1YnNjcmliZVdpdGhTZWxlY3RvcigoKSA9PiBtYXAucmVkdWNlKChwcmV2LCBjdXIpID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW2N1ci5uYW1lXTogZmFsc2VcbiAgICB9KSwge30pKSk7XG4gIH0sIFtrZXldKTtcbiAgY29uc3QgYXBpID0gUmVhY3QudXNlTWVtbygoKSA9PiBbdXNlQ29udHJvbHMuc3Vic2NyaWJlLCB1c2VDb250cm9scy5nZXRTdGF0ZSwgdXNlQ29udHJvbHNdLCBba2V5XSk7XG4gIGNvbnN0IHNldCA9IHVzZUNvbnRyb2xzLnNldFN0YXRlO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IG1hcC5tYXAoKHtcbiAgICAgIG5hbWUsXG4gICAgICBrZXlzLFxuICAgICAgdXBcbiAgICB9KSA9PiAoe1xuICAgICAga2V5cyxcbiAgICAgIHVwLFxuICAgICAgZm46IHZhbHVlID0+IHtcbiAgICAgICAgLy8gU2V0IHp1c3RhbmQgc3RhdGVcbiAgICAgICAgc2V0KHtcbiAgICAgICAgICBbbmFtZV06IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbmZvcm0gY2FsbGJhY2tcbiAgICAgICAgaWYgKG9uQ2hhbmdlKSBvbkNoYW5nZShuYW1lLCB2YWx1ZSwgYXBpWzFdKCkpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBrZXlNYXAgPSBjb25maWcucmVkdWNlKChvdXQsIHtcbiAgICAgIGtleXMsXG4gICAgICBmbixcbiAgICAgIHVwID0gdHJ1ZVxuICAgIH0pID0+IHtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gb3V0W2tleV0gPSB7XG4gICAgICAgIGZuLFxuICAgICAgICBwcmVzc2VkOiBmYWxzZSxcbiAgICAgICAgdXBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgZG93bkhhbmRsZXIgPSAoe1xuICAgICAga2V5LFxuICAgICAgY29kZVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG9iaiA9IGtleU1hcFtrZXldIHx8IGtleU1hcFtjb2RlXTtcbiAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZuLFxuICAgICAgICBwcmVzc2VkLFxuICAgICAgICB1cFxuICAgICAgfSA9IG9iajtcbiAgICAgIG9iai5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgIGlmICh1cCB8fCAhcHJlc3NlZCkgZm4odHJ1ZSk7XG4gICAgfTtcbiAgICBjb25zdCB1cEhhbmRsZXIgPSAoe1xuICAgICAga2V5LFxuICAgICAgY29kZVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG9iaiA9IGtleU1hcFtrZXldIHx8IGtleU1hcFtjb2RlXTtcbiAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZuLFxuICAgICAgICB1cFxuICAgICAgfSA9IG9iajtcbiAgICAgIG9iai5wcmVzc2VkID0gZmFsc2U7XG4gICAgICBpZiAodXApIGZuKGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHNvdXJjZSA9IGRvbUVsZW1lbnQgfHwgd2luZG93O1xuICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cEhhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtkb21FbGVtZW50LCBrZXldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogYXBpLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZUtleWJvYXJkQ29udHJvbHMoc2VsKSB7XG4gIGNvbnN0IFtzdWIsIGdldCwgc3RvcmVdID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKHNlbCkgcmV0dXJuIHN0b3JlKHNlbCk7ZWxzZSByZXR1cm4gW3N1YiwgZ2V0XTtcbn1cblxuZXhwb3J0IHsgS2V5Ym9hcmRDb250cm9scywgdXNlS2V5Ym9hcmRDb250cm9scyB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlIiwic3Vic2NyaWJlV2l0aFNlbGVjdG9yIiwiY29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJLZXlib2FyZENvbnRyb2xzIiwibWFwIiwiY2hpbGRyZW4iLCJvbkNoYW5nZSIsImRvbUVsZW1lbnQiLCJrZXkiLCJpdGVtIiwibmFtZSIsImtleXMiLCJqb2luIiwidXNlQ29udHJvbHMiLCJ1c2VNZW1vIiwicmVkdWNlIiwicHJldiIsImN1ciIsImFwaSIsInN1YnNjcmliZSIsImdldFN0YXRlIiwic2V0Iiwic2V0U3RhdGUiLCJ1c2VFZmZlY3QiLCJjb25maWciLCJ1cCIsImZuIiwidmFsdWUiLCJrZXlNYXAiLCJvdXQiLCJmb3JFYWNoIiwicHJlc3NlZCIsImRvd25IYW5kbGVyIiwiY29kZSIsIm9iaiIsInVwSGFuZGxlciIsInNvdXJjZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInVzZUtleWJvYXJkQ29udHJvbHMiLCJzZWwiLCJzdWIiLCJnZXQiLCJzdG9yZSIsInVzZUNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/web/KeyboardControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useThree),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useFrame),\n/* harmony export */   D: () => (/* binding */ useGraph),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ buildGraph),\n/* harmony export */   x: () => (/* binding */ roots),\n/* harmony export */   y: () => (/* binding */ useInstanceHandle),\n/* harmony export */   z: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // @ts-ignore\n                // Remove interactivity on the initial root\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(findInitialRoot(child), child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers on the initial root\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = findInitialRoot(newInstance).getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, warn on undefined behavior\n    const handleTextInstance = ()=>console.warn(\"Text is not allowed in the R3F tree! This could be stray whitespace or characters.\");\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container on the initial root\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                findInitialRoot(instance).getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-ignore\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\n * The current THREE.ColorManagement instance, if present.\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\n * Returns instance root state\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n/**\n * Returns the instances initial (outmost) root\n */ function findInitialRoot(child) {\n    let root = child.__r3f.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\n * Collects nodes and materials from a THREE.Object3D.\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    var _instance$__r3f;\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f2;\n        // Bail out on primitive object\n        if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f3, _root$getState, _instance$__r3f4;\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-ignore\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_4__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Get the initial root state's internals\n        const internal = findInitialRoot(instance).getState().internal;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = internal.interaction.indexOf(instance);\n        if (index > -1) internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_4__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_4__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState()), frames);\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        /**\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n     */ invalidate,\n        /**\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n     */ advance\n    };\n}\n/**\n * Exposes an object's {@link LocalState}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`)))))).finally(()=>loader.dispose == null ? void 0 : loader.dispose());\n    };\n}\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\n * Preloads an asset into cache as a side-effect.\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\n * Removes a loaded asset from cache.\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) applyProps(camera, cameraOptions);\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_4__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_4__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_4__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            // Set color space and tonemapping preferences\n            const LinearEncoding = 3000;\n            const sRGBEncoding = 3001;\n            applyProps(gl, {\n                outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_4__.ACESFilmicToneMapping\n            });\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: store\n    }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portal, {\n        key: container.uuid,\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, reconciler.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: usePortalStore\n    }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtMjliNzEyMWIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDYTtBQUNtQztBQUNyQjtBQUV4RCxJQUFJYSxhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBU0MsQ0FBQUEsVUFBVyxLQUFLTCxPQUFPTSxNQUFNLENBQUNILFdBQVdFO0FBQ3hELFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsaUJBQWlCO0lBQy9DLFNBQVNDLGVBQWVDLElBQUksRUFBRSxFQUM1QkMsT0FBTyxFQUFFLEVBQ1RDLE1BQU0sRUFDTixHQUFHQyxPQUNKLEVBQUVDLElBQUk7UUFDTCxJQUFJQyxPQUFPLENBQUMsRUFBRUwsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckQsSUFBSUM7UUFDSixJQUFJUixTQUFTLGFBQWE7WUFDeEIsSUFBSUcsTUFBTU0sTUFBTSxLQUFLQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtZQUNoRCxNQUFNRixTQUFTTixNQUFNTSxNQUFNO1lBQzNCRCxXQUFXSSxRQUFRSCxRQUFRO2dCQUN6QlQ7Z0JBQ0FJO2dCQUNBRjtnQkFDQVcsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE1BQU1DLFNBQVN0QixTQUFTLENBQUNhLEtBQUs7WUFDOUIsSUFBSSxDQUFDUyxRQUFRO2dCQUNYLE1BQU0sSUFBSUgsTUFBTSxDQUFDLEtBQUssRUFBRU4sS0FBSyw0SkFBNEosQ0FBQztZQUM1TDtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNVLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBTyxNQUFNLElBQUlVLE1B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QUFRLENBQUNMLENBQUFBLGNBQWVGLE9BQU96WSxhQUFhakksUUFBUSxJQUFJNGdCO0lBQ3ZFLHVEQUF1RDtJQUN6RCxHQUFHO1FBQUNGO0tBQU87SUFDWCxPQUFPLFdBQVcsR0FBRTVtQixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNNEcsV0FBVzRmLFlBQVksQ0FBRSxXQUFXLEdBQUV4bUIsZ0RBQW1CLENBQUN3YSxRQUFRcUwsUUFBUSxFQUFFO1FBQ3hJbGQsT0FBT29lO0lBQ1QsR0FBRy9pQixXQUFXK2lCLGdCQUFnQjtBQUNoQztBQUNBbmdCLFdBQVcwZ0Isa0JBQWtCLENBQUM7SUFDNUJDLFlBQVl0VyxNQUF5QixHQUFlLENBQUMsR0FBRztJQUN4RHVXLHFCQUFxQjtJQUNyQkMsU0FBU3puQiwwQ0FBYTtBQUN4QjtBQUNBLE1BQU0wbkIsTUFBTTFuQiwrQ0FBa0I7QUFFdWhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtMjliNzEyMWIuZXNtLmpzP2JjYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IGV4dGVuZCA9IG9iamVjdHMgPT4gdm9pZCBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihfcm9vdHMsIF9nZXRFdmVudFByaW9yaXR5KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHtcbiAgICBhcmdzID0gW10sXG4gICAgYXR0YWNoLFxuICAgIC4uLnByb3BzXG4gIH0sIHJvb3QpIHtcbiAgICBsZXQgbmFtZSA9IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICBpZiAocHJvcHMub2JqZWN0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHByb3BzLm9iamVjdDtcbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShvYmplY3QsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgIC8vIEluc3RhbmNpYXRlIG5ldyBvYmplY3QsIGxpbmsgaXQgdG8gdGhlIHJvb3RcbiAgICAgIC8vIEFwcGVuZCBtZW1vaXplZCBwcm9wcyB3aXRoIGFyZ3Mgc28gaXQncyBub3QgZm9yZ290dGVuXG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUobmV3IHRhcmdldCguLi5hcmdzKSwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIC8vIFNhdmUgYXJncyBpbiBjYXNlIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgbGF0ZXIgZm9yIEhNUlxuICAgICAgICBtZW1vaXplZFByb3BzOiB7XG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICBpZiAoaW5zdGFuY2UuX19yM2YuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gICAgfVxuXG4gICAgLy8gSXQgc2hvdWxkIE5PVCBjYWxsIG9uVXBkYXRlIG9uIG9iamVjdCBpbnN0YW5jaWF0aW9uLCBiZWNhdXNlIGl0IGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZVxuICAgIC8vIHZpZXcgeWV0LiBJZiB0aGUgY2FsbGJhY2sgcmVsaWVzIG9uIHJlZmVyZW5jZXMgZm9yIGluc3RhbmNlLCB0aGV5IHdvbid0IGJlIHJlYWR5IHlldCwgdGhpcyBpc1xuICAgIC8vIHdoeSBpdCBwYXNzZXMgXCJ0cnVlXCIgaGVyZVxuICAgIC8vIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBhcHBseSBwcm9wcyB0byBpbmplY3RzXG4gICAgaWYgKG5hbWUgIT09ICdpbmplY3QnKSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIHByb3BzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmLCBfcGFyZW50SW5zdGFuY2UkX19yM2Y7XG4gICAgICAvLyBUaGUgYXR0YWNoIGF0dHJpYnV0ZSBpbXBsaWVzIHRoYXQgdGhlIG9iamVjdCBhdHRhY2hlcyBpdHNlbGYgb24gdGhlIHBhcmVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICAvLyBhZGQgaW4gdGhlIHVzdWFsIHBhcmVudC1jaGlsZCB3YXlcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuYWRkKGNoaWxkKTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBmb3IgYW55dGhpbmcgdGhhdCB1c2VkIGF0dGFjaCwgYW5kIGZvciBub24tT2JqZWN0M0RzIHRoYXQgZG9uJ3QgZ2V0IGF0dGFjaGVkIHRvIHByb3BzO1xuICAgICAgLy8gdGhhdCBpcywgYW55dGhpbmcgdGhhdCdzIGEgY2hpbGQgaW4gUmVhY3QgYnV0IG5vdCBhIGNoaWxkIGluIHRoZSBzY2VuZWdyYXBoLlxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmLm9iamVjdHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLl9fcjNmKSBwcmVwYXJlKGNoaWxkLCB7fSk7XG4gICAgICBjaGlsZC5fX3IzZi5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmMiwgX3BhcmVudEluc3RhbmNlJF9fcjNmMjtcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjIuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIFJlbW92ZSBpbnRlcmFjdGl2aXR5IG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9ICFpc1ByaW1pdGl2ZSAmJiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCA6IGRpc3Bvc2UpO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhc3luYyBhdCBydW50aW1lLCBmbHVzaCBzeW5jIGluIHRlc3RpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgaW5zdGFuY2UuX19yM2Yucm9vdCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xMzQ4XG4gICAgLy8gV2hlbiBhcmdzIGNoYW5nZSB0aGUgaW5zdGFuY2UgaGFzIHRvIGJlIHJlLWNvbnN0cnVjdGVkLCB3aGljaCB0aGVuXG4gICAgLy8gZm9yY2VzIHIzZiB0byByZS1wYXJlbnQgdGhlIGNoaWxkcmVuIGFuZCBub24tc2NlbmUgb2JqZWN0c1xuICAgIGlmIChpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuX19yM2YpIGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5jaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuX19yM2YpO1xuICAgIH1cbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzLmZvckVhY2goY2hpbGQgPT4gYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKSk7XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IFtdO1xuICAgIGlmICghaW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQpIHtcbiAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAobmV3SW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBuZXdJbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCA9IHRydWU7XG4gICAgfVxuICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbmV3SW5zdGFuY2UpO1xuXG4gICAgLy8gUmUtYmluZCBldmVudCBoYW5kbGVycyBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gZmluZEluaXRpYWxSb290KG5ld0luc3RhbmNlKS5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgd2FybiBvbiB1bmRlZmluZWQgYmVoYXZpb3JcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4gY29uc29sZS53YXJuKCdUZXh0IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBSM0YgdHJlZSEgVGhpcyBjb3VsZCBiZSBzdHJheSB3aGl0ZXNwYWNlIG9yIGNoYXJhY3RlcnMuJyk7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKHtcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGluc2VydEJlZm9yZSxcbiAgICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICAgIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gICAgbm9UaW1lb3V0OiAtMSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcblxuICAgICAgLy8gTGluayBjdXJyZW50IHJvb3QgdG8gdGhlIGRlZmF1bHQgc2NlbmVcbiAgICAgIHNjZW5lLl9fcjNmLnJvb3QgPSBjb250YWluZXI7XG4gICAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuICAgICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBudWxsLFxuICAgIGdldENoaWxkSG9zdENvbnRleHQ6IHBhcmVudEhvc3RDb250ZXh0ID0+IHBhcmVudEhvc3RDb250ZXh0LFxuICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjIgOiB7fTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgdHJpZ2dlciBjb21taXRNb3VudFxuICAgICAgcmV0dXJuIEJvb2xlYW4obG9jYWxTdGF0ZS5oYW5kbGVycyk7XG4gICAgfSxcbiAgICBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCBfdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMztcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcblxuICAgICAgLy8gQ3JlYXRlIGRpZmYtc2V0c1xuICAgICAgaWYgKGxvY2FsU3RhdGUucHJpbWl0aXZlICYmIG5ld1Byb3BzLm9iamVjdCAmJiBuZXdQcm9wcy5vYmplY3QgIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NOZXcgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY04sXG4gICAgICAgICAgLi4ucmVzdE5ld1xuICAgICAgICB9ID0gbmV3UHJvcHM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzT2xkID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNPLFxuICAgICAgICAgIC4uLnJlc3RPbGRcbiAgICAgICAgfSA9IG9sZFByb3BzO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3NOZXcpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogdGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAgIC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbnRpYXRlZFxuICAgICAgICBpZiAoYXJnc05ldy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICE9PSBhcmdzT2xkW2luZGV4XSkpIHJldHVybiBbdHJ1ZV07XG4gICAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZlByb3BzKGluc3RhbmNlLCByZXN0TmV3LCByZXN0T2xkLCB0cnVlKTtcbiAgICAgICAgaWYgKGRpZmYuY2hhbmdlcy5sZW5ndGgpIHJldHVybiBbZmFsc2UsIGRpZmZdO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3QgdG91Y2ggdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCBbcmVjb25zdHJ1Y3QsIGRpZmZdLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgICAgaWYgKHJlY29uc3RydWN0KSBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG92ZXJ3cml0ZSBwcm9wc1xuICAgICAgZWxzZSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRpZmYpO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIF90eXBlLCBfcHJvcHMsIF9pbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y0O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYXJlIG9ubHkgYWRkZWQgb25jZSB0byB0aGUgY2VudHJhbCBjb250YWluZXIgb24gdGhlIGluaXRpYWwgcm9vdFxuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y0IDoge307XG4gICAgICBpZiAoaW5zdGFuY2UucmF5Y2FzdCAmJiBsb2NhbFN0YXRlLmhhbmRsZXJzICYmIGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgICAgICBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWwuaW50ZXJhY3Rpb24ucHVzaChpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQdWJsaWNJbnN0YW5jZTogaW5zdGFuY2UgPT4gaW5zdGFuY2UsXG4gICAgcHJlcGFyZUZvckNvbW1pdDogKCkgPT4gbnVsbCxcbiAgICBwcmVwYXJlUG9ydGFsTW91bnQ6IGNvbnRhaW5lciA9PiBwcmVwYXJlKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lKSxcbiAgICByZXNldEFmdGVyQ29tbWl0OiAoKSA9PiB7fSxcbiAgICBzaG91bGRTZXRUZXh0Q29udGVudDogKCkgPT4gZmFsc2UsXG4gICAgY2xlYXJDb250YWluZXI6ICgpID0+IGZhbHNlLFxuICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjU7XG4gICAgICAvLyBEZXRhY2ggd2hpbGUgdGhlIGluc3RhbmNlIGlzIGhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y1IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGRldGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEKSBpbnN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNjtcbiAgICAgIC8vIFJlLWF0dGFjaCB3aGVuIHRoZSBpbnN0YW5jZSBpcyB1bmhpZGRlblxuICAgICAgY29uc3Qge1xuICAgICAgICBhdHRhY2g6IHR5cGUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IChfaW5zdGFuY2UkX19yM2Y2ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2Y2IDoge307XG4gICAgICBpZiAodHlwZSAmJiBwYXJlbnQpIGF0dGFjaChwYXJlbnQsIGluc3RhbmNlLCB0eXBlKTtcbiAgICAgIGlmIChpbnN0YW5jZS5pc09iamVjdDNEICYmIHByb3BzLnZpc2libGUgPT0gbnVsbCB8fCBwcm9wcy52aXNpYmxlKSBpbnN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICBjcmVhdGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICBoaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgdW5oaWRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTE2MzU2ODc0XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGdldEN1cnJlbnRFdmVudFByaW9yaXR5OiAoKSA9PiBfZ2V0RXZlbnRQcmlvcml0eSA/IF9nZXRFdmVudFByaW9yaXR5KCkgOiBEZWZhdWx0RXZlbnRQcmlvcml0eSxcbiAgICBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2U6ICgpID0+IHt9LFxuICAgIG5vdzogdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBpcy5mdW4ocGVyZm9ybWFuY2Uubm93KSA/IHBlcmZvcm1hbmNlLm5vdyA6IGlzLmZ1bihEYXRlLm5vdykgPyBEYXRlLm5vdyA6ICgpID0+IDAsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIzNjAjZGlzY3Vzc2lvbl9yOTIwODgzNTAzXG4gICAgc2NoZWR1bGVUaW1lb3V0OiBpcy5mdW4oc2V0VGltZW91dCkgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkLFxuICAgIGNhbmNlbFRpbWVvdXQ6IGlzLmZ1bihjbGVhclRpbWVvdXQpID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHJlY29uY2lsZXIsXG4gICAgYXBwbHlQcm9wczogYXBwbHlQcm9wcyQxXG4gIH07XG59XG5cbnZhciBfd2luZG93JGRvY3VtZW50LCBfd2luZG93JG5hdmlnYXRvcjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgd2l0aCBjb3JyZWN0IFRTIHR5cGUgaW5mZXJlbmNlIGlmIGFuIG9iamVjdCBoYXMgYSBjb25maWd1cmFibGUgY29sb3Igc3BhY2UgKHNpbmNlIHIxNTIpLlxuICovXG5jb25zdCBoYXNDb2xvclNwYWNlID0gb2JqZWN0ID0+ICdjb2xvclNwYWNlJyBpbiBvYmplY3QgfHwgJ291dHB1dENvbG9yU3BhY2UnIGluIG9iamVjdDtcbi8qKlxuICogVGhlIGN1cnJlbnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IGluc3RhbmNlLCBpZiBwcmVzZW50LlxuICovXG5jb25zdCBnZXRDb2xvck1hbmFnZW1lbnQgPSAoKSA9PiB7XG4gIHZhciBfQ29sb3JNYW5hZ2VtZW50O1xuICByZXR1cm4gKF9Db2xvck1hbmFnZW1lbnQgPSBjYXRhbG9ndWUuQ29sb3JNYW5hZ2VtZW50KSAhPSBudWxsID8gX0NvbG9yTWFuYWdlbWVudCA6IG51bGw7XG59O1xuY29uc3QgaXNPcnRob2dyYXBoaWNDYW1lcmEgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzUmVmID0gb2JqID0+IG9iaiAmJiBvYmouaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKTtcblxuLyoqXG4gKiBBbiBTU1ItZnJpZW5kbHkgdXNlTGF5b3V0RWZmZWN0LlxuICpcbiAqIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4gKiBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuICogdXNlTGF5b3V0RWZmZWN0IGVsc2V3aGVyZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQ5MjdcbiAqL1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX3dpbmRvdyRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCkgIT0gbnVsbCAmJiBfd2luZG93JGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgfHwgKChfd2luZG93JG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JG5hdmlnYXRvci5wcm9kdWN0KSA9PT0gJ1JlYWN0TmF0aXZlJykgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VNdXRhYmxlQ2FsbGJhY2soZm4pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKGZuKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB2b2lkIChyZWYuY3VycmVudCA9IGZuKSwgW2ZuXSk7XG4gIHJldHVybiByZWY7XG59XG5mdW5jdGlvbiBCbG9jayh7XG4gIHNldFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXQobmV3IFByb21pc2UoKCkgPT4gbnVsbCkpO1xuICAgIHJldHVybiAoKSA9PiBzZXQoZmFsc2UpO1xuICB9LCBbc2V0XSk7XG4gIHJldHVybiBudWxsO1xufVxuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb21wb25lbnREaWRDYXRjaChlcnIpIHtcbiAgICB0aGlzLnByb3BzLnNldChlcnIpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvciA/IG51bGwgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5FcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9ICgpID0+ICh7XG4gIGVycm9yOiB0cnVlXG59KTtcbmNvbnN0IERFRkFVTFQgPSAnX19kZWZhdWx0JztcbmNvbnN0IERFRkFVTFRTID0gbmV3IE1hcCgpO1xuY29uc3QgaXNEaWZmU2V0ID0gZGVmID0+IGRlZiAmJiAhIWRlZi5tZW1vaXplZCAmJiAhIWRlZi5jaGFuZ2VzO1xuZnVuY3Rpb24gY2FsY3VsYXRlRHByKGRwcikge1xuICB2YXIgX3dpbmRvdyRkZXZpY2VQaXhlbFJhO1xuICAvLyBFcnIgb24gdGhlIHNpZGUgb2YgcHJvZ3Jlc3MgYnkgYXNzdW1pbmcgMnggZHByIGlmIHdlIGNhbid0IGRldGVjdCBpdFxuICAvLyBUaGlzIHdpbGwgaGFwcGVuIGluIHdvcmtlcnMgd2hlcmUgd2luZG93IGlzIGRlZmluZWQgYnV0IGRwciBpc24ndC5cbiAgY29uc3QgdGFyZ2V0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoX3dpbmRvdyRkZXZpY2VQaXhlbFJhID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8pICE9IG51bGwgPyBfd2luZG93JGRldmljZVBpeGVsUmEgOiAyIDogMTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZHByKSA/IE1hdGgubWluKE1hdGgubWF4KGRwclswXSwgdGFyZ2V0KSwgZHByWzFdKSA6IGRwcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGluc3RhbmNlIHJvb3Qgc3RhdGVcbiAqL1xuY29uc3QgZ2V0Um9vdFN0YXRlID0gb2JqID0+IHtcbiAgdmFyIF9yM2Y7XG4gIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2Yucm9vdC5nZXRTdGF0ZSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW5jZXMgaW5pdGlhbCAob3V0bW9zdCkgcm9vdFxuICovXG5mdW5jdGlvbiBmaW5kSW5pdGlhbFJvb3QoY2hpbGQpIHtcbiAgbGV0IHJvb3QgPSBjaGlsZC5fX3IzZi5yb290O1xuICB3aGlsZSAocm9vdC5nZXRTdGF0ZSgpLnByZXZpb3VzUm9vdCkgcm9vdCA9IHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3Q7XG4gIHJldHVybiByb290O1xufVxuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbXBhcmUgZnVuY3Rpb25zXG5jb25zdCBpcyA9IHtcbiAgb2JqOiBhID0+IGEgPT09IE9iamVjdChhKSAmJiAhaXMuYXJyKGEpICYmIHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nLFxuICBmdW46IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbicsXG4gIHN0cjogYSA9PiB0eXBlb2YgYSA9PT0gJ3N0cmluZycsXG4gIG51bTogYSA9PiB0eXBlb2YgYSA9PT0gJ251bWJlcicsXG4gIGJvbzogYSA9PiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nLFxuICB1bmQ6IGEgPT4gYSA9PT0gdm9pZCAwLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb2xsZWN0cyBub2RlcyBhbmQgbWF0ZXJpYWxzIGZyb20gYSBUSFJFRS5PYmplY3QzRC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRHcmFwaChvYmplY3QpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBub2Rlczoge30sXG4gICAgbWF0ZXJpYWxzOiB7fVxuICB9O1xuICBpZiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKG9iaiA9PiB7XG4gICAgICBpZiAob2JqLm5hbWUpIGRhdGEubm9kZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiAhZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdKSBkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0gPSBvYmoubWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLmRpc3Bvc2UgJiYgb2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBwLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSBvYmpbcF07XG4gIH1cbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUob2JqZWN0LCBzdGF0ZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdDtcbiAgaW5zdGFuY2UuX19yM2YgPSB7XG4gICAgdHlwZTogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwcmV2aW91c0F0dGFjaDogbnVsbCxcbiAgICBtZW1vaXplZFByb3BzOiB7fSxcbiAgICBldmVudENvdW50OiAwLFxuICAgIGhhbmRsZXJzOiB7fSxcbiAgICBvYmplY3RzOiBbXSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgLi4uc3RhdGVcbiAgfTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5zdGFuY2UsIGtleSkge1xuICBsZXQgdGFyZ2V0ID0gaW5zdGFuY2U7XG4gIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBsYXN0ID0gZW50cmllcy5wb3AoKTtcbiAgICB0YXJnZXQgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleTogbGFzdFxuICAgIH07XG4gIH0gZWxzZSByZXR1cm4ge1xuICAgIHRhcmdldCxcbiAgICBrZXlcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgLy8gSWYgYXR0YWNoaW5nIGludG8gYW4gYXJyYXkgKGZvby0wKSwgY3JlYXRlIG9uZVxuICAgIGlmIChJTkRFWF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgICBjb25zdCByb290ID0gdHlwZS5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAga2V5XG4gICAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHJvb3QpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSkgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHRhcmdldFtrZXldO1xuICAgIHRhcmdldFtrZXldID0gY2hpbGQ7XG4gIH0gZWxzZSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHR5cGUocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICB2YXIgX2NoaWxkJF9fcjNmLCBfY2hpbGQkX19yM2YyO1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIC8vIE90aGVyd2lzZSBzZXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgZWxzZSB0YXJnZXRba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2UgKF9jaGlsZCRfX3IzZiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIChfY2hpbGQkX19yM2YyID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9jaGlsZCRfX3IzZjIucHJldmlvdXNBdHRhY2g7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcHJlcGFyZXMgYSBzZXQgb2YgY2hhbmdlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gZGlmZlByb3BzKGluc3RhbmNlLCB7XG4gIGNoaWxkcmVuOiBjTixcbiAga2V5OiBrTixcbiAgcmVmOiByTixcbiAgLi4ucHJvcHNcbn0sIHtcbiAgY2hpbGRyZW46IGNQLFxuICBrZXk6IGtQLFxuICByZWY6IHJQLFxuICAuLi5wcmV2aW91c1xufSA9IHt9LCByZW1vdmUgPSBmYWxzZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZiA6IHt9O1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gW107XG5cbiAgLy8gQ2F0Y2ggcmVtb3ZlZCBwcm9wcywgcHJlcGVuZCB0aGVtIHNvIHRoZXkgY2FuIGJlIHJlc2V0IG9yIHJlbW92ZWRcbiAgaWYgKHJlbW92ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5cyA9IE9iamVjdC5rZXlzKHByZXZpb3VzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcmV2aW91c0tleXNbaV0pKSBlbnRyaWVzLnVuc2hpZnQoW3ByZXZpb3VzS2V5c1tpXSwgREVGQVVMVCArICdyZW1vdmUnXSk7XG4gICAgfVxuICB9XG4gIGVudHJpZXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgLy8gQmFpbCBvdXQgb24gcHJpbWl0aXZlIG9iamVjdFxuICAgIGlmICgoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjIucHJpbWl0aXZlICYmIGtleSA9PT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAvLyBXaGVuIHByb3BzIG1hdGNoIGJhaWwgb3V0XG4gICAgaWYgKGlzLmVxdSh2YWx1ZSwgcHJldmlvdXNba2V5XSkpIHJldHVybjtcbiAgICAvLyBDb2xsZWN0IGhhbmRsZXJzIGFuZCBiYWlsIG91dFxuICAgIGlmICgvXm9uKFBvaW50ZXJ8Q2xpY2t8RG91YmxlQ2xpY2t8Q29udGV4dE1lbnV8V2hlZWwpLy50ZXN0KGtleSkpIHJldHVybiBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIHRydWUsIFtdXSk7XG4gICAgLy8gU3BsaXQgZGFzaGVkIHByb3BzXG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIGZhbHNlLCBlbnRyaWVzXSk7XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aChgJHtrZXl9LWApKSBjaGFuZ2VzLnB1c2goW3Byb3AsIHZhbHVlLCBmYWxzZSwgcHJvcC5zcGxpdCgnLScpXSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbWVtb2l6ZWQgPSB7XG4gICAgLi4ucHJvcHNcbiAgfTtcbiAgaWYgKGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncykgbWVtb2l6ZWQuYXJncyA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzO1xuICBpZiAobG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2gpIG1lbW9pemVkLmF0dGFjaCA9IGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hdHRhY2g7XG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9O1xufVxuY29uc3QgX19ERVZfXyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nO1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgYSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgZGF0YSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmMywgX3Jvb3QkZ2V0U3RhdGUsIF9pbnN0YW5jZSRfX3IzZjQ7XG4gIC8vIEZpbHRlciBlcXVhbHMsIGV2ZW50cyBhbmQgcmVzZXJ2ZWQgcHJvcHNcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YzID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG4gIGNvbnN0IHJvb3QgPSBsb2NhbFN0YXRlLnJvb3Q7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IChfcm9vdCRnZXRTdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZ2V0U3RhdGUoKSkgIT0gbnVsbCA/IF9yb290JGdldFN0YXRlIDoge307XG4gIGNvbnN0IHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH0gPSBpc0RpZmZTZXQoZGF0YSkgPyBkYXRhIDogZGlmZlByb3BzKGluc3RhbmNlLCBkYXRhKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gbG9jYWxTdGF0ZS5ldmVudENvdW50O1xuXG4gIC8vIFByZXBhcmUgbWVtb2l6ZWQgcHJvcHNcbiAgaWYgKGluc3RhbmNlLl9fcjNmKSBpbnN0YW5jZS5fX3IzZi5tZW1vaXplZFByb3BzID0gbWVtb2l6ZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBba2V5LCB2YWx1ZSwgaXNFdmVudCwga2V5c10gPSBjaGFuZ2VzW2ldO1xuXG4gICAgLy8gQWxpYXMgKG91dHB1dCllbmNvZGluZyA9PiAob3V0cHV0KWNvbG9yU3BhY2UgKHNpbmNlIHIxNTIpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI4MjlcbiAgICBpZiAoaGFzQ29sb3JTcGFjZShpbnN0YW5jZSkpIHtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbiAgICAgIGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbiAgICAgIGlmIChrZXkgPT09ICdlbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ2NvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvdXRwdXRFbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ291dHB1dENvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgbGV0IHRhcmdldFByb3AgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcblxuICAgIC8vIFJldm9sdmUgZGFzaGVkIHByb3BzXG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRQcm9wID0ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhdG9taWMsIGl0IGZvcmNlcyB1cyB0byBzd2l0Y2ggdGhlIHJvb3RcbiAgICAgIGlmICghKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQpKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCAuLi5yZXZlcnNlRW50cmllc10gPSBrZXlzLnJldmVyc2UoKTtcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gcmV2ZXJzZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAgIGtleSA9IG5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmICh2YWx1ZSA9PT0gREVGQVVMVCArICdyZW1vdmUnKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICAgIGxldCBjdG9yID0gREVGQVVMVFMuZ2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghY3Rvcikge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjdG9yID0gbmV3IGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgIERFRkFVTFRTLnNldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gY3RvcltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBjb25zdHJ1Y3RvciwganVzdCBzZXQgaXQgdG8gMFxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzIC4uLlxuICAgIGlmIChpc0V2ZW50KSB7XG4gICAgICBpZiAodmFsdWUpIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XSA9IHZhbHVlO2Vsc2UgZGVsZXRlIGxvY2FsU3RhdGUuaGFuZGxlcnNba2V5XTtcbiAgICAgIGxvY2FsU3RhdGUuZXZlbnRDb3VudCA9IE9iamVjdC5rZXlzKGxvY2FsU3RhdGUuaGFuZGxlcnMpLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gU3BlY2lhbCB0cmVhdG1lbnQgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvciBzZXQvY29weSwgYW5kIGxheWVyc1xuICAgIGVsc2UgaWYgKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQgJiYgKHRhcmdldFByb3AuY29weSB8fCB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSkge1xuICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAodGFyZ2V0UHJvcC5mcm9tQXJyYXkpIHRhcmdldFByb3AuZnJvbUFycmF5KHZhbHVlKTtlbHNlIHRhcmdldFByb3Auc2V0KC4uLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIFRlc3QgYWdhaW4gdGFyZ2V0LmNvcHkoY2xhc3MpIG5leHQgLi4uXG4gICAgICBlbHNlIGlmICh0YXJnZXRQcm9wLmNvcHkgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgKFxuICAgICAgLy8gU29tZSBlbnZpcm9ubWVudHMgbWF5IGJyZWFrIHN0cmljdCBpZGVudGl0eSBjaGVja3MgYnkgZHVwbGljYXRpbmcgdmVyc2lvbnMgb2YgdGhyZWUuanMuXG4gICAgICAvLyBMb29zZW4gdG8gdW5taW5pZmllZCBuYW1lcywgaWdub3JpbmcgZGVzY2VuZGVudHMuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8yODU2XG4gICAgICAvLyBUT0RPOiBmaXggdXBzdHJlYW0gYW5kIHJlbW92ZSBpbiB2OVxuICAgICAgX19ERVZfXyA/IHRhcmdldFByb3AuY29uc3RydWN0b3IubmFtZSA9PT0gdmFsdWUuY29uc3RydWN0b3IubmFtZSA6IHRhcmdldFByb3AuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0YXJnZXRQcm9wLmNvcHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbm90aGluZyBlbHNlIGZpdHMsIGp1c3Qgc2V0IHRoZSBzaW5nbGUgdmFsdWUsIGlnbm9yZSB1bmRlZmluZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI3NFxuICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBpc0NvbG9yID0gdGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yO1xuICAgICAgICAvLyBBbGxvdyBzZXR0aW5nIGFycmF5IHNjYWxhcnNcbiAgICAgICAgaWYgKCFpc0NvbG9yICYmIHRhcmdldFByb3Auc2V0U2NhbGFyKSB0YXJnZXRQcm9wLnNldFNjYWxhcih2YWx1ZSk7XG4gICAgICAgIC8vIExheWVycyBoYXZlIG5vIGNvcHkgZnVuY3Rpb24sIHdlIG11c3QgdGhlcmVmb3JlIGNvcHkgdGhlIG1hc2sgcHJvcGVydHlcbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykgdGFyZ2V0UHJvcC5tYXNrID0gdmFsdWUubWFzaztcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgc2V0IC4uLlxuICAgICAgICBlbHNlIHRhcmdldFByb3Auc2V0KHZhbHVlKTtcbiAgICAgICAgLy8gRm9yIHZlcnNpb25zIG9mIHRocmVlIHdoaWNoIGRvbid0IHN1cHBvcnQgVEhSRUUuQ29sb3JNYW5hZ2VtZW50LFxuICAgICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiBjb2xvcnNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzQ0XG4gICAgICAgIGlmICghZ2V0Q29sb3JNYW5hZ2VtZW50KCkgJiYgIXJvb3RTdGF0ZS5saW5lYXIgJiYgaXNDb2xvcikgdGFyZ2V0UHJvcC5jb252ZXJ0U1JHQlRvTGluZWFyKCk7XG4gICAgICB9XG4gICAgICAvLyBFbHNlLCBqdXN0IG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0gPSB2YWx1ZTtcblxuICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgdGV4dHVyZXMsIGZvciBub3cgLi4uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2Vba2V5XSBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0uZm9ybWF0ID09PSBUSFJFRS5SR0JBRm9ybWF0ICYmIGN1cnJlbnRJbnN0YW5jZVtrZXldLnR5cGUgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUpIHtcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuICAgICAgICBpZiAoaGFzQ29sb3JTcGFjZSh0ZXh0dXJlKSAmJiBoYXNDb2xvclNwYWNlKHJvb3RTdGF0ZS5nbCkpIHRleHR1cmUuY29sb3JTcGFjZSA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRDb2xvclNwYWNlO2Vsc2UgdGV4dHVyZS5lbmNvZGluZyA9IHJvb3RTdGF0ZS5nbC5vdXRwdXRFbmNvZGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgfVxuICBpZiAobG9jYWxTdGF0ZS5wYXJlbnQgJiYgaW5zdGFuY2UucmF5Y2FzdCAmJiBwcmV2SGFuZGxlcnMgIT09IGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCByb290IHN0YXRlJ3MgaW50ZXJuYWxzXG4gICAgY29uc3QgaW50ZXJuYWwgPSBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWw7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IGludGVybmFsLmludGVyYWN0aW9uLmluZGV4T2YoaW5zdGFuY2UpO1xuICAgIGlmIChpbmRleCA+IC0xKSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChsb2NhbFN0YXRlLmV2ZW50Q291bnQpIGludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdXBkYXRlIGxpZmVjeWNsZSB3aGVuIGl0IGlzIGJlaW5nIHVwZGF0ZWQsIGJ1dCBvbmx5IHdoZW4gaXQgaXMgcGFydCBvZiB0aGUgc2NlbmUuXG4gIC8vIFNraXAgdXBkYXRlcyB0byB0aGUgYG9uVXBkYXRlYCBwcm9wIGl0c2VsZlxuICBjb25zdCBpc0NpcmN1bGFyID0gY2hhbmdlcy5sZW5ndGggPT09IDEgJiYgY2hhbmdlc1swXVswXSA9PT0gJ29uVXBkYXRlJztcbiAgaWYgKCFpc0NpcmN1bGFyICYmIGNoYW5nZXMubGVuZ3RoICYmIChfaW5zdGFuY2UkX19yM2Y0ID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmNC5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2Y1LCBfaW5zdGFuY2UkX19yM2Y1JHJvb3Q7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5zdGFuY2UkX19yM2Y1JHJvb3QgPSBfaW5zdGFuY2UkX19yM2Y1LnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjUkcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICBpZiAoIWNhbWVyYS5tYW51YWwpIHtcbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xNzhcbiAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcbiAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlciNnZXRjdXJyZW50ZXZlbnRwcmlvcml0eVxuLy8gR2l2ZXMgUmVhY3QgYSBjbHVlIGFzIHRvIGhvdyBpbXBvcnQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gaXNcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfZ2xvYmFsU2NvcGUkZXZlbnQ7XG4gIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUgaW4gd2luZG93IGFuZCB3b3JrZXIgY29udGV4dHMgaWYgYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjQ5M1xuICBjb25zdCBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbiAgaWYgKCFnbG9iYWxTY29wZSkgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICBjb25zdCBuYW1lID0gKF9nbG9iYWxTY29wZSRldmVudCA9IGdsb2JhbFNjb3BlLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFNjb3BlJGV2ZW50LnR5cGU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnZGJsY2xpY2snOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgY2FzZSAncG9pbnRlcmxlYXZlJzpcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbGVhc2UgcG9pbnRlciBjYXB0dXJlcy5cbiAqIFRoaXMgaXMgY2FsbGVkIGJ5IHJlbGVhc2VQb2ludGVyQ2FwdHVyZSBpbiB0aGUgQVBJLCBhbmQgd2hlbiBhbiBvYmplY3QgaXMgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KSB8fCByb290U3RhdGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG5cbiAgICAgICAgLypcbiAgICAgICAgTUFZQkUgVE9ETywgREVMRVRFIElGIE5PVDogXG4gICAgICAgICAgQ2hlY2sgaWYgdGhlIG9iamVjdCBpcyBjYXB0dXJlZCwgY2FwdHVyZWQgZXZlbnRzIHNob3VsZCBub3QgaGF2ZSBpbnRlcnNlY3RzIHJ1bm5pbmcgaW4gcGFyYWxsZWxcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xuICAgICAgICAgIEFsc28sIGFyZSB3ZSBPSyB3aXRoIHN0cmFpZ2h0IHVwIG1ha2luZyBwaWNraW5nIHVwIG11bHRpcGxlIG9iamVjdHMgaW1wb3NzaWJsZT9cbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlZE1lc2hTZXQgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQocG9pbnRlcklkKVxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVkID0gY2FwdHVyZWRNZXNoU2V0LmdldChldmVudE9iamVjdClcbiAgICAgICAgICAgIGlmIChjYXB0dXJlZCAmJiBjYXB0dXJlZC5sb2NhbFN0YXRlLnN0b3BwZWQpIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfSovXG5cbiAgICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZW50IC4uLlxuICAgICAgICAgIGlmIChoYW5kbGVycy5vblBvaW50ZXJPdmVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyIHx8IGhhbmRsZXJzLm9uUG9pbnRlck91dCB8fCBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSkge1xuICAgICAgICAgICAgLy8gV2hlbiBlbnRlciBvciBvdXQgaXMgcHJlc2VudCB0YWtlIGNhcmUgb2YgaG92ZXItc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgaG92ZXJlZEl0ZW0gPSBpbnRlcm5hbC5ob3ZlcmVkLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoIWhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2Fzbid0IHByZXZpb3VzbHkgaG92ZXJlZCwgYm9vayBpdCBhbmQgY2FsbCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLnNldChpZCwgZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck92ZXIoZGF0YSk7XG4gICAgICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlckVudGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJFbnRlcihkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0uc3RvcHBlZCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhcyBwcmV2aW91c2x5IGhvdmVyZWQgYW5kIHN0b3BwZWQsIHdlIHNob3VsZG4ndCBhbGxvdyBvdGhlciBpdGVtcyB0byBwcm9jZWVkXG4gICAgICAgICAgICAgIGRhdGEuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgbW91c2UgbW92ZVxuICAgICAgICAgIGhhbmRsZXJzLm9uUG9pbnRlck1vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck1vdmUoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxsIG90aGVyIGV2ZW50cyAuLi5cbiAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbbmFtZV07XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIC8vIEZvcndhcmQgYWxsIGV2ZW50cyBiYWNrIHRvIHRoZWlyIHJlc3BlY3RpdmUgaGFuZGxlcnMgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGNsaWNrIGV2ZW50cyxcbiAgICAgICAgICAgIC8vIHdoaWNoIG11c3QgdXNlIHRoZSBpbml0aWFsIHRhcmdldFxuICAgICAgICAgICAgaWYgKCFpc0NsaWNrRXZlbnQgfHwgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgICAgLy8gTm93IGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgICAgICAgICAgaGFuZGxlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvblBvaW50ZXJNaXNzZWQgb24gYWxsIGVsZW1lbnRzIHRoYXQgaGF2ZSBwb2ludGVyIG92ZXIvb3V0IGhhbmRsZXJzLCBidXQgbm90IGNsaWNrIGFuZCB3ZXJlbid0IGhpdFxuICAgICAgICAgICAgaWYgKGlzQ2xpY2tFdmVudCAmJiBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlSW50ZXJzZWN0cyhoaXRzLCBldmVudCwgZGVsdGEsIG9uSW50ZXJzZWN0KTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9O1xufVxuXG4vLyBLZXlzIHRoYXQgc2hvdWxkbid0IGJlIGNvcGllZCBiZXR3ZWVuIFIzRiBzdG9yZXNcbmNvbnN0IHByaXZhdGVLZXlzID0gWydzZXQnLCAnZ2V0JywgJ3NldFNpemUnLCAnc2V0RnJhbWVsb29wJywgJ3NldERwcicsICdldmVudHMnLCAnaW52YWxpZGF0ZScsICdhZHZhbmNlJywgJ3NpemUnLCAndmlld3BvcnQnXTtcbmNvbnN0IGlzUmVuZGVyZXIgPSBkZWYgPT4gISEoZGVmICE9IG51bGwgJiYgZGVmLnJlbmRlcik7XG5jb25zdCBjb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbnZhbGlkYXRlLCBhZHZhbmNlKSA9PiB7XG4gIGNvbnN0IHJvb3RTdGF0ZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgZGVmYXVsdFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgY29uc3QgdGVtcFRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSA9IGdldCgpLmNhbWVyYSwgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCwgc2l6ZSA9IGdldCgpLnNpemUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0XG4gICAgICB9ID0gc2l6ZTtcbiAgICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMpIHRlbXBUYXJnZXQuY29weSh0YXJnZXQpO2Vsc2UgdGVtcFRhcmdldC5zZXQoLi4udGFyZ2V0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2FtZXJhLmdldFdvcmxkUG9zaXRpb24ocG9zaXRpb24pLmRpc3RhbmNlVG8odGVtcFRhcmdldCk7XG4gICAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiAxLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm92ID0gY2FtZXJhLmZvdiAqIE1hdGguUEkgLyAxODA7IC8vIGNvbnZlcnQgdmVydGljYWwgZm92IHRvIHJhZGlhbnNcbiAgICAgICAgY29uc3QgaCA9IDIgKiBNYXRoLnRhbihmb3YgLyAyKSAqIGRpc3RhbmNlOyAvLyB2aXNpYmxlIGhlaWdodFxuICAgICAgICBjb25zdCB3ID0gaCAqICh3aWR0aCAvIGhlaWdodCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3Rvcjogd2lkdGggLyB3LFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGFzcGVjdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGVyZm9ybWFuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNldFBlcmZvcm1hbmNlQ3VycmVudCA9IGN1cnJlbnQgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgY3VycmVudFxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCBwb2ludGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcbiAgICBjb25zdCByb290U3RhdGUgPSB7XG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBNb2NrIG9iamVjdHMgdGhhdCBoYXZlIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgIGdsOiBudWxsLFxuICAgICAgY2FtZXJhOiBudWxsLFxuICAgICAgcmF5Y2FzdGVyOiBudWxsLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIHByaW9yaXR5OiAxLFxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBjb25uZWN0ZWQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgeHI6IG51bGwsXG4gICAgICBzY2VuZTogbnVsbCxcbiAgICAgIGludmFsaWRhdGU6IChmcmFtZXMgPSAxKSA9PiBpbnZhbGlkYXRlKGdldCgpLCBmcmFtZXMpLFxuICAgICAgYWR2YW5jZTogKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cykgPT4gYWR2YW5jZSh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMsIGdldCgpKSxcbiAgICAgIGxlZ2FjeTogZmFsc2UsXG4gICAgICBsaW5lYXI6IGZhbHNlLFxuICAgICAgZmxhdDogZmFsc2UsXG4gICAgICBjb250cm9sczogbnVsbCxcbiAgICAgIGNsb2NrOiBuZXcgVEhSRUUuQ2xvY2soKSxcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIGZyYW1lbG9vcDogJ2Fsd2F5cycsXG4gICAgICBvblBvaW50ZXJNaXNzZWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIGN1cnJlbnQ6IDEsXG4gICAgICAgIG1pbjogMC41LFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIGRlYm91bmNlOiAyMDAsXG4gICAgICAgIHJlZ3Jlc3M6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRcbiAgICAgICAgICBpZiAocGVyZm9ybWFuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQocGVyZm9ybWFuY2VUaW1lb3V0KTtcbiAgICAgICAgICAvLyBTZXQgbG93ZXIgYm91bmQgcGVyZm9ybWFuY2VcbiAgICAgICAgICBpZiAoc3RhdGUucGVyZm9ybWFuY2UuY3VycmVudCAhPT0gc3RhdGUucGVyZm9ybWFuY2UubWluKSBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoc3RhdGUucGVyZm9ybWFuY2UubWluKTtcbiAgICAgICAgICAvLyBHbyBiYWNrIHRvIHVwcGVyIGJvdW5kIHBlcmZvcm1hbmNlIGFmdGVyIGEgd2hpbGUgdW5sZXNzIHNvbWV0aGluZyByZWdyZXNzZXMgbWVhbndoaWxlXG4gICAgICAgICAgcGVyZm9ybWFuY2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRQZXJmb3JtYW5jZUN1cnJlbnQoZ2V0KCkucGVyZm9ybWFuY2UubWF4KSwgc3RhdGUucGVyZm9ybWFuY2UuZGVib3VuY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGluaXRpYWxEcHI6IDAsXG4gICAgICAgIGRwcjogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBhc3BlY3Q6IDAsXG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBmYWN0b3I6IDAsXG4gICAgICAgIGdldEN1cnJlbnRWaWV3cG9ydFxuICAgICAgfSxcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSksXG4gICAgICBzZXRTaXplOiAod2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUsIHRvcCwgbGVmdCkgPT4ge1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBnZXQoKS5jYW1lcmE7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHRvcDogdG9wIHx8IDAsXG4gICAgICAgICAgbGVmdDogbGVmdCB8fCAwLFxuICAgICAgICAgIHVwZGF0ZVN0eWxlXG4gICAgICAgIH07XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgLi4uZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgZGVmYXVsdFRhcmdldCwgc2l6ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBzZXREcHI6IGRwciA9PiBzZXQoc3RhdGUgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGNhbGN1bGF0ZURwcihkcHIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIGRwcjogcmVzb2x2ZWQsXG4gICAgICAgICAgICBpbml0aWFsRHByOiBzdGF0ZS52aWV3cG9ydC5pbml0aWFsRHByIHx8IHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBzZXRGcmFtZWxvb3A6IChmcmFtZWxvb3AgPSAnYWx3YXlzJykgPT4ge1xuICAgICAgICBjb25zdCBjbG9jayA9IGdldCgpLmNsb2NrO1xuXG4gICAgICAgIC8vIGlmIGZyYW1lbG9vcCA9PT0gXCJuZXZlclwiIGNsb2NrLmVsYXBzZWRUaW1lIGlzIHVwZGF0ZWQgdXNpbmcgYWR2YW5jZSh0aW1lc3RhbXApXG4gICAgICAgIGNsb2NrLnN0b3AoKTtcbiAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICBpZiAoZnJhbWVsb29wICE9PSAnbmV2ZXInKSB7XG4gICAgICAgICAgY2xvY2suc3RhcnQoKTtcbiAgICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc2V0KCgpID0+ICh7XG4gICAgICAgICAgZnJhbWVsb29wXG4gICAgICAgIH0pKTtcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c1Jvb3Q6IHVuZGVmaW5lZCxcbiAgICAgIGludGVybmFsOiB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICBmcmFtZXM6IDAsXG4gICAgICAgIGxhc3RFdmVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICBpbnRlcmFjdGlvbjogW10sXG4gICAgICAgIGhvdmVyZWQ6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICBpbml0aWFsQ2xpY2s6IFswLCAwXSxcbiAgICAgICAgaW5pdGlhbEhpdHM6IFtdLFxuICAgICAgICBjYXB0dXJlZE1hcDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmU6IChyZWYsIHByaW9yaXR5LCBzdG9yZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJzY3JpcHRpb24gd2FzIGdpdmVuIGEgcHJpb3JpdHksIGl0IHRha2VzIHJlbmRlcmluZyBpbnRvIGl0cyBvd24gaGFuZHNcbiAgICAgICAgICAvLyBGb3IgdGhhdCByZWFzb24gd2Ugc3dpdGNoIG9mZiBhdXRvbWF0aWMgcmVuZGVyaW5nIGFuZCBpbmNyZWFzZSB0aGUgbWFudWFsIGZsYWdcbiAgICAgICAgICAvLyBBcyBsb25nIGFzIHRoaXMgZmxhZyBpcyBwb3NpdGl2ZSB0aGVyZSBjYW4gYmUgbm8gaW50ZXJuYWwgcmVuZGVyaW5nIGF0IGFsbFxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgcmVuZGVyIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5ICsgKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycy5wdXNoKHtcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIHByaW9yaXR5LFxuICAgICAgICAgICAgc3RvcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBSZWdpc3RlciBzdWJzY3JpYmVyIGFuZCBzb3J0IGxheWVycyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LCBtZWFuaW5nLFxuICAgICAgICAgIC8vIGhpZ2hlc3QgcHJpb3JpdHkgcmVuZGVycyBsYXN0IChvbiB0b3Agb2YgdGhlIG90aGVyIGZyYW1lcylcbiAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbCAhPSBudWxsICYmIGludGVybmFsLnN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIG1hbnVhbCBmbGFnIGlmIHRoaXMgc3Vic2NyaXB0aW9uIGhhZCBhIHByaW9yaXR5XG4gICAgICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgLSAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgc3Vic2NyaWJlciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5maWx0ZXIocyA9PiBzLnJlZiAhPT0gcmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcm9vdFN0YXRlO1xuICB9KTtcbiAgY29uc3Qgc3RhdGUgPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcbiAgbGV0IG9sZFNpemUgPSBzdGF0ZS5zaXplO1xuICBsZXQgb2xkRHByID0gc3RhdGUudmlld3BvcnQuZHByO1xuICBsZXQgb2xkQ2FtZXJhID0gc3RhdGUuY2FtZXJhO1xuICByb290U3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW1lcmEsXG4gICAgICBzaXplLFxuICAgICAgdmlld3BvcnQsXG4gICAgICBnbCxcbiAgICAgIHNldFxuICAgIH0gPSByb290U3RhdGUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIFJlc2l6ZSBjYW1lcmEgYW5kIHJlbmRlcmVyIG9uIGNoYW5nZXMgdG8gc2l6ZSBhbmQgcGl4ZWxyYXRpb1xuICAgIGlmIChzaXplLndpZHRoICE9PSBvbGRTaXplLndpZHRoIHx8IHNpemUuaGVpZ2h0ICE9PSBvbGRTaXplLmhlaWdodCB8fCB2aWV3cG9ydC5kcHIgIT09IG9sZERwcikge1xuICAgICAgdmFyIF9zaXplJHVwZGF0ZVN0eWxlO1xuICAgICAgb2xkU2l6ZSA9IHNpemU7XG4gICAgICBvbGREcHIgPSB2aWV3cG9ydC5kcHI7XG4gICAgICAvLyBVcGRhdGUgY2FtZXJhICYgcmVuZGVyZXJcbiAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgICAgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSAoX3NpemUkdXBkYXRlU3R5bGUgPSBzaXplLnVwZGF0ZVN0eWxlKSAhPSBudWxsID8gX3NpemUkdXBkYXRlU3R5bGUgOiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBzdWJzKSB7XG4gIGNvbnN0IHN1YiA9IHtcbiAgICBjYWxsYmFja1xuICB9O1xuICBzdWJzLmFkZChzdWIpO1xuICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzLmRlbGV0ZShzdWIpO1xufVxubGV0IGk7XG5sZXQgZ2xvYmFsRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxBZnRlckVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEFmdGVyRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRUYWlsXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSkge1xuICAvLyBSdW4gbG9jYWwgZWZmZWN0c1xuICBsZXQgZGVsdGEgPSBzdGF0ZS5jbG9jay5nZXREZWx0YSgpO1xuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuICAvLyBDYWxsIHN1YnNjcmliZXJzICh1c2VGcmFtZSlcbiAgc3Vic2NyaWJlcnMgPSBzdGF0ZS5pbnRlcm5hbC5zdWJzY3JpYmVycztcbiAgZm9yIChpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG4gIC8vIFJlbmRlciBjb250ZW50XG4gIGlmICghc3RhdGUuaW50ZXJuYWwucHJpb3JpdHkgJiYgc3RhdGUuZ2wucmVuZGVyKSBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG4gIC8vIERlY3JlYXNlIGZyYW1lIGNvdW50XG4gIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWF4KDAsIHN0YXRlLmludGVybmFsLmZyYW1lcyAtIDEpO1xuICByZXR1cm4gc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyA/IDEgOiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVMb29wKHJvb3RzKSB7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBmcmFtZTtcbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcGVhdCA9IDA7XG5cbiAgICAvLyBSdW4gZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgICByZXBlYXQgKz0gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICAgIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHIyO1xuICAgIGlmICghc3RhdGUpIHJldHVybiByb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCkpLCBmcmFtZXMpO1xuICAgIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHJlbmRlciQxKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb29wLFxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNpbnZhbGlkYXRlXG4gICAgICovXG4gICAgaW52YWxpZGF0ZSxcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgZnJhbWVsb29wIGFuZCBydW5zIHJlbmRlciBlZmZlY3RzLCB1c2VmdWwgZm9yIHdoZW4gbWFudWFsbHkgcmVuZGVyaW5nIHZpYSBgZnJhbWVsb29wPVwibmV2ZXJcImAuXG4gICAgICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkdmFuY2VcbiAgICAgKi9cbiAgICBhZHZhbmNlXG4gIH07XG59XG5cbi8qKlxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgTG9jYWxTdGF0ZX0uXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcbiAqXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAoaW5zdGFuY2UuY3VycmVudCA9IHJlZi5jdXJyZW50Ll9fcjNmKSwgW3JlZl0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBBY2Nlc3NlcyBSM0YncyBpbnRlcm5hbCBzdGF0ZSwgY29udGFpbmluZyByZW5kZXJlciwgY2FudmFzLCBzY2VuZSwgZXRjLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNldGhyZWVcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBjYWxsYmFjayBiZWZvcmUgcmVuZGVyIGluIGEgc2hhcmVkIGZyYW1lIGxvb3AuXG4gKiBDYW4gb3JkZXIgZWZmZWN0cyB3aXRoIHJlbmRlciBwcmlvcml0eSBvciBtYW51YWxseSByZW5kZXIgd2l0aCBhIHBvc2l0aXZlIHByaW9yaXR5LlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcbiAqL1xuZnVuY3Rpb24gdXNlRnJhbWUoY2FsbGJhY2ssIHJlbmRlclByaW9yaXR5ID0gMCkge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHN0b3JlLmdldFN0YXRlKCkuaW50ZXJuYWwuc3Vic2NyaWJlO1xuICAvLyBNZW1vaXplIHJlZlxuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAvLyBTdWJzY3JpYmUgb24gbW91bnQsIHVuc3Vic2NyaWJlIG9uIHVubW91bnRcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBzdWJzY3JpYmUocmVmLCByZW5kZXJQcmlvcml0eSwgc3RvcmUpLCBbcmVuZGVyUHJpb3JpdHksIHN1YnNjcmliZSwgc3RvcmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5vZGUgZ3JhcGggb2YgYW4gb2JqZWN0IHdpdGggbmFtZWQgbm9kZXMgJiBtYXRlcmlhbHMuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxuICovXG5mdW5jdGlvbiB1c2VHcmFwaChvYmplY3QpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gYnVpbGRHcmFwaChvYmplY3QpLCBbb2JqZWN0XSk7XG59XG5jb25zdCBtZW1vaXplZExvYWRlcnMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gbG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChQcm90bywgLi4uaW5wdXQpIHtcbiAgICAvLyBDb25zdHJ1Y3QgbmV3IGxvYWRlciBhbmQgcnVuIGV4dGVuc2lvbnNcbiAgICBsZXQgbG9hZGVyID0gbWVtb2l6ZWRMb2FkZXJzLmdldChQcm90byk7XG4gICAgaWYgKCFsb2FkZXIpIHtcbiAgICAgIGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgICAgbWVtb2l6ZWRMb2FkZXJzLnNldChQcm90bywgbG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbnMpIGV4dGVuc2lvbnMobG9hZGVyKTtcbiAgICAvLyBHbyB0aHJvdWdoIHRoZSB1cmxzIGFuZCBsb2FkIHRoZW1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKGlucHV0ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlamVjdCkgPT4gbG9hZGVyLmxvYWQoaW5wdXQsIGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEuc2NlbmUpIE9iamVjdC5hc3NpZ24oZGF0YSwgYnVpbGRHcmFwaChkYXRhLnNjZW5lKSk7XG4gICAgICByZXMoZGF0YSk7XG4gICAgfSwgb25Qcm9ncmVzcywgZXJyb3IgPT4gcmVqZWN0KG5ldyBFcnJvcihgQ291bGQgbm90IGxvYWQgJHtpbnB1dH06ICR7ZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2V9YCkpKSkpKS5maW5hbGx5KCgpID0+IGxvYWRlci5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXIuZGlzcG9zZSgpKTtcbiAgfTtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBhbmQgY2FjaGVzIGFzc2V0cyB3aXRoIGEgdGhyZWUgbG9hZGVyLlxuICpcbiAqIE5vdGU6IHRoaXMgaG9vaydzIGNhbGxlciBtdXN0IGJlIHdyYXBwZWQgd2l0aCBgUmVhY3QuU3VzcGVuc2VgXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2Vsb2FkZXJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCByZXN1bHRzID0gc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtQcm90bywgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdC9zXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcbiAqIFByZWxvYWRzIGFuIGFzc2V0IGludG8gY2FjaGUgYXMgYSBzaWRlLWVmZmVjdC5cbiAqL1xudXNlTG9hZGVyLnByZWxvYWQgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIHByZWxvYWQobG9hZGluZ0ZuKGV4dGVuc2lvbnMpLCBbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGxvYWRlZCBhc3NldCBmcm9tIGNhY2hlLlxuICovXG51c2VMb2FkZXIuY2xlYXIgPSBmdW5jdGlvbiAoUHJvdG8sIGlucHV0KSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgcmV0dXJuIGNsZWFyKFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuY29uc3Qgcm9vdHMgPSBuZXcgTWFwKCk7XG5jb25zdCB7XG4gIGludmFsaWRhdGUsXG4gIGFkdmFuY2Vcbn0gPSBjcmVhdGVMb29wKHJvb3RzKTtcbmNvbnN0IHtcbiAgcmVjb25jaWxlcixcbiAgYXBwbHlQcm9wc1xufSA9IGNyZWF0ZVJlbmRlcmVyKHJvb3RzLCBnZXRFdmVudFByaW9yaXR5KTtcbmNvbnN0IHNoYWxsb3dMb29zZSA9IHtcbiAgb2JqZWN0czogJ3NoYWxsb3cnLFxuICBzdHJpY3Q6IGZhbHNlXG59O1xuY29uc3QgY3JlYXRlUmVuZGVyZXJJbnN0YW5jZSA9IChnbCwgY2FudmFzKSA9PiB7XG4gIGNvbnN0IGN1c3RvbVJlbmRlcmVyID0gdHlwZW9mIGdsID09PSAnZnVuY3Rpb24nID8gZ2woY2FudmFzKSA6IGdsO1xuICBpZiAoaXNSZW5kZXJlcihjdXN0b21SZW5kZXJlcikpIHJldHVybiBjdXN0b21SZW5kZXJlcjtlbHNlIHJldHVybiBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZScsXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgYW50aWFsaWFzOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlLFxuICAgIC4uLmdsXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIGRlZmF1bHRTaXplKSB7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gIGlmIChkZWZhdWx0U2l6ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlID0gZGVmYXVsdFN0eWxlXG4gICAgfSA9IGRlZmF1bHRTaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdFxuICAgIH0gPSBjYW52YXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdXBkYXRlU3R5bGU6IGRlZmF1bHRTdHlsZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBDb25jdXJyZW50Um9vdCwgbnVsbCwgZmFsc2UsIG51bGwsICcnLCBsb2dSZWNvdmVyYWJsZUVycm9yLCBudWxsKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIHJvb3RzLnNldChjYW52YXMsIHtcbiAgICBmaWJlcixcbiAgICBzdG9yZVxuICB9KTtcblxuICAvLyBMb2NhbHNcbiAgbGV0IG9uQ3JlYXRlZDtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RDYW1lcmE7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGdsOiBnbENvbmZpZyxcbiAgICAgICAgc2l6ZTogcHJvcHNTaXplLFxuICAgICAgICBzY2VuZTogc2NlbmVPcHRpb25zLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkQ2FsbGJhY2ssXG4gICAgICAgIHNoYWRvd3MgPSBmYWxzZSxcbiAgICAgICAgbGluZWFyID0gZmFsc2UsXG4gICAgICAgIGZsYXQgPSBmYWxzZSxcbiAgICAgICAgbGVnYWN5ID0gZmFsc2UsXG4gICAgICAgIG9ydGhvZ3JhcGhpYyA9IGZhbHNlLFxuICAgICAgICBmcmFtZWxvb3AgPSAnYWx3YXlzJyxcbiAgICAgICAgZHByID0gWzEsIDJdLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0T3B0aW9ucyxcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFPcHRpb25zLFxuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0gPSBwcm9wcztcbiAgICAgIGxldCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNldCB1cCByZW5kZXJlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgZ2wgPSBzdGF0ZS5nbDtcbiAgICAgIGlmICghc3RhdGUuZ2wpIHN0YXRlLnNldCh7XG4gICAgICAgIGdsOiBnbCA9IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UoZ2xDb25maWcsIGNhbnZhcylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29uZmlndXJlIHJheWNhc3RlclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXhyL2lzc3Vlcy8zMDBcbiAgICAgICAgcmF5Y2FzdGVyLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIHNjZW5lIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUuc2NlbmUpIHtcbiAgICAgICAgbGV0IHNjZW5lO1xuICAgICAgICBpZiAoc2NlbmVPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuU2NlbmUpIHtcbiAgICAgICAgICBzY2VuZSA9IHNjZW5lT3B0aW9ucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIGlmIChzY2VuZU9wdGlvbnMpIGFwcGx5UHJvcHMoc2NlbmUsIHNjZW5lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBzY2VuZTogcHJlcGFyZShzY2VuZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBYUiAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnhyKSB7XG4gICAgICAgIHZhciBfZ2wkeHI7XG4gICAgICAgIC8vIEhhbmRsZSBmcmFtZSBiZWhhdmlvciBpbiBXZWJYUlxuICAgICAgICBjb25zdCBoYW5kbGVYUkZyYW1lID0gKHRpbWVzdGFtcCwgZnJhbWUpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgICAgICAgIGFkdmFuY2UodGltZXN0YW1wLCB0cnVlLCBzdGF0ZSwgZnJhbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSByZW5kZXIgc3dpdGNoaW5nIG9uIHNlc3Npb25cbiAgICAgICAgY29uc3QgaGFuZGxlU2Vzc2lvbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuZW5hYmxlZCA9IHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZztcbiAgICAgICAgICBzdGF0ZS5nbC54ci5zZXRBbmltYXRpb25Mb29wKHN0YXRlLmdsLnhyLmlzUHJlc2VudGluZyA/IGhhbmRsZVhSRnJhbWUgOiBudWxsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdsLnhyLmlzUHJlc2VudGluZykgaW52YWxpZGF0ZShzdGF0ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gV2ViWFIgc2Vzc2lvbiBtYW5hZ2VyXG4gICAgICAgIGNvbnN0IHhyID0ge1xuICAgICAgICAgIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICBjb25zdCBnbCA9IHN0b3JlLmdldFN0YXRlKCkuZ2w7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uc3RhcnQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25lbmQnLCBoYW5kbGVTZXNzaW9uQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIFdlYlhSIHNlc3Npb24gZXZlbnRzXG4gICAgICAgIGlmICh0eXBlb2YgKChfZ2wkeHIgPSBnbC54cikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbCR4ci5hZGRFdmVudExpc3RlbmVyKSA9PT0gJ2Z1bmN0aW9uJykgeHIuY29ubmVjdCgpO1xuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHhyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgc2hhZG93bWFwXG4gICAgICBpZiAoZ2wuc2hhZG93TWFwKSB7XG4gICAgICAgIGNvbnN0IG9sZEVuYWJsZWQgPSBnbC5zaGFkb3dNYXAuZW5hYmxlZDtcbiAgICAgICAgY29uc3Qgb2xkVHlwZSA9IGdsLnNoYWRvd01hcC50eXBlO1xuICAgICAgICBnbC5zaGFkb3dNYXAuZW5hYmxlZCA9ICEhc2hhZG93cztcbiAgICAgICAgaWYgKGlzLmJvbyhzaGFkb3dzKSkge1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5zdHIoc2hhZG93cykpIHtcbiAgICAgICAgICB2YXIgX3R5cGVzJHNoYWRvd3M7XG4gICAgICAgICAgY29uc3QgdHlwZXMgPSB7XG4gICAgICAgICAgICBiYXNpYzogVEhSRUUuQmFzaWNTaGFkb3dNYXAsXG4gICAgICAgICAgICBwZXJjZW50YWdlOiBUSFJFRS5QQ0ZTaGFkb3dNYXAsXG4gICAgICAgICAgICBzb2Z0OiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwLFxuICAgICAgICAgICAgdmFyaWFuY2U6IFRIUkVFLlZTTVNoYWRvd01hcFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSAoX3R5cGVzJHNoYWRvd3MgPSB0eXBlc1tzaGFkb3dzXSkgIT0gbnVsbCA/IF90eXBlcyRzaGFkb3dzIDogVEhSRUUuUENGU29mdFNoYWRvd01hcDtcbiAgICAgICAgfSBlbHNlIGlmIChpcy5vYmooc2hhZG93cykpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGdsLnNoYWRvd01hcCwgc2hhZG93cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZEVuYWJsZWQgIT09IGdsLnNoYWRvd01hcC5lbmFibGVkIHx8IG9sZFR5cGUgIT09IGdsLnNoYWRvd01hcC50eXBlKSBnbC5zaGFkb3dNYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTYWZlbHkgc2V0IGNvbG9yIG1hbmFnZW1lbnQgaWYgYXZhaWxhYmxlLlxuICAgICAgLy8gQXZvaWQgYWNjZXNzaW5nIFRIUkVFLkNvbG9yTWFuYWdlbWVudCB0byBwbGF5IG5pY2Ugd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAgICAgY29uc3QgQ29sb3JNYW5hZ2VtZW50ID0gZ2V0Q29sb3JNYW5hZ2VtZW50KCk7XG4gICAgICBpZiAoQ29sb3JNYW5hZ2VtZW50KSB7XG4gICAgICAgIGlmICgnZW5hYmxlZCcgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQuZW5hYmxlZCA9ICFsZWdhY3k7ZWxzZSBpZiAoJ2xlZ2FjeU1vZGUnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmxlZ2FjeU1vZGUgPSBsZWdhY3k7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBjb2xvciBzcGFjZSBhbmQgdG9uZW1hcHBpbmcgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBhcHBseVByb3BzKGdsLCB7XG4gICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgdG9uZU1hcHBpbmc6IGZsYXQgPyBUSFJFRS5Ob1RvbmVNYXBwaW5nIDogVEhSRUUuQUNFU0ZpbG1pY1RvbmVNYXBwaW5nXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIGNvbG9yIG1hbmFnZW1lbnQgc3RhdGVcbiAgICAgIGlmIChzdGF0ZS5sZWdhY3kgIT09IGxlZ2FjeSkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxlZ2FjeVxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmxpbmVhciAhPT0gbGluZWFyKSBzdGF0ZS5zZXQoKCkgPT4gKHtcbiAgICAgICAgbGluZWFyXG4gICAgICB9KSk7XG4gICAgICBpZiAoc3RhdGUuZmxhdCAhPT0gZmxhdCkgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGZsYXRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGdsIHByb3BzXG4gICAgICBpZiAoZ2xDb25maWcgJiYgIWlzLmZ1bihnbENvbmZpZykgJiYgIWlzUmVuZGVyZXIoZ2xDb25maWcpICYmICFpcy5lcXUoZ2xDb25maWcsIGdsLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKGdsLCBnbENvbmZpZyk7XG4gICAgICAvLyBTdG9yZSBldmVudHMgaW50ZXJuYWxseVxuICAgICAgaWYgKGV2ZW50cyAmJiAhc3RhdGUuZXZlbnRzLmhhbmRsZXJzKSBzdGF0ZS5zZXQoe1xuICAgICAgICBldmVudHM6IGV2ZW50cyhzdG9yZSlcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hlY2sgc2l6ZSwgYWxsb3cgaXQgdG8gdGFrZSBvbiBjb250YWluZXIgYm91bmRzIGluaXRpYWxseVxuICAgICAgY29uc3Qgc2l6ZSA9IGNvbXB1dGVJbml0aWFsU2l6ZShjYW52YXMsIHByb3BzU2l6ZSk7XG4gICAgICBpZiAoIWlzLmVxdShzaXplLCBzdGF0ZS5zaXplLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIHN0YXRlLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHNpemUudXBkYXRlU3R5bGUsIHNpemUudG9wLCBzaXplLmxlZnQpO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgcGl4ZWxyYXRpb1xuICAgICAgaWYgKGRwciAmJiBzdGF0ZS52aWV3cG9ydC5kcHIgIT09IGNhbGN1bGF0ZURwcihkcHIpKSBzdGF0ZS5zZXREcHIoZHByKTtcbiAgICAgIC8vIENoZWNrIGZyYW1lbG9vcFxuICAgICAgaWYgKHN0YXRlLmZyYW1lbG9vcCAhPT0gZnJhbWVsb29wKSBzdGF0ZS5zZXRGcmFtZWxvb3AoZnJhbWVsb29wKTtcbiAgICAgIC8vIENoZWNrIHBvaW50ZXIgbWlzc2VkXG4gICAgICBpZiAoIXN0YXRlLm9uUG9pbnRlck1pc3NlZCkgc3RhdGUuc2V0KHtcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHBlcmZvcm1hbmNlXG4gICAgICBpZiAocGVyZm9ybWFuY2UgJiYgIWlzLmVxdShwZXJmb3JtYW5jZSwgc3RhdGUucGVyZm9ybWFuY2UsIHNoYWxsb3dMb29zZSkpIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICAgIC4uLnBlcmZvcm1hbmNlXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gU2V0IGxvY2Fsc1xuICAgICAgb25DcmVhdGVkID0gb25DcmVhdGVkQ2FsbGJhY2s7XG4gICAgICBjb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyKGNoaWxkcmVuKSB7XG4gICAgICAvLyBUaGUgcm9vdCBoYXMgdG8gYmUgY29uZmlndXJlZCBiZWZvcmUgaXQgY2FuIGJlIHJlbmRlcmVkXG4gICAgICBpZiAoIWNvbmZpZ3VyZWQpIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdG9yZVxuICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcywgY2FsbGJhY2spIHtcbiAgY29uc3Qgcm9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBmaWJlciA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3QuZmliZXI7XG4gIGlmIChmaWJlcikge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZSkgc3RhdGUuaW50ZXJuYWwuYWN0aXZlID0gZmFsc2U7XG4gICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIobnVsbCwgZmliZXIsIG51bGwsICgpID0+IHtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9zdGF0ZSRnbCwgX3N0YXRlJGdsJHJlbmRlckxpc3RzLCBfc3RhdGUkZ2wyLCBfc3RhdGUkZ2wzO1xuICAgICAgICAgICAgc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiAoX3N0YXRlJGdsJHJlbmRlckxpc3RzID0gX3N0YXRlJGdsLnJlbmRlckxpc3RzKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAoX3N0YXRlJGdsMiA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgICAgIGlmICgoX3N0YXRlJGdsMyA9IHN0YXRlLmdsKSAhPSBudWxsICYmIF9zdGF0ZSRnbDMueHIpIHN0YXRlLnhyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGRpc3Bvc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcm9vdHMuZGVsZXRlKGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGNhbnZhcyk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgc3RhdGUpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwge1xuICAgIGtleTogY29udGFpbmVyLnV1aWQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcbiAgICogIGlmIHRoaXMgaXMgb3VyIGVudmlyb25tZW50LCB0aGVuIHdlIGFyZSBub3QgaW4gcjNmJ3MgcmVuZGVyZXIgYnV0IGluIHJlYWN0LWRvbSwgaXQgd291bGQgdHJpZ2dlclxuICAgKiAgdGhlIFwiUjNGIGhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IVwiIHdhcm5pbmc6XG4gICAqICA8Q2FudmFzPlxuICAgKiAgICB7Y3JlYXRlUG9ydGFsKC4uLil9ICovXG4gIGNvbnN0IHtcbiAgICBldmVudHMsXG4gICAgc2l6ZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSb290ID0gdXNlU3RvcmUoKTtcbiAgY29uc3QgW3JheWNhc3Rlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuUmF5Y2FzdGVyKCkpO1xuICBjb25zdCBbcG9pbnRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMigpKTtcbiAgY29uc3QgaW5qZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soKHJvb3RTdGF0ZSwgaW5qZWN0U3RhdGUpID0+IHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSB7XG4gICAgICAuLi5yb290U3RhdGVcbiAgICB9OyAvLyBhbGwgcHJldiBzdGF0ZSBwcm9wc1xuXG4gICAgLy8gT25seSB0aGUgZmllbGRzIG9mIFwicm9vdFN0YXRlXCIgdGhhdCBkbyBub3QgZGlmZmVyIGZyb20gaW5qZWN0U3RhdGVcbiAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgT2JqZWN0LmtleXMocm9vdFN0YXRlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAvLyBTb21lIHByb3BzIHNob3VsZCBiZSBvZmYtbGltaXRzXG4gICAgICBwcml2YXRlS2V5cy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICAgIC8vIFVubGVzcyB0aGUgaW5qZWN0IGxheWVyIHByb3BzIGlzIHVuZGVmaW5lZCwgdGhlbiB3ZSBrZWVwIHRoZSByb290IGxheWVyXG4gICAgICByb290U3RhdGVba2V5XSAhPT0gaW5qZWN0U3RhdGVba2V5XSAmJiBpbmplY3RTdGF0ZVtrZXldKSB7XG4gICAgICAgIGRlbGV0ZSBpbnRlcnNlY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdmlld3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGluamVjdFN0YXRlICYmIHNpemUpIHtcbiAgICAgIGNvbnN0IGNhbWVyYSA9IGluamVjdFN0YXRlLmNhbWVyYTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcnJpZGUgdmlld3BvcnQsIGlmIHByZXNlbnRcbiAgICAgIHZpZXdwb3J0ID0gcm9vdFN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIG5ldyBUSFJFRS5WZWN0b3IzKCksIHNpemUpO1xuICAgICAgLy8gVXBkYXRlIHRoZSBwb3J0YWwgY2FtZXJhLCBpZiBpdCBkaWZmZXJzIGZyb20gdGhlIHByZXZpb3VzIGxheWVyXG4gICAgICBpZiAoY2FtZXJhICE9PSByb290U3RhdGUuY2FtZXJhKSB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoZSBpbnRlcnNlY3QgY29uc2lzdHMgb2YgdGhlIHByZXZpb3VzIHJvb3Qgc3RhdGVcbiAgICAgIC4uLmludGVyc2VjdCxcbiAgICAgIC8vIFBvcnRhbHMgaGF2ZSB0aGVpciBvd24gc2NlbmUsIHdoaWNoIGZvcm1zIHRoZSByb290LCBhIHJheWNhc3RlciBhbmQgYSBwb2ludGVyXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgLy8gVGhlaXIgcHJldmlvdXMgcm9vdCBpcyB0aGUgbGF5ZXIgYmVmb3JlIGl0XG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICAvLyBFdmVudHMsIHNpemUgYW5kIHZpZXdwb3J0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBpbmplY3QgbGF5ZXJcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5yb290U3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi4oaW5qZWN0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluamVjdFN0YXRlLmV2ZW50cyksXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICAuLi5yb290U3RhdGUudmlld3BvcnQsXG4gICAgICAgIC4uLnZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgLi4ucmVzdFxuICAgIH07XG4gIH0sXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3N0YXRlXSk7XG4gIGNvbnN0IFt1c2VQb3J0YWxTdG9yZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgbWlycm9yZWQgc3RvcmUsIGJhc2VkIG9uIHRoZSBwcmV2aW91cyByb290IHdpdGggYSBmZXcgb3ZlcnJpZGVzIC4uLlxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZSgoc2V0LCBnZXQpID0+ICh7XG4gICAgICAuLi5wcmV2aW91c1N0YXRlLFxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5wcmV2aW91c1N0YXRlLnNpemUsXG4gICAgICAgIC4uLnNpemVcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0LFxuICAgICAgLy8gU2V0IGFuZCBnZXQgcmVmZXIgdG8gdGhpcyByb290LXN0YXRlXG4gICAgICBzZXQsXG4gICAgICBnZXQsXG4gICAgICAvLyBMYXllcnMgYXJlIGFsbG93ZWQgdG8gb3ZlcnJpZGUgZXZlbnRzXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgfSkpO1xuICAgIHJldHVybiBzdG9yZTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3Vic2NyaWJlIHRvIHByZXZpb3VzIHJvb3Qtc3RhdGUgYW5kIGNvcHkgY2hhbmdlcyBvdmVyIHRvIHRoZSBtaXJyb3JlZCBwb3J0YWwtc3RhdGVcbiAgICBjb25zdCB1bnN1YiA9IHByZXZpb3VzUm9vdC5zdWJzY3JpYmUocHJldiA9PiB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShzdGF0ZSA9PiBpbmplY3QocHJldiwgc3RhdGUpKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVuc3ViKCk7XG4gICAgICB1c2VQb3J0YWxTdG9yZS5kZXN0cm95KCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB1c2VQb3J0YWxTdG9yZS5zZXRTdGF0ZShpbmplY3RTdGF0ZSA9PiBpbmplY3QocHJldmlvdXNSb290LmdldFN0YXRlKCksIGluamVjdFN0YXRlKSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbaW5qZWN0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdXNlUG9ydGFsU3RvcmVcbiAgfSwgY2hpbGRyZW4pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbCkpO1xufVxucmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBidW5kbGVUeXBlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gMCA6IDEsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICB2ZXJzaW9uOiBSZWFjdC52ZXJzaW9uXG59KTtcbmNvbnN0IGFjdCA9IFJlYWN0LnVuc3RhYmxlX2FjdDtcblxuZXhwb3J0IHsgdXNlVGhyZWUgYXMgQSwgQmxvY2sgYXMgQiwgdXNlRnJhbWUgYXMgQywgdXNlR3JhcGggYXMgRCwgRXJyb3JCb3VuZGFyeSBhcyBFLCB1c2VMb2FkZXIgYXMgRiwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBhLCBjcmVhdGVSb290IGFzIGIsIGNyZWF0ZUV2ZW50cyBhcyBjLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIGFzIGQsIGV4dGVuZCBhcyBlLCBjb250ZXh0IGFzIGYsIGNyZWF0ZVBvcnRhbCBhcyBnLCByZWNvbmNpbGVyIGFzIGgsIGlzUmVmIGFzIGksIGFwcGx5UHJvcHMgYXMgaiwgZGlzcG9zZSBhcyBrLCBpbnZhbGlkYXRlIGFzIGwsIGFkdmFuY2UgYXMgbSwgYWRkRWZmZWN0IGFzIG4sIGFkZEFmdGVyRWZmZWN0IGFzIG8sIGFkZFRhaWwgYXMgcCwgZmx1c2hHbG9iYWxFZmZlY3RzIGFzIHEsIHJlbmRlciBhcyByLCBnZXRSb290U3RhdGUgYXMgcywgdGhyZWVUeXBlcyBhcyB0LCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgdSwgYWN0IGFzIHYsIGJ1aWxkR3JhcGggYXMgdywgcm9vdHMgYXMgeCwgdXNlSW5zdGFuY2VIYW5kbGUgYXMgeSwgdXNlU3RvcmUgYXMgeiB9O1xuIl0sIm5hbWVzIjpbIlRIUkVFIiwiUmVhY3QiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29uY3VycmVudFJvb3QiLCJjcmVhdGUiLCJSZWNvbmNpbGVyIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInN1c3BlbmQiLCJwcmVsb2FkIiwiY2xlYXIiLCJ0aHJlZVR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY2F0YWxvZ3VlIiwiZXh0ZW5kIiwib2JqZWN0cyIsImFzc2lnbiIsImNyZWF0ZVJlbmRlcmVyIiwiX3Jvb3RzIiwiX2dldEV2ZW50UHJpb3JpdHkiLCJjcmVhdGVJbnN0YW5jZSIsInR5cGUiLCJhcmdzIiwiYXR0YWNoIiwicHJvcHMiLCJyb290IiwibmFtZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnN0YW5jZSIsIm9iamVjdCIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJlcGFyZSIsInByaW1pdGl2ZSIsInRhcmdldCIsIkFycmF5IiwiaXNBcnJheSIsIm1lbW9pemVkUHJvcHMiLCJfX3IzZiIsIkJ1ZmZlckdlb21ldHJ5IiwiTWF0ZXJpYWwiLCJhcHBseVByb3BzJDEiLCJhcHBlbmRDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiY2hpbGQiLCJhZGRlZCIsIl9jaGlsZCRfX3IzZiIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZiIsImlzT2JqZWN0M0QiLCJhZGQiLCJwdXNoIiwicGFyZW50IiwidXBkYXRlSW5zdGFuY2UiLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJpbnNlcnRCZWZvcmUiLCJiZWZvcmVDaGlsZCIsIl9jaGlsZCRfX3IzZjIiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YyIiwiZGlzcGF0Y2hFdmVudCIsInJlc3RTaWJsaW5ncyIsImNoaWxkcmVuIiwiZmlsdGVyIiwic2libGluZyIsImluZGV4IiwiaW5kZXhPZiIsInJlbW92ZVJlY3Vyc2l2ZSIsImFycmF5IiwiZGlzcG9zZSIsImZvckVhY2giLCJyZW1vdmVDaGlsZCIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZjMiLCJfY2hpbGQkX19yM2YzIiwiX2NoaWxkJF9fcjNmNSIsIngiLCJkZXRhY2giLCJfY2hpbGQkX19yM2Y0IiwicmVtb3ZlIiwicmVtb3ZlSW50ZXJhY3Rpdml0eSIsImZpbmRJbml0aWFsUm9vdCIsImlzUHJpbWl0aXZlIiwic2hvdWxkRGlzcG9zZSIsIl9jaGlsZCRfX3IzZjYiLCJjYWxsYmFjayIsImUiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJzd2l0Y2hJbnN0YW5jZSIsIm5ld1Byb3BzIiwiZmliZXIiLCJfaW5zdGFuY2UkX19yM2YiLCJuZXdJbnN0YW5jZSIsImF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kIiwicmF5Y2FzdCIsImV2ZW50Q291bnQiLCJyb290U3RhdGUiLCJnZXRTdGF0ZSIsImludGVybmFsIiwiaW50ZXJhY3Rpb24iLCJhbHRlcm5hdGUiLCJzdGF0ZU5vZGUiLCJyZWYiLCJjdXJyZW50IiwiaGFuZGxlVGV4dEluc3RhbmNlIiwiY29uc29sZSIsIndhcm4iLCJyZWNvbmNpbGVyIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwic3VwcG9ydHNNdXRhdGlvbiIsImlzUHJpbWFyeVJlbmRlcmVyIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwibm9UaW1lb3V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImNvbnRhaW5lciIsInNjZW5lIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJnZXRSb290SG9zdENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsIl9pbnN0YW5jZSRfX3IzZjIiLCJsb2NhbFN0YXRlIiwiQm9vbGVhbiIsImhhbmRsZXJzIiwicHJlcGFyZVVwZGF0ZSIsIl90eXBlIiwib2xkUHJvcHMiLCJfaW5zdGFuY2UkX19yM2YzIiwiYXJnc05ldyIsImNOIiwicmVzdE5ldyIsImFyZ3NPbGQiLCJjTyIsInJlc3RPbGQiLCJzb21lIiwidmFsdWUiLCJkaWZmIiwiZGlmZlByb3BzIiwiY2hhbmdlcyIsImxlbmd0aCIsImNvbW1pdFVwZGF0ZSIsInJlY29uc3RydWN0IiwiX29sZFByb3BzIiwiY29tbWl0TW91bnQiLCJfcHJvcHMiLCJfaW50IiwiX2luc3RhbmNlJF9fcjNmNCIsImdldFB1YmxpY0luc3RhbmNlIiwicHJlcGFyZUZvckNvbW1pdCIsInByZXBhcmVQb3J0YWxNb3VudCIsInJlc2V0QWZ0ZXJDb21taXQiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsImNsZWFyQ29udGFpbmVyIiwiaGlkZUluc3RhbmNlIiwiX2luc3RhbmNlJF9fcjNmNSIsInZpc2libGUiLCJ1bmhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRfX3IzZjYiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwiZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHkiLCJiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIiLCJhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsIm5vdyIsInBlcmZvcm1hbmNlIiwiaXMiLCJmdW4iLCJEYXRlIiwic2NoZWR1bGVUaW1lb3V0Iiwic2V0VGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJhcHBseVByb3BzIiwiX3dpbmRvdyRkb2N1bWVudCIsIl93aW5kb3ckbmF2aWdhdG9yIiwiaGFzQ29sb3JTcGFjZSIsImdldENvbG9yTWFuYWdlbWVudCIsIl9Db2xvck1hbmFnZW1lbnQiLCJDb2xvck1hbmFnZW1lbnQiLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsImRlZiIsImlzUmVmIiwib2JqIiwiaGFzT3duUHJvcGVydHkiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0Iiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZU11dGFibGVDYWxsYmFjayIsImZuIiwidXNlUmVmIiwiQmxvY2siLCJzZXQiLCJQcm9taXNlIiwiRXJyb3JCb3VuZGFyeSIsIkNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwic3RhdGUiLCJlcnJvciIsImNvbXBvbmVudERpZENhdGNoIiwiZXJyIiwicmVuZGVyIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiREVGQVVMVCIsIkRFRkFVTFRTIiwiTWFwIiwiaXNEaWZmU2V0IiwibWVtb2l6ZWQiLCJjYWxjdWxhdGVEcHIiLCJkcHIiLCJfd2luZG93JGRldmljZVBpeGVsUmEiLCJkZXZpY2VQaXhlbFJhdGlvIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldFJvb3RTdGF0ZSIsIl9yM2YiLCJwcmV2aW91c1Jvb3QiLCJhIiwiYXJyIiwic3RyIiwibnVtIiwiYm9vIiwidW5kIiwiZXF1IiwiYiIsImFycmF5cyIsInN0cmljdCIsImlzT2JqIiwiaXNBcnIiLCJpIiwia2V5cyIsImJ1aWxkR3JhcGgiLCJkYXRhIiwibm9kZXMiLCJtYXRlcmlhbHMiLCJ0cmF2ZXJzZSIsIm1hdGVyaWFsIiwicCIsInByZXZpb3VzQXR0YWNoIiwicmVzb2x2ZSIsImtleSIsImluY2x1ZGVzIiwiZW50cmllcyIsInNwbGl0IiwibGFzdCIsInBvcCIsInJlZHVjZSIsImFjYyIsIklOREVYX1JFR0VYIiwidGVzdCIsInJlcGxhY2UiLCJwcmV2aW91cyIsImtOIiwick4iLCJjUCIsImtQIiwiclAiLCJwcmV2aW91c0tleXMiLCJ1bnNoaWZ0IiwicHJvcCIsInN0YXJ0c1dpdGgiLCJfX0RFVl9fIiwicHJvY2VzcyIsIl9yb290JGdldFN0YXRlIiwicHJldkhhbmRsZXJzIiwiaXNFdmVudCIsInNSR0JFbmNvZGluZyIsIlNSR0JDb2xvclNwYWNlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJjdXJyZW50SW5zdGFuY2UiLCJ0YXJnZXRQcm9wIiwicmV2ZXJzZUVudHJpZXMiLCJyZXZlcnNlIiwiY3RvciIsImdldCIsImNvcHkiLCJMYXllcnMiLCJmcm9tQXJyYXkiLCJpc0NvbG9yIiwiQ29sb3IiLCJzZXRTY2FsYXIiLCJtYXNrIiwibGluZWFyIiwiY29udmVydFNSR0JUb0xpbmVhciIsIlRleHR1cmUiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsInRleHR1cmUiLCJnbCIsImNvbG9yU3BhY2UiLCJvdXRwdXRDb2xvclNwYWNlIiwiZW5jb2RpbmciLCJvdXRwdXRFbmNvZGluZyIsInNwbGljZSIsImlzQ2lyY3VsYXIiLCJfaW5zdGFuY2UkX19yM2Y1JHJvb3QiLCJmcmFtZXMiLCJpbnZhbGlkYXRlIiwib25VcGRhdGUiLCJ1cGRhdGVDYW1lcmEiLCJjYW1lcmEiLCJzaXplIiwibWFudWFsIiwibGVmdCIsIndpZHRoIiwicmlnaHQiLCJ0b3AiLCJoZWlnaHQiLCJib3R0b20iLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJtYWtlSWQiLCJldmVudCIsImV2ZW50T2JqZWN0IiwidXVpZCIsImluc3RhbmNlSWQiLCJnZXRFdmVudFByaW9yaXR5IiwiX2dsb2JhbFNjb3BlJGV2ZW50IiwiZ2xvYmFsU2NvcGUiLCJzZWxmIiwicmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUiLCJjYXB0dXJlZE1hcCIsImNhcHR1cmVzIiwicG9pbnRlcklkIiwiY2FwdHVyZURhdGEiLCJkZWxldGUiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJzdG9yZSIsIm8iLCJpbml0aWFsSGl0cyIsImhvdmVyZWQiLCJjcmVhdGVFdmVudHMiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImR4Iiwib2Zmc2V0WCIsImluaXRpYWxDbGljayIsImR5Iiwib2Zmc2V0WSIsInJvdW5kIiwic3FydCIsImZpbHRlclBvaW50ZXJFdmVudHMiLCJpbnRlcnNlY3QiLCJkdXBsaWNhdGVzIiwiU2V0IiwiaW50ZXJzZWN0aW9ucyIsImV2ZW50c09iamVjdHMiLCJyYXljYXN0ZXIiLCJldmVudHMiLCJjb21wdXRlIiwiaGFuZGxlUmF5Y2FzdCIsImVuYWJsZWQiLCJfc3RhdGUkcHJldmlvdXNSb290IiwiaW50ZXJzZWN0T2JqZWN0IiwiaGl0cyIsImZsYXRNYXAiLCJzb3J0IiwiYVN0YXRlIiwiYlN0YXRlIiwiZGlzdGFuY2UiLCJwcmlvcml0eSIsIml0ZW0iLCJpZCIsImhhcyIsImhpdCIsIl9yM2YyIiwidmFsdWVzIiwiaW50ZXJzZWN0aW9uIiwiaGFuZGxlSW50ZXJzZWN0cyIsImRlbHRhIiwic3RvcHBlZCIsInBvaW50ZXIiLCJ1bnByb2plY3RlZFBvaW50IiwiVmVjdG9yMyIsInkiLCJ1bnByb2plY3QiLCJoYXNQb2ludGVyQ2FwdHVyZSIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcCIsIl9pbnRlcm5hbCRjYXB0dXJlZE1hcDIiLCJzZXRQb2ludGVyQ2FwdHVyZSIsImV4dHJhY3RFdmVudFByb3BzIiwicHJvcGVydHkiLCJyYXljYXN0RXZlbnQiLCJyYXkiLCJzdG9wUHJvcGFnYXRpb24iLCJjYXB0dXJlc0ZvclBvaW50ZXIiLCJmcm9tIiwiZmluZCIsImhpZ2hlciIsImNhbmNlbFBvaW50ZXIiLCJjdXJyZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJob3ZlcmVkT2JqIiwib25Qb2ludGVyT3V0Iiwib25Qb2ludGVyTGVhdmUiLCJwb2ludGVyTWlzc2VkIiwib25Qb2ludGVyTWlzc2VkIiwiaGFuZGxlUG9pbnRlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImhhbmRsZUV2ZW50IiwibGFzdEV2ZW50IiwiaXNQb2ludGVyTW92ZSIsImlzQ2xpY2tFdmVudCIsIm1hcCIsIm9uSW50ZXJzZWN0Iiwib25Qb2ludGVyT3ZlciIsIm9uUG9pbnRlckVudGVyIiwiaG92ZXJlZEl0ZW0iLCJvblBvaW50ZXJNb3ZlIiwiaGFuZGxlciIsInByaXZhdGVLZXlzIiwiaXNSZW5kZXJlciIsImNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlU3RvcmUiLCJhZHZhbmNlIiwicG9zaXRpb24iLCJkZWZhdWx0VGFyZ2V0IiwidGVtcFRhcmdldCIsImdldEN1cnJlbnRWaWV3cG9ydCIsImdldFdvcmxkUG9zaXRpb24iLCJkaXN0YW5jZVRvIiwiem9vbSIsImZhY3RvciIsImZvdiIsIlBJIiwiaCIsInRhbiIsInciLCJwZXJmb3JtYW5jZVRpbWVvdXQiLCJzZXRQZXJmb3JtYW5jZUN1cnJlbnQiLCJWZWN0b3IyIiwiY29ubmVjdGVkIiwieHIiLCJ0aW1lc3RhbXAiLCJydW5HbG9iYWxFZmZlY3RzIiwibGVnYWN5IiwiZmxhdCIsImNvbnRyb2xzIiwiY2xvY2siLCJDbG9jayIsIm1vdXNlIiwiZnJhbWVsb29wIiwiZGVib3VuY2UiLCJyZWdyZXNzIiwidXBkYXRlU3R5bGUiLCJ2aWV3cG9ydCIsImluaXRpYWxEcHIiLCJzZXRFdmVudHMiLCJzZXRTaXplIiwic2V0RHByIiwicmVzb2x2ZWQiLCJzZXRGcmFtZWxvb3AiLCJzdG9wIiwiZWxhcHNlZFRpbWUiLCJzdGFydCIsImFjdGl2ZSIsImNyZWF0ZVJlZiIsInN1YnNjcmliZXJzIiwic3Vic2NyaWJlIiwicyIsIm9sZFNpemUiLCJvbGREcHIiLCJvbGRDYW1lcmEiLCJfc2l6ZSR1cGRhdGVTdHlsZSIsInNldFBpeGVsUmF0aW8iLCJIVE1MQ2FudmFzRWxlbWVudCIsImRvbUVsZW1lbnQiLCJjcmVhdGVTdWJzIiwic3VicyIsInN1YiIsImdsb2JhbEVmZmVjdHMiLCJnbG9iYWxBZnRlckVmZmVjdHMiLCJnbG9iYWxUYWlsRWZmZWN0cyIsImFkZEVmZmVjdCIsImFkZEFmdGVyRWZmZWN0IiwiYWRkVGFpbCIsInJ1biIsImVmZmVjdHMiLCJmbHVzaEdsb2JhbEVmZmVjdHMiLCJzdWJzY3JpcHRpb24iLCJyZW5kZXIkMSIsImZyYW1lIiwiZ2V0RGVsdGEiLCJvbGRUaW1lIiwiY3JlYXRlTG9vcCIsInJvb3RzIiwicnVubmluZyIsInJlcGVhdCIsImxvb3AiLCJfc3RhdGUkZ2wkeHIiLCJpc1ByZXNlbnRpbmciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIl9zdGF0ZSRnbCR4cjIiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsInVzZVN0b3JlIiwidXNlQ29udGV4dCIsInVzZVRocmVlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwidXNlRnJhbWUiLCJyZW5kZXJQcmlvcml0eSIsInVzZUdyYXBoIiwidXNlTWVtbyIsIm1lbW9pemVkTG9hZGVycyIsIldlYWtNYXAiLCJsb2FkaW5nRm4iLCJleHRlbnNpb25zIiwib25Qcm9ncmVzcyIsIlByb3RvIiwiaW5wdXQiLCJsb2FkZXIiLCJhbGwiLCJyZXMiLCJyZWplY3QiLCJsb2FkIiwibWVzc2FnZSIsImZpbmFsbHkiLCJ1c2VMb2FkZXIiLCJyZXN1bHRzIiwiZXF1YWwiLCJzaGFsbG93TG9vc2UiLCJjcmVhdGVSZW5kZXJlckluc3RhbmNlIiwiY2FudmFzIiwiY3VzdG9tUmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwicG93ZXJQcmVmZXJlbmNlIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJjb21wdXRlSW5pdGlhbFNpemUiLCJkZWZhdWx0U2l6ZSIsImRlZmF1bHRTdHlsZSIsInBhcmVudEVsZW1lbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJPZmZzY3JlZW5DYW52YXMiLCJjcmVhdGVSb290IiwicHJldlJvb3QiLCJwcmV2RmliZXIiLCJwcmV2U3RvcmUiLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVwb3J0RXJyb3IiLCJjcmVhdGVDb250YWluZXIiLCJvbkNyZWF0ZWQiLCJjb25maWd1cmVkIiwibGFzdENhbWVyYSIsImNvbmZpZ3VyZSIsImdsQ29uZmlnIiwicHJvcHNTaXplIiwic2NlbmVPcHRpb25zIiwib25DcmVhdGVkQ2FsbGJhY2siLCJzaGFkb3dzIiwib3J0aG9ncmFwaGljIiwicmF5Y2FzdE9wdGlvbnMiLCJjYW1lcmFPcHRpb25zIiwiUmF5Y2FzdGVyIiwicGFyYW1zIiwib3B0aW9ucyIsImlzQ2FtZXJhIiwiQ2FtZXJhIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ6Iiwicm90YXRpb24iLCJsb29rQXQiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJoYW5kbGVTZXNzaW9uQ2hhbmdlIiwic2V0QW5pbWF0aW9uTG9vcCIsImNvbm5lY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzaGFkb3dNYXAiLCJvbGRFbmFibGVkIiwib2xkVHlwZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJfdHlwZXMkc2hhZG93cyIsInR5cGVzIiwiYmFzaWMiLCJCYXNpY1NoYWRvd01hcCIsInBlcmNlbnRhZ2UiLCJQQ0ZTaGFkb3dNYXAiLCJzb2Z0IiwidmFyaWFuY2UiLCJWU01TaGFkb3dNYXAiLCJuZWVkc1VwZGF0ZSIsImxlZ2FjeU1vZGUiLCJMaW5lYXJFbmNvZGluZyIsInRvbmVNYXBwaW5nIiwiTm9Ub25lTWFwcGluZyIsIkFDRVNGaWxtaWNUb25lTWFwcGluZyIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNvbmZpZyIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwidXNlQ2FsbGJhY2siLCJpbmplY3RTdGF0ZSIsInVzZVBvcnRhbFN0b3JlIiwicHJldmlvdXNTdGF0ZSIsInVuc3ViIiwicHJldiIsInNldFN0YXRlIiwiZGVzdHJveSIsIkZyYWdtZW50IiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJ2ZXJzaW9uIiwiYWN0IiwidW5zdGFibGVfYWN0IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiYyIsImQiLCJmIiwiZyIsImoiLCJrIiwibCIsIm0iLCJuIiwicSIsInIiLCJ0IiwidSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   act: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   context: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)\n/* harmony export */ });\n/* harmony import */ var _index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-29b7121b.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/web.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>(0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(Bridge, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                set: setError\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n                fallback: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                    set: setBlock\n                })\n            }, children))));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_index_29b7121b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        }\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"canvas\", {\n        ref: canvasRef,\n        style: {\n            display: \"block\"\n        }\n    }, fallback)));\n});\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CanvasImpl, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, props, {\n        ref: ref\n    })));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNE47QUFDeVI7QUFDM2I7QUFDM0I7QUFDQTtBQUNZO0FBQ2dCO0FBQ3ZCO0FBQ25CO0FBQ1M7QUFDUDtBQUNJO0FBRXZCLE1BQU1zRSxhQUFhO0lBQ2pCQyxTQUFTO1FBQUM7UUFBUztLQUFNO0lBQ3pCQyxlQUFlO1FBQUM7UUFBZTtLQUFNO0lBQ3JDQyxlQUFlO1FBQUM7UUFBWTtLQUFNO0lBQ2xDQyxTQUFTO1FBQUM7UUFBUztLQUFLO0lBQ3hCQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxhQUFhO1FBQUM7UUFBYTtLQUFLO0lBQ2hDQyxnQkFBZ0I7UUFBQztRQUFnQjtLQUFLO0lBQ3RDQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxpQkFBaUI7UUFBQztRQUFpQjtLQUFLO0lBQ3hDQyxzQkFBc0I7UUFBQztRQUFzQjtLQUFLO0FBQ3BEO0FBRUEsc0NBQXNDLEdBQ3RDLFNBQVNDLG9CQUFvQkMsS0FBSztJQUNoQyxNQUFNLEVBQ0pDLGFBQWEsRUFDZCxHQUFHbEYseURBQVlBLENBQUNpRjtJQUNqQixPQUFPO1FBQ0xFLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxTQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsUUFBUTtZQUM1Qix1REFBdUQ7WUFDdkQsNEZBQTRGO1lBQzVGRCxNQUFNRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osTUFBTUssT0FBTyxHQUFHSixNQUFNSyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBRVAsQ0FBQUEsTUFBTVEsT0FBTyxHQUFHUCxNQUFNSyxJQUFJLENBQUNHLE1BQU0sSUFBSSxJQUFJO1lBQ3ZHUixNQUFNUyxTQUFTLENBQUNDLGFBQWEsQ0FBQ1YsTUFBTUUsT0FBTyxFQUFF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QUFPO1FBQ2hDLElBQUlzRCxRQUFRLE9BQU8sSUFBTXZKLHlEQUFzQkEsQ0FBQ3VKO0lBQ2xELEdBQUcsRUFBRTtJQUVMLCtFQUErRTtJQUMvRSxzRUFBc0U7SUFDdEUsTUFBTU8sZ0JBQWdCdkMsY0FBYyxTQUFTO0lBQzdDLE9BQU8sV0FBVyxHQUFFdkUsZ0RBQW1CLENBQUMsT0FBT0QsOEVBQVFBLENBQUM7UUFDdERnSCxLQUFLakI7UUFDTHpCLE9BQU87WUFDTDJDLFVBQVU7WUFDVm5GLE9BQU87WUFDUEUsUUFBUTtZQUNSa0YsVUFBVTtZQUNWSDtZQUNBLEdBQUd6QyxLQUFLO1FBQ1Y7SUFDRixHQUFHZSxRQUFRLFdBQVcsR0FBRXBGLGdEQUFtQixDQUFDLE9BQU87UUFDakQrRyxLQUFLdkI7UUFDTG5CLE9BQU87WUFDTHhDLE9BQU87WUFDUEUsUUFBUTtRQUNWO0lBQ0YsR0FBRyxXQUFXLEdBQUUvQixnREFBbUIsQ0FBQyxVQUFVO1FBQzVDK0csS0FBS25CO1FBQ0x2QixPQUFPO1lBQ0w2QyxTQUFTO1FBQ1g7SUFDRixHQUFHL0M7QUFDTDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1GLFNBQVMsV0FBVyxHQUFFakUsNkNBQWdCLENBQUMsU0FBU21ILGNBQWMvQixLQUFLLEVBQUUyQixHQUFHO0lBQzVFLE9BQU8sV0FBVyxHQUFFL0csZ0RBQW1CLENBQUNHLG1EQUFhQSxFQUFFLE1BQU0sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQytELFlBQVloRSw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdxRixPQUFPO1FBQzVIMkIsS0FBS0E7SUFDUDtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzPzc5Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyBhcyBjcmVhdGVFdmVudHMsIGUgYXMgZXh0ZW5kLCB1IGFzIHVzZU11dGFibGVDYWxsYmFjaywgYSBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBiIGFzIGNyZWF0ZVJvb3QsIGkgYXMgaXNSZWYsIEUgYXMgRXJyb3JCb3VuZGFyeSwgQiBhcyBCbG9jaywgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlIH0gZnJvbSAnLi9pbmRleC0yOWI3MTIxYi5lc20uanMnO1xuZXhwb3J0IHsgdCBhcyBSZWFjdFRocmVlRmliZXIsIHggYXMgX3Jvb3RzLCB2IGFzIGFjdCwgbyBhcyBhZGRBZnRlckVmZmVjdCwgbiBhcyBhZGRFZmZlY3QsIHAgYXMgYWRkVGFpbCwgbSBhcyBhZHZhbmNlLCBqIGFzIGFwcGx5UHJvcHMsIHcgYXMgYnVpbGRHcmFwaCwgZiBhcyBjb250ZXh0LCBjIGFzIGNyZWF0ZUV2ZW50cywgZyBhcyBjcmVhdGVQb3J0YWwsIGIgYXMgY3JlYXRlUm9vdCwgayBhcyBkaXNwb3NlLCBlIGFzIGV4dGVuZCwgcSBhcyBmbHVzaEdsb2JhbEVmZmVjdHMsIHMgYXMgZ2V0Um9vdFN0YXRlLCBsIGFzIGludmFsaWRhdGUsIGggYXMgcmVjb25jaWxlciwgciBhcyByZW5kZXIsIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgQyBhcyB1c2VGcmFtZSwgRCBhcyB1c2VHcmFwaCwgeSBhcyB1c2VJbnN0YW5jZUhhbmRsZSwgRiBhcyB1c2VMb2FkZXIsIHogYXMgdXNlU3RvcmUsIEEgYXMgdXNlVGhyZWUgfSBmcm9tICcuL2luZGV4LTI5YjcxMjFiLmVzbS5qcyc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgdXNlTWVhc3VyZSBmcm9tICdyZWFjdC11c2UtbWVhc3VyZSc7XG5pbXBvcnQgeyBGaWJlclByb3ZpZGVyLCB1c2VDb250ZXh0QnJpZGdlIH0gZnJvbSAnaXRzLWZpbmUnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cyc7XG5pbXBvcnQgJ3p1c3RhbmQnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcbmltcG9ydCAnc3VzcGVuZC1yZWFjdCc7XG5cbmNvbnN0IERPTV9FVkVOVFMgPSB7XG4gIG9uQ2xpY2s6IFsnY2xpY2snLCBmYWxzZV0sXG4gIG9uQ29udGV4dE1lbnU6IFsnY29udGV4dG1lbnUnLCBmYWxzZV0sXG4gIG9uRG91YmxlQ2xpY2s6IFsnZGJsY2xpY2snLCBmYWxzZV0sXG4gIG9uV2hlZWw6IFsnd2hlZWwnLCB0cnVlXSxcbiAgb25Qb2ludGVyRG93bjogWydwb2ludGVyZG93bicsIHRydWVdLFxuICBvblBvaW50ZXJVcDogWydwb2ludGVydXAnLCB0cnVlXSxcbiAgb25Qb2ludGVyTGVhdmU6IFsncG9pbnRlcmxlYXZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlck1vdmU6IFsncG9pbnRlcm1vdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyQ2FuY2VsOiBbJ3BvaW50ZXJjYW5jZWwnLCB0cnVlXSxcbiAgb25Mb3N0UG9pbnRlckNhcHR1cmU6IFsnbG9zdHBvaW50ZXJjYXB0dXJlJywgdHJ1ZV1cbn07XG5cbi8qKiBEZWZhdWx0IFIzRiBldmVudCBtYW5hZ2VyIGZvciB3ZWIgKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50ZXJFdmVudHMoc3RvcmUpIHtcbiAgY29uc3Qge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfSA9IGNyZWF0ZUV2ZW50cyhzdG9yZSk7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHk6IDEsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBjb21wdXRlKGV2ZW50LCBzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC83ODJcbiAgICAgIC8vIEV2ZW50cyB0cmlnZ2VyIG91dHNpZGUgb2YgY2FudmFzIHdoZW4gbW92ZWQsIHVzZSBvZmZzZXRYL1kgYnkgZGVmYXVsdCBhbmQgYWxsb3cgb3ZlcnJpZGVzXG4gICAgICBzdGF0ZS5wb2ludGVyLnNldChldmVudC5vZmZzZXRYIC8gc3RhdGUuc2l6ZS53aWR0aCAqIDIgLSAxLCAtKGV2ZW50Lm9mZnNldFkgLyBzdGF0ZS5zaXplLmhlaWdodCkgKiAyICsgMSk7XG4gICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgIH0sXG4gICAgY29ubmVjdGVkOiB1bmRlZmluZWQsXG4gICAgaGFuZGxlcnM6IE9iamVjdC5rZXlzKERPTV9FVkVOVFMpLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogaGFuZGxlUG9pbnRlcihrZXkpXG4gICAgfSksIHt9KSxcbiAgICB1cGRhdGU6ICgpID0+IHtcbiAgICAgIHZhciBfaW50ZXJuYWwkbGFzdEV2ZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBldmVudHMsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICgoX2ludGVybmFsJGxhc3RFdmVudCA9IGludGVybmFsLmxhc3RFdmVudCkgIT0gbnVsbCAmJiBfaW50ZXJuYWwkbGFzdEV2ZW50LmN1cnJlbnQgJiYgZXZlbnRzLmhhbmRsZXJzKSBldmVudHMuaGFuZGxlcnMub25Qb2ludGVyTW92ZShpbnRlcm5hbC5sYXN0RXZlbnQuY3VycmVudCk7XG4gICAgfSxcbiAgICBjb25uZWN0OiB0YXJnZXQgPT4ge1xuICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICBjb25uZWN0ZWQ6IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVycyA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICBjb25zdCBbZXZlbnROYW1lLCBwYXNzaXZlXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQsIHtcbiAgICAgICAgICBwYXNzaXZlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0OiAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNldCxcbiAgICAgICAgZXZlbnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmIChldmVudHMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzMjtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMyID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVyczIgOiBbXSkuZm9yRWFjaCgoW25hbWUsIGV2ZW50XSkgPT4ge1xuICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzLmNvbm5lY3RlZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBbZXZlbnROYW1lXSA9IERPTV9FVkVOVFNbbmFtZV07XG4gICAgICAgICAgICBldmVudHMuY29ubmVjdGVkLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgQ2FudmFzSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICBnbCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBsaW5lYXIsXG4gICAgICAgIGZsYXQsXG4gICAgICAgIGxlZ2FjeSxcbiAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgIGRwcixcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCcmlkZ2UsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgc2V0OiBzZXRFcnJvclxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJsb2NrLCB7XG4gICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICB9KVxuICAgICAgfSwgY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH0sIGZhbGxiYWNrKSkpO1xufSk7XG5cbi8qKlxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xuICovXG5jb25zdCBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZpYmVyUHJvdmlkZXIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhbnZhc0ltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKSk7XG59KTtcblxuZXhwb3J0IHsgQ2FudmFzLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGV2ZW50cyB9O1xuIl0sIm5hbWVzIjpbImMiLCJjcmVhdGVFdmVudHMiLCJlIiwiZXh0ZW5kIiwidSIsInVzZU11dGFibGVDYWxsYmFjayIsImEiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiYiIsImNyZWF0ZVJvb3QiLCJpIiwiaXNSZWYiLCJFIiwiRXJyb3JCb3VuZGFyeSIsIkIiLCJCbG9jayIsImQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwidCIsIlJlYWN0VGhyZWVGaWJlciIsIngiLCJfcm9vdHMiLCJ2IiwiYWN0IiwibyIsImFkZEFmdGVyRWZmZWN0IiwibiIsImFkZEVmZmVjdCIsInAiLCJhZGRUYWlsIiwibSIsImFkdmFuY2UiLCJqIiwiYXBwbHlQcm9wcyIsInciLCJidWlsZEdyYXBoIiwiZiIsImNvbnRleHQiLCJnIiwiY3JlYXRlUG9ydGFsIiwiayIsImRpc3Bvc2UiLCJxIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwicyIsImdldFJvb3RTdGF0ZSIsImwiLCJpbnZhbGlkYXRlIiwiaCIsInJlY29uY2lsZXIiLCJyIiwicmVuZGVyIiwiQyIsInVzZUZyYW1lIiwiRCIsInVzZUdyYXBoIiwieSIsInVzZUluc3RhbmNlSGFuZGxlIiwiRiIsInVzZUxvYWRlciIsInoiLCJ1c2VTdG9yZSIsIkEiLCJ1c2VUaHJlZSIsIl9leHRlbmRzIiwiUmVhY3QiLCJUSFJFRSIsInVzZU1lYXN1cmUiLCJGaWJlclByb3ZpZGVyIiwidXNlQ29udGV4dEJyaWRnZSIsIkRPTV9FVkVOVFMiLCJvbkNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uRG91YmxlQ2xpY2siLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyTGVhdmUiLCJvblBvaW50ZXJNb3ZlIiwib25Qb2ludGVyQ2FuY2VsIiwib25Mb3N0UG9pbnRlckNhcHR1cmUiLCJjcmVhdGVQb2ludGVyRXZlbnRzIiwic3RvcmUiLCJoYW5kbGVQb2ludGVyIiwicHJpb3JpdHkiLCJlbmFibGVkIiwiY29tcHV0ZSIsImV2ZW50Iiwic3RhdGUiLCJwcmV2aW91cyIsInBvaW50ZXIiLCJzZXQiLCJvZmZzZXRYIiwic2l6ZSIsIndpZHRoIiwib2Zmc2V0WSIsImhlaWdodCIsInJheWNhc3RlciIsInNldEZyb21DYW1lcmEiLCJjYW1lcmEiLCJjb25uZWN0ZWQiLCJ1bmRlZmluZWQiLCJoYW5kbGVycyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJ1cGRhdGUiLCJfaW50ZXJuYWwkbGFzdEV2ZW50IiwiZXZlbnRzIiwiaW50ZXJuYWwiLCJnZXRTdGF0ZSIsImxhc3RFdmVudCIsImN1cnJlbnQiLCJjb25uZWN0IiwidGFyZ2V0IiwiX2V2ZW50cyRoYW5kbGVycyIsImRpc2Nvbm5lY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsIm5hbWUiLCJldmVudE5hbWUiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9ldmVudHMkaGFuZGxlcnMyIiwiSFRNTEVsZW1lbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQ2FudmFzSW1wbCIsImZvcndhcmRSZWYiLCJDYW52YXMiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwicmVzaXplIiwic3R5bGUiLCJnbCIsImV2ZW50U291cmNlIiwiZXZlbnRQcmVmaXgiLCJzaGFkb3dzIiwibGluZWFyIiwiZmxhdCIsImxlZ2FjeSIsIm9ydGhvZ3JhcGhpYyIsImZyYW1lbG9vcCIsImRwciIsInBlcmZvcm1hbmNlIiwic2NlbmUiLCJvblBvaW50ZXJNaXNzZWQiLCJvbkNyZWF0ZWQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsInVzZU1lbW8iLCJCcmlkZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJSZWN0Iiwic2Nyb2xsIiwiZGVib3VuY2UiLCJjYW52YXNSZWYiLCJ1c2VSZWYiLCJkaXZSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiaGFuZGxlUG9pbnRlck1pc3NlZCIsImJsb2NrIiwic2V0QmxvY2siLCJ1c2VTdGF0ZSIsImVycm9yIiwic2V0RXJyb3IiLCJyb290IiwiY2FudmFzIiwiY29uZmlndXJlIiwiYXJncyIsInNldEV2ZW50cyIsImNyZWF0ZUVsZW1lbnQiLCJTdXNwZW5zZSIsInVzZUVmZmVjdCIsInBvaW50ZXJFdmVudHMiLCJyZWYiLCJwb3NpdGlvbiIsIm92ZXJmbG93IiwiZGlzcGxheSIsIkNhbnZhc1dyYXBwZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyCollider: () => (/* binding */ AnyCollider),\n/* harmony export */   BallCollider: () => (/* binding */ BallCollider),\n/* harmony export */   CapsuleCollider: () => (/* binding */ CapsuleCollider),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   ConeCollider: () => (/* binding */ ConeCollider),\n/* harmony export */   ConvexHullCollider: () => (/* binding */ ConvexHullCollider),\n/* harmony export */   CuboidCollider: () => (/* binding */ CuboidCollider),\n/* harmony export */   CylinderCollider: () => (/* binding */ CylinderCollider),\n/* harmony export */   HeightfieldCollider: () => (/* binding */ HeightfieldCollider),\n/* harmony export */   InstancedRigidBodies: () => (/* binding */ InstancedRigidBodies),\n/* harmony export */   MeshCollider: () => (/* binding */ MeshCollider),\n/* harmony export */   Physics: () => (/* binding */ Physics),\n/* harmony export */   RapierCollider: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   RapierRigidBody: () => (/* reexport safe */ _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RoundConeCollider: () => (/* binding */ RoundConeCollider),\n/* harmony export */   RoundCuboidCollider: () => (/* binding */ RoundCuboidCollider),\n/* harmony export */   RoundCylinderCollider: () => (/* binding */ RoundCylinderCollider),\n/* harmony export */   TrimeshCollider: () => (/* binding */ TrimeshCollider),\n/* harmony export */   euler: () => (/* binding */ euler),\n/* harmony export */   interactionGroups: () => (/* binding */ interactionGroups),\n/* harmony export */   quat: () => (/* binding */ quat),\n/* harmony export */   useAfterPhysicsStep: () => (/* binding */ useAfterPhysicsStep),\n/* harmony export */   useBeforePhysicsStep: () => (/* binding */ useBeforePhysicsStep),\n/* harmony export */   useFixedJoint: () => (/* binding */ useFixedJoint),\n/* harmony export */   useImpulseJoint: () => (/* binding */ useImpulseJoint),\n/* harmony export */   usePrismaticJoint: () => (/* binding */ usePrismaticJoint),\n/* harmony export */   useRapier: () => (/* binding */ useRapier),\n/* harmony export */   useRevoluteJoint: () => (/* binding */ useRevoluteJoint),\n/* harmony export */   useRopeJoint: () => (/* binding */ useRopeJoint),\n/* harmony export */   useSphericalJoint: () => (/* binding */ useSphericalJoint),\n/* harmony export */   useSpringJoint: () => (/* binding */ useSpringJoint),\n/* harmony export */   vec3: () => (/* binding */ vec3)\n/* harmony export */ });\n/* harmony import */ var _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-29b7121b.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n\n\n\n\n\n\n\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nconst _quaternion = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Euler();\nconst _vector3 = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nnew three__WEBPACK_IMPORTED_MODULE_2__.Object3D();\nconst _matrix4 = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4();\nconst _position = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nconst _rotation = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\nconst _scale = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\nconst vectorArrayToVector3 = (arr)=>{\n    const [x, y, z] = arr;\n    return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\nconst rapierQuaternionToQuaternion = ({ x, y, z, w })=>_quaternion.set(x, y, z, w);\nconst vector3ToRapierVector = (v)=>{\n    if (Array.isArray(v)) {\n        return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v[0], v[1], v[2]);\n    } else if (typeof v === \"number\") {\n        return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(v, v, v);\n    } else {\n        const threeVector3 = v;\n        return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Vector3(threeVector3.x, threeVector3.y, threeVector3.z);\n    }\n};\nconst quaternionToRapierQuaternion = (v)=>{\n    if (Array.isArray(v)) {\n        return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v[0], v[1], v[2], v[3]);\n    } else {\n        return new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.Quaternion(v.x, v.y, v.z, v.w);\n    }\n};\nconst rigidBodyTypeMap = {\n    fixed: 1,\n    dynamic: 0,\n    kinematicPosition: 2,\n    kinematicVelocity: 3\n};\nconst rigidBodyTypeFromString = (type)=>rigidBodyTypeMap[type];\nconst scaleVertices = (vertices, scale)=>{\n    const scaledVerts = Array.from(vertices);\n    for(let i = 0; i < vertices.length / 3; i++){\n        scaledVerts[i * 3] *= scale.x;\n        scaledVerts[i * 3 + 1] *= scale.y;\n        scaledVerts[i * 3 + 2] *= scale.z;\n    }\n    return scaledVerts;\n};\nconst vectorToTuple = (v)=>{\n    if (!v) return [\n        0\n    ];\n    if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Quaternion) {\n        return [\n            v.x,\n            v.y,\n            v.z,\n            v.w\n        ];\n    }\n    if (v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Vector3 || v instanceof three__WEBPACK_IMPORTED_MODULE_2__.Euler) {\n        return [\n            v.x,\n            v.y,\n            v.z\n        ];\n    }\n    if (Array.isArray(v)) {\n        return v;\n    }\n    return [\n        v\n    ];\n};\nfunction useConst(initialValue) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    if (ref.current === undefined) {\n        ref.current = {\n            value: typeof initialValue === \"function\" ? initialValue() : initialValue\n        };\n    }\n    return ref.current.value;\n}\nconst useRaf = (callback)=>{\n    const cb = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(callback);\n    const raf = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const lastFrame = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        cb.current = callback;\n    }, [\n        callback\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loop = ()=>{\n            const now = performance.now();\n            const delta = now - lastFrame.current;\n            raf.current = requestAnimationFrame(loop);\n            cb.current(delta / 1000);\n            lastFrame.current = now;\n        };\n        raf.current = requestAnimationFrame(loop);\n        return ()=>cancelAnimationFrame(raf.current);\n    }, []);\n};\nconst UseFrameStepper = ({ onStep, updatePriority })=>{\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)((_, dt)=>{\n        onStep(dt);\n    }, updatePriority);\n    return null;\n};\nconst RafStepper = ({ onStep })=>{\n    useRaf((dt)=>{\n        onStep(dt);\n    });\n    return null;\n};\nconst FrameStepper = ({ onStep, type, updatePriority })=>{\n    return type === \"independent\" ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RafStepper, {\n        onStep: onStep\n    }) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(UseFrameStepper, {\n        onStep: onStep,\n        updatePriority: updatePriority\n    });\n};\nvar FrameStepper$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FrameStepper);\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nconst _excluded$2 = [\n    \"mass\",\n    \"linearDamping\",\n    \"angularDamping\",\n    \"type\",\n    \"onCollisionEnter\",\n    \"onCollisionExit\",\n    \"onIntersectionEnter\",\n    \"onIntersectionExit\",\n    \"onContactForce\",\n    \"children\",\n    \"canSleep\",\n    \"ccd\",\n    \"gravityScale\"\n];\nconst scaleColliderArgs = (shape, args, scale)=>{\n    const newArgs = args.slice(); // Heightfield uses a vector\n    if (shape === \"heightfield\") {\n        const s = newArgs[3];\n        s.x *= scale.x;\n        s.x *= scale.y;\n        s.x *= scale.z;\n        return newArgs;\n    } // Trimesh and convex scale the vertices\n    if (shape === \"trimesh\" || shape === \"convexHull\") {\n        newArgs[0] = scaleVertices(newArgs[0], scale);\n        return newArgs;\n    } // Prepfill with some extra\n    const scaleArray = [\n        scale.x,\n        scale.y,\n        scale.z,\n        scale.x,\n        scale.x\n    ];\n    return newArgs.map((arg, index)=>scaleArray[index] * arg);\n};\nconst createColliderFromOptions = (options, world, scale, getRigidBody)=>{\n    const scaledArgs = scaleColliderArgs(options.shape, options.args, scale); // @ts-ignore\n    const desc = _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc[options.shape](...scaledArgs);\n    return world.createCollider(desc, getRigidBody === null || getRigidBody === void 0 ? void 0 : getRigidBody());\n};\nconst immutableColliderOptions = [\n    \"shape\",\n    \"args\"\n];\nconst massPropertiesConflictError = \"Please pick ONLY ONE of the `density`, `mass` and `massProperties` options.\";\nconst setColliderMassOptions = (collider, options)=>{\n    if (options.density !== undefined) {\n        if (options.mass !== undefined || options.massProperties !== undefined) {\n            throw new Error(massPropertiesConflictError);\n        }\n        collider.setDensity(options.density);\n        return;\n    }\n    if (options.mass !== undefined) {\n        if (options.massProperties !== undefined) {\n            throw new Error(massPropertiesConflictError);\n        }\n        collider.setMass(options.mass);\n        return;\n    }\n    if (options.massProperties !== undefined) {\n        collider.setMassProperties(options.massProperties.mass, options.massProperties.centerOfMass, options.massProperties.principalAngularInertia, options.massProperties.angularInertiaLocalFrame);\n    }\n};\nconst mutableColliderOptions = {\n    sensor: (collider, value)=>{\n        collider.setSensor(value);\n    },\n    collisionGroups: (collider, value)=>{\n        collider.setCollisionGroups(value);\n    },\n    solverGroups: (collider, value)=>{\n        collider.setSolverGroups(value);\n    },\n    friction: (collider, value)=>{\n        collider.setFriction(value);\n    },\n    frictionCombineRule: (collider, value)=>{\n        collider.setFrictionCombineRule(value);\n    },\n    restitution: (collider, value)=>{\n        collider.setRestitution(value);\n    },\n    restitutionCombineRule: (collider, value)=>{\n        collider.setRestitutionCombineRule(value);\n    },\n    // To make sure the options all mutable options are listed\n    quaternion: ()=>{},\n    position: ()=>{},\n    rotation: ()=>{},\n    scale: ()=>{}\n};\nconst mutableColliderOptionKeys = Object.keys(mutableColliderOptions);\nconst setColliderOptions = (collider, options, states)=>{\n    const state = states.get(collider.handle);\n    if (state) {\n        var _state$worldParent;\n        // Update collider position based on the object's position\n        const parentWorldScale = state.object.parent.getWorldScale(_vector3);\n        const parentInvertedWorldMatrix = (_state$worldParent = state.worldParent) === null || _state$worldParent === void 0 ? void 0 : _state$worldParent.matrixWorld.clone().invert();\n        state.object.updateWorldMatrix(true, false);\n        _matrix4.copy(state.object.matrixWorld);\n        if (parentInvertedWorldMatrix) {\n            _matrix4.premultiply(parentInvertedWorldMatrix);\n        }\n        _matrix4.decompose(_position, _rotation, _scale);\n        if (collider.parent()) {\n            collider.setTranslationWrtParent({\n                x: _position.x * parentWorldScale.x,\n                y: _position.y * parentWorldScale.y,\n                z: _position.z * parentWorldScale.z\n            });\n            collider.setRotationWrtParent(_rotation);\n        } else {\n            collider.setTranslation({\n                x: _position.x * parentWorldScale.x,\n                y: _position.y * parentWorldScale.y,\n                z: _position.z * parentWorldScale.z\n            });\n            collider.setRotation(_rotation);\n        }\n        mutableColliderOptionKeys.forEach((key)=>{\n            if (key in options) {\n                const option = options[key];\n                mutableColliderOptions[key](collider, option, options);\n            }\n        }); // handle mass separately, because the assignments\n        // are exclusive.\n        setColliderMassOptions(collider, options);\n    }\n};\nconst useUpdateColliderOptions = (getCollider, props, states)=>{\n    // TODO: Improve this, split each prop into its own effect\n    const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>mutableColliderOptionKeys.flatMap((key)=>{\n            return vectorToTuple(props[key]);\n        }), [\n        props\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const collider = getCollider();\n        setColliderOptions(collider, props, states);\n    }, [\n        ...mutablePropsAsFlatArray,\n        getCollider\n    ]);\n};\nconst isChildOfMeshCollider = (child)=>{\n    let flag = false;\n    child.traverseAncestors((a)=>{\n        if (a.userData.r3RapierType === \"MeshCollider\") flag = true;\n    });\n    return flag;\n};\nconst createColliderState = (collider, object, rigidBodyObject)=>{\n    return {\n        collider,\n        worldParent: rigidBodyObject || undefined,\n        object\n    };\n};\nconst autoColliderMap = {\n    cuboid: \"cuboid\",\n    ball: \"ball\",\n    hull: \"convexHull\",\n    trimesh: \"trimesh\"\n};\nconst createColliderPropsFromChildren = ({ object, ignoreMeshColliders: _ignoreMeshColliders = true, options })=>{\n    const childColliderProps = [];\n    object.updateWorldMatrix(true, false);\n    const invertedParentMatrixWorld = object.matrixWorld.clone().invert();\n    const colliderFromChild = (child)=>{\n        if (\"isMesh\" in child) {\n            if (_ignoreMeshColliders && isChildOfMeshCollider(child)) return;\n            const worldScale = child.getWorldScale(_scale);\n            const shape = autoColliderMap[options.colliders || \"cuboid\"];\n            child.updateWorldMatrix(true, false);\n            _matrix4.copy(child.matrixWorld).premultiply(invertedParentMatrixWorld).decompose(_position, _rotation, _scale);\n            const rotationEuler = new three__WEBPACK_IMPORTED_MODULE_2__.Euler().setFromQuaternion(_rotation, \"XYZ\");\n            const { geometry } = child;\n            const { args, offset } = getColliderArgsFromGeometry(geometry, options.colliders || \"cuboid\");\n            const colliderProps = _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(options)), {}, {\n                args: args,\n                shape: shape,\n                rotation: [\n                    rotationEuler.x,\n                    rotationEuler.y,\n                    rotationEuler.z\n                ],\n                position: [\n                    _position.x + offset.x * worldScale.x,\n                    _position.y + offset.y * worldScale.y,\n                    _position.z + offset.z * worldScale.z\n                ],\n                scale: [\n                    worldScale.x,\n                    worldScale.y,\n                    worldScale.z\n                ]\n            });\n            childColliderProps.push(colliderProps);\n        }\n    };\n    if (options.includeInvisible) {\n        object.traverse(colliderFromChild);\n    } else {\n        object.traverseVisible(colliderFromChild);\n    }\n    return childColliderProps;\n};\nconst getColliderArgsFromGeometry = (geometry, colliders)=>{\n    switch(colliders){\n        case \"cuboid\":\n            {\n                geometry.computeBoundingBox();\n                const { boundingBox } = geometry;\n                const size = boundingBox.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n                return {\n                    args: [\n                        size.x / 2,\n                        size.y / 2,\n                        size.z / 2\n                    ],\n                    offset: boundingBox.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3())\n                };\n            }\n        case \"ball\":\n            {\n                geometry.computeBoundingSphere();\n                const { boundingSphere } = geometry;\n                const radius = boundingSphere.radius;\n                return {\n                    args: [\n                        radius\n                    ],\n                    offset: boundingSphere.center\n                };\n            }\n        case \"trimesh\":\n            {\n                var _clonedGeometry$index;\n                const clonedGeometry = geometry.index ? geometry.clone() : (0,three_stdlib__WEBPACK_IMPORTED_MODULE_4__.mergeVertices)(geometry);\n                return {\n                    args: [\n                        clonedGeometry.attributes.position.array,\n                        (_clonedGeometry$index = clonedGeometry.index) === null || _clonedGeometry$index === void 0 ? void 0 : _clonedGeometry$index.array\n                    ],\n                    offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n                };\n            }\n        case \"hull\":\n            {\n                const g = geometry.clone();\n                return {\n                    args: [\n                        g.attributes.position.array\n                    ],\n                    offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n                };\n            }\n    }\n    return {\n        args: [],\n        offset: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()\n    };\n};\nconst getActiveCollisionEventsFromProps = (props)=>{\n    return {\n        collision: !!(props !== null && props !== void 0 && props.onCollisionEnter || props !== null && props !== void 0 && props.onCollisionExit || props !== null && props !== void 0 && props.onIntersectionEnter || props !== null && props !== void 0 && props.onIntersectionExit),\n        contactForce: !!(props !== null && props !== void 0 && props.onContactForce)\n    };\n};\nconst useColliderEvents = (getCollider, props, events, /**\n * The RigidBody can pass down active events to the collider without attaching the event listners\n */ activeEvents = {})=>{\n    const { onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce } = props;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const collider = getCollider();\n        if (collider) {\n            const { collision: collisionEventsActive, contactForce: contactForceEventsActive } = getActiveCollisionEventsFromProps(props);\n            const hasCollisionEvent = collisionEventsActive || activeEvents.collision;\n            const hasContactForceEvent = contactForceEventsActive || activeEvents.contactForce;\n            if (hasCollisionEvent && hasContactForceEvent) {\n                collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS | _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n            } else if (hasCollisionEvent) {\n                collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.COLLISION_EVENTS);\n            } else if (hasContactForceEvent) {\n                collider.setActiveEvents(_dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents.CONTACT_FORCE_EVENTS);\n            }\n            events.set(collider.handle, {\n                onCollisionEnter,\n                onCollisionExit,\n                onIntersectionEnter,\n                onIntersectionExit,\n                onContactForce\n            });\n        }\n        return ()=>{\n            if (collider) {\n                events.delete(collider.handle);\n            }\n        };\n    }, [\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce,\n        activeEvents\n    ]);\n};\nconst cleanRigidBodyPropsForCollider = (props = {})=>{\n    const rest = _objectWithoutProperties(props, _excluded$2);\n    return rest;\n};\nconst useMutableCallback = (fn)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(fn);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        ref.current = fn;\n    }, [\n        fn\n    ]);\n    return ref;\n}; // External hooks\n/**\n * Exposes the Rapier context, and world\n * @category Hooks\n */ const useRapier = ()=>{\n    const rapier = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(rapierContext);\n    if (!rapier) throw new Error(\"react-three-rapier: useRapier must be used within <Physics />!\");\n    return rapier;\n};\n/**\n * Registers a callback to be called before the physics step\n * @category Hooks\n */ const useBeforePhysicsStep = (callback)=>{\n    const { beforeStepCallbacks } = useRapier();\n    const ref = useMutableCallback(callback);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        beforeStepCallbacks.add(ref);\n        return ()=>{\n            beforeStepCallbacks.delete(ref);\n        };\n    }, []);\n};\n/**\n * Registers a callback to be called after the physics step\n * @category Hooks\n */ const useAfterPhysicsStep = (callback)=>{\n    const { afterStepCallbacks } = useRapier();\n    const ref = useMutableCallback(callback);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        afterStepCallbacks.add(ref);\n        return ()=>{\n            afterStepCallbacks.delete(ref);\n        };\n    }, []);\n}; // Internal hooks\n/**\n * @internal\n */ const useChildColliderProps = (ref, options, ignoreMeshColliders = true)=>{\n    const [colliderProps, setColliderProps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const object = ref.current;\n        if (object && options.colliders !== false) {\n            setColliderProps(createColliderPropsFromChildren({\n                object: ref.current,\n                options,\n                ignoreMeshColliders\n            }));\n        }\n    }, [\n        options.colliders\n    ]);\n    return colliderProps;\n};\nconst Debug = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(()=>{\n    const { world } = useRapier();\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.C)(()=>{\n        const mesh = ref.current;\n        if (!mesh) return;\n        const buffers = world.debugRender();\n        mesh.geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.vertices, 3));\n        mesh.geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.BufferAttribute(buffers.colors, 4));\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"group\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineSegments\", {\n        ref: ref,\n        frustumCulled: false\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"lineBasicMaterial\", {\n        color: 0xffffff,\n        vertexColors: true\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"bufferGeometry\", null)));\n});\n/**\n * Creates a proxy that will create a singleton instance of the given class\n * when a property is accessed, and not before.\n *\n * @returns A proxy and a reset function, so that the instance can created again\n */ const createSingletonProxy = (createInstance)=>{\n    let instance;\n    const handler = {\n        get (target, prop) {\n            if (!instance) {\n                instance = createInstance();\n            }\n            return Reflect.get(instance, prop);\n        },\n        set (target, prop, value) {\n            if (!instance) {\n                instance = createInstance();\n            }\n            return Reflect.set(instance, prop, value);\n        }\n    };\n    const proxy = new Proxy({}, handler);\n    const reset = ()=>{\n        instance = undefined;\n    };\n    const set = (newInstance)=>{\n        instance = newInstance;\n    };\n    /**\n   * Return the proxy and a reset function\n   */ return {\n        proxy,\n        reset,\n        set\n    };\n};\nconst rapierContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst getCollisionPayloadFromSource = (target, other)=>{\n    var _target$collider$stat, _target$rigidBody$sta, _other$collider$state, _other$rigidBody$stat, _other$collider$state2, _other$rigidBody$stat2;\n    return {\n        target: {\n            rigidBody: target.rigidBody.object,\n            collider: target.collider.object,\n            colliderObject: (_target$collider$stat = target.collider.state) === null || _target$collider$stat === void 0 ? void 0 : _target$collider$stat.object,\n            rigidBodyObject: (_target$rigidBody$sta = target.rigidBody.state) === null || _target$rigidBody$sta === void 0 ? void 0 : _target$rigidBody$sta.object\n        },\n        other: {\n            rigidBody: other.rigidBody.object,\n            collider: other.collider.object,\n            colliderObject: (_other$collider$state = other.collider.state) === null || _other$collider$state === void 0 ? void 0 : _other$collider$state.object,\n            rigidBodyObject: (_other$rigidBody$stat = other.rigidBody.state) === null || _other$rigidBody$stat === void 0 ? void 0 : _other$rigidBody$stat.object\n        },\n        rigidBody: other.rigidBody.object,\n        collider: other.collider.object,\n        colliderObject: (_other$collider$state2 = other.collider.state) === null || _other$collider$state2 === void 0 ? void 0 : _other$collider$state2.object,\n        rigidBodyObject: (_other$rigidBody$stat2 = other.rigidBody.state) === null || _other$rigidBody$stat2 === void 0 ? void 0 : _other$rigidBody$stat2.object\n    };\n};\nconst importRapier = async ()=>{\n    let r = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @dimforge/rapier3d-compat */ \"(ssr)/./node_modules/@dimforge/rapier3d-compat/rapier.es.js\"));\n    await r.init();\n    return r;\n};\n/**\n * The main physics component used to create a physics world.\n * @category Components\n */ const Physics = (props)=>{\n    const { colliders = \"cuboid\", children, timeStep = 1 / 60, paused = false, interpolate = true, updatePriority, updateLoop = \"follow\", debug = false, gravity = [\n        0,\n        -9.81,\n        0\n    ], allowedLinearError = 0.001, predictionDistance = 0.002, numSolverIterations = 4, numAdditionalFrictionIterations = 4, numInternalPgsIterations = 1, minIslandSize = 128, maxCcdSubsteps = 1, erp = 0.8 } = props;\n    const rapier = (0,suspend_react__WEBPACK_IMPORTED_MODULE_5__.suspend)(importRapier, [\n        \"@react-thee/rapier\",\n        importRapier\n    ]);\n    const { invalidate } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)();\n    const rigidBodyStates = useConst(()=>new Map());\n    const colliderStates = useConst(()=>new Map());\n    const rigidBodyEvents = useConst(()=>new Map());\n    const colliderEvents = useConst(()=>new Map());\n    const eventQueue = useConst(()=>new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.EventQueue(false));\n    const beforeStepCallbacks = useConst(()=>new Set());\n    const afterStepCallbacks = useConst(()=>new Set());\n    /**\n   * Initiate the world\n   * This creates a singleton proxy, so that the world is only created when\n   * something within it is accessed.\n   */ const { proxy: worldProxy, reset: resetWorldProxy, set: setWorldProxy } = useConst(()=>createSingletonProxy(()=>new rapier.World(vectorArrayToVector3(gravity))));\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            worldProxy.free();\n            resetWorldProxy();\n        };\n    }, []); // Update mutable props\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        worldProxy.gravity = vector3ToRapierVector(gravity);\n        worldProxy.integrationParameters.numSolverIterations = numSolverIterations;\n        worldProxy.integrationParameters.numAdditionalFrictionIterations = numAdditionalFrictionIterations;\n        worldProxy.integrationParameters.numInternalPgsIterations = numInternalPgsIterations;\n        worldProxy.integrationParameters.allowedLinearError = allowedLinearError;\n        worldProxy.integrationParameters.minIslandSize = minIslandSize;\n        worldProxy.integrationParameters.maxCcdSubsteps = maxCcdSubsteps;\n        worldProxy.integrationParameters.predictionDistance = predictionDistance;\n        worldProxy.integrationParameters.erp = erp;\n    }, [\n        worldProxy,\n        ...gravity,\n        numSolverIterations,\n        numAdditionalFrictionIterations,\n        numInternalPgsIterations,\n        allowedLinearError,\n        minIslandSize,\n        maxCcdSubsteps,\n        predictionDistance,\n        erp\n    ]);\n    const getSourceFromColliderHandle = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((handle)=>{\n        var _collider$parent;\n        const collider = worldProxy.getCollider(handle);\n        const colEvents = colliderEvents.get(handle);\n        const colliderState = colliderStates.get(handle);\n        const rigidBodyHandle = collider === null || collider === void 0 ? void 0 : (_collider$parent = collider.parent()) === null || _collider$parent === void 0 ? void 0 : _collider$parent.handle;\n        const rigidBody = rigidBodyHandle !== undefined ? worldProxy.getRigidBody(rigidBodyHandle) : undefined;\n        const rbEvents = rigidBody && rigidBodyHandle !== undefined ? rigidBodyEvents.get(rigidBodyHandle) : undefined;\n        const rigidBodyState = rigidBodyHandle !== undefined ? rigidBodyStates.get(rigidBodyHandle) : undefined;\n        const source = {\n            collider: {\n                object: collider,\n                events: colEvents,\n                state: colliderState\n            },\n            rigidBody: {\n                object: rigidBody,\n                events: rbEvents,\n                state: rigidBodyState\n            }\n        };\n        return source;\n    }, []);\n    const [steppingState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        previousState: {},\n        accumulator: 0\n    });\n    const step = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((dt)=>{\n        const world = worldProxy;\n        /* Check if the timestep is supposed to be variable. We'll do this here\n      once so we don't have to string-check every frame. */ const timeStepVariable = timeStep === \"vary\";\n        /**\n     * Fixed timeStep simulation progression\n     * @see https://gafferongames.com/post/fix_your_timestep/\n     */ const clampedDelta = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(dt, 0, 0.5);\n        const stepWorld = (delta)=>{\n            // Trigger beforeStep callbacks\n            beforeStepCallbacks.forEach((callback)=>{\n                callback.current(world);\n            });\n            world.timestep = delta;\n            world.step(eventQueue); // Trigger afterStep callbacks\n            afterStepCallbacks.forEach((callback)=>{\n                callback.current(world);\n            });\n        };\n        if (timeStepVariable) {\n            stepWorld(clampedDelta);\n        } else {\n            // don't step time forwards if paused\n            // Increase accumulator\n            steppingState.accumulator += clampedDelta;\n            while(steppingState.accumulator >= timeStep){\n                // Set up previous state\n                // needed for accurate interpolations if the world steps more than once\n                if (interpolate) {\n                    steppingState.previousState = {};\n                    world.forEachRigidBody((body)=>{\n                        steppingState.previousState[body.handle] = {\n                            position: body.translation(),\n                            rotation: body.rotation()\n                        };\n                    });\n                }\n                stepWorld(timeStep);\n                steppingState.accumulator -= timeStep;\n            }\n        }\n        const interpolationAlpha = timeStepVariable || !interpolate || paused ? 1 : steppingState.accumulator / timeStep; // Update meshes\n        rigidBodyStates.forEach((state, handle)=>{\n            const rigidBody = world.getRigidBody(handle);\n            const events = rigidBodyEvents.get(handle);\n            if (events !== null && events !== void 0 && events.onSleep || events !== null && events !== void 0 && events.onWake) {\n                if (rigidBody.isSleeping() && !state.isSleeping) {\n                    var _events$onSleep;\n                    events === null || events === void 0 ? void 0 : (_events$onSleep = events.onSleep) === null || _events$onSleep === void 0 ? void 0 : _events$onSleep.call(events);\n                }\n                if (!rigidBody.isSleeping() && state.isSleeping) {\n                    var _events$onWake;\n                    events === null || events === void 0 ? void 0 : (_events$onWake = events.onWake) === null || _events$onWake === void 0 ? void 0 : _events$onWake.call(events);\n                }\n                state.isSleeping = rigidBody.isSleeping();\n            }\n            if (!rigidBody || rigidBody.isSleeping() && !(\"isInstancedMesh\" in state.object) || !state.setMatrix) {\n                return;\n            } // New states\n            let t = rigidBody.translation();\n            let r = rigidBody.rotation();\n            let previousState = steppingState.previousState[handle];\n            if (previousState) {\n                // Get previous simulated world position\n                _matrix4.compose(previousState.position, rapierQuaternionToQuaternion(previousState.rotation), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale); // Apply previous tick position\n                if (state.meshType == \"mesh\") {\n                    state.object.position.copy(_position);\n                    state.object.quaternion.copy(_rotation);\n                }\n            } // Get new position\n            _matrix4.compose(t, rapierQuaternionToQuaternion(r), state.scale).premultiply(state.invertedWorldMatrix).decompose(_position, _rotation, _scale);\n            if (state.meshType == \"instancedMesh\") {\n                state.setMatrix(_matrix4);\n            } else {\n                // Interpolate to new position\n                state.object.position.lerp(_position, interpolationAlpha);\n                state.object.quaternion.slerp(_rotation, interpolationAlpha);\n            }\n        });\n        eventQueue.drainCollisionEvents((handle1, handle2, started)=>{\n            const source1 = getSourceFromColliderHandle(handle1);\n            const source2 = getSourceFromColliderHandle(handle2); // Collision Events\n            if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n                return;\n            }\n            const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n            const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n            if (started) {\n                world.contactPair(source1.collider.object, source2.collider.object, (manifold, flipped)=>{\n                    var _source1$rigidBody$ev, _source1$rigidBody$ev2, _source2$rigidBody$ev, _source2$rigidBody$ev2, _source1$collider$eve, _source1$collider$eve2, _source2$collider$eve, _source2$collider$eve2;\n                    /* RigidBody events */ (_source1$rigidBody$ev = source1.rigidBody.events) === null || _source1$rigidBody$ev === void 0 ? void 0 : (_source1$rigidBody$ev2 = _source1$rigidBody$ev.onCollisionEnter) === null || _source1$rigidBody$ev2 === void 0 ? void 0 : _source1$rigidBody$ev2.call(_source1$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n                        manifold,\n                        flipped\n                    }));\n                    (_source2$rigidBody$ev = source2.rigidBody.events) === null || _source2$rigidBody$ev === void 0 ? void 0 : (_source2$rigidBody$ev2 = _source2$rigidBody$ev.onCollisionEnter) === null || _source2$rigidBody$ev2 === void 0 ? void 0 : _source2$rigidBody$ev2.call(_source2$rigidBody$ev, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n                        manifold,\n                        flipped\n                    }));\n                    /* Collider events */ (_source1$collider$eve = source1.collider.events) === null || _source1$collider$eve === void 0 ? void 0 : (_source1$collider$eve2 = _source1$collider$eve.onCollisionEnter) === null || _source1$collider$eve2 === void 0 ? void 0 : _source1$collider$eve2.call(_source1$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n                        manifold,\n                        flipped\n                    }));\n                    (_source2$collider$eve = source2.collider.events) === null || _source2$collider$eve === void 0 ? void 0 : (_source2$collider$eve2 = _source2$collider$eve.onCollisionEnter) === null || _source2$collider$eve2 === void 0 ? void 0 : _source2$collider$eve2.call(_source2$collider$eve, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n                        manifold,\n                        flipped\n                    }));\n                });\n            } else {\n                var _source1$rigidBody$ev3, _source1$rigidBody$ev4, _source2$rigidBody$ev3, _source2$rigidBody$ev4, _source1$collider$eve3, _source1$collider$eve4, _source2$collider$eve3, _source2$collider$eve4;\n                (_source1$rigidBody$ev3 = source1.rigidBody.events) === null || _source1$rigidBody$ev3 === void 0 ? void 0 : (_source1$rigidBody$ev4 = _source1$rigidBody$ev3.onCollisionExit) === null || _source1$rigidBody$ev4 === void 0 ? void 0 : _source1$rigidBody$ev4.call(_source1$rigidBody$ev3, collisionPayload1);\n                (_source2$rigidBody$ev3 = source2.rigidBody.events) === null || _source2$rigidBody$ev3 === void 0 ? void 0 : (_source2$rigidBody$ev4 = _source2$rigidBody$ev3.onCollisionExit) === null || _source2$rigidBody$ev4 === void 0 ? void 0 : _source2$rigidBody$ev4.call(_source2$rigidBody$ev3, collisionPayload2);\n                (_source1$collider$eve3 = source1.collider.events) === null || _source1$collider$eve3 === void 0 ? void 0 : (_source1$collider$eve4 = _source1$collider$eve3.onCollisionExit) === null || _source1$collider$eve4 === void 0 ? void 0 : _source1$collider$eve4.call(_source1$collider$eve3, collisionPayload1);\n                (_source2$collider$eve3 = source2.collider.events) === null || _source2$collider$eve3 === void 0 ? void 0 : (_source2$collider$eve4 = _source2$collider$eve3.onCollisionExit) === null || _source2$collider$eve4 === void 0 ? void 0 : _source2$collider$eve4.call(_source2$collider$eve3, collisionPayload2);\n            } // Sensor Intersections\n            if (started) {\n                if (world.intersectionPair(source1.collider.object, source2.collider.object)) {\n                    var _source1$rigidBody$ev5, _source1$rigidBody$ev6, _source2$rigidBody$ev5, _source2$rigidBody$ev6, _source1$collider$eve5, _source1$collider$eve6, _source2$collider$eve5, _source2$collider$eve6;\n                    (_source1$rigidBody$ev5 = source1.rigidBody.events) === null || _source1$rigidBody$ev5 === void 0 ? void 0 : (_source1$rigidBody$ev6 = _source1$rigidBody$ev5.onIntersectionEnter) === null || _source1$rigidBody$ev6 === void 0 ? void 0 : _source1$rigidBody$ev6.call(_source1$rigidBody$ev5, collisionPayload1);\n                    (_source2$rigidBody$ev5 = source2.rigidBody.events) === null || _source2$rigidBody$ev5 === void 0 ? void 0 : (_source2$rigidBody$ev6 = _source2$rigidBody$ev5.onIntersectionEnter) === null || _source2$rigidBody$ev6 === void 0 ? void 0 : _source2$rigidBody$ev6.call(_source2$rigidBody$ev5, collisionPayload2);\n                    (_source1$collider$eve5 = source1.collider.events) === null || _source1$collider$eve5 === void 0 ? void 0 : (_source1$collider$eve6 = _source1$collider$eve5.onIntersectionEnter) === null || _source1$collider$eve6 === void 0 ? void 0 : _source1$collider$eve6.call(_source1$collider$eve5, collisionPayload1);\n                    (_source2$collider$eve5 = source2.collider.events) === null || _source2$collider$eve5 === void 0 ? void 0 : (_source2$collider$eve6 = _source2$collider$eve5.onIntersectionEnter) === null || _source2$collider$eve6 === void 0 ? void 0 : _source2$collider$eve6.call(_source2$collider$eve5, collisionPayload2);\n                }\n            } else {\n                var _source1$rigidBody$ev7, _source1$rigidBody$ev8, _source2$rigidBody$ev7, _source2$rigidBody$ev8, _source1$collider$eve7, _source1$collider$eve8, _source2$collider$eve7, _source2$collider$eve8;\n                (_source1$rigidBody$ev7 = source1.rigidBody.events) === null || _source1$rigidBody$ev7 === void 0 ? void 0 : (_source1$rigidBody$ev8 = _source1$rigidBody$ev7.onIntersectionExit) === null || _source1$rigidBody$ev8 === void 0 ? void 0 : _source1$rigidBody$ev8.call(_source1$rigidBody$ev7, collisionPayload1);\n                (_source2$rigidBody$ev7 = source2.rigidBody.events) === null || _source2$rigidBody$ev7 === void 0 ? void 0 : (_source2$rigidBody$ev8 = _source2$rigidBody$ev7.onIntersectionExit) === null || _source2$rigidBody$ev8 === void 0 ? void 0 : _source2$rigidBody$ev8.call(_source2$rigidBody$ev7, collisionPayload2);\n                (_source1$collider$eve7 = source1.collider.events) === null || _source1$collider$eve7 === void 0 ? void 0 : (_source1$collider$eve8 = _source1$collider$eve7.onIntersectionExit) === null || _source1$collider$eve8 === void 0 ? void 0 : _source1$collider$eve8.call(_source1$collider$eve7, collisionPayload1);\n                (_source2$collider$eve7 = source2.collider.events) === null || _source2$collider$eve7 === void 0 ? void 0 : (_source2$collider$eve8 = _source2$collider$eve7.onIntersectionExit) === null || _source2$collider$eve8 === void 0 ? void 0 : _source2$collider$eve8.call(_source2$collider$eve7, collisionPayload2);\n            }\n        });\n        eventQueue.drainContactForceEvents((event)=>{\n            var _source1$rigidBody$ev9, _source1$rigidBody$ev10, _source2$rigidBody$ev9, _source2$rigidBody$ev10, _source1$collider$eve9, _source1$collider$eve10, _source2$collider$eve9, _source2$collider$eve10;\n            const source1 = getSourceFromColliderHandle(event.collider1());\n            const source2 = getSourceFromColliderHandle(event.collider2()); // Collision Events\n            if (!(source1 !== null && source1 !== void 0 && source1.collider.object) || !(source2 !== null && source2 !== void 0 && source2.collider.object)) {\n                return;\n            }\n            const collisionPayload1 = getCollisionPayloadFromSource(source1, source2);\n            const collisionPayload2 = getCollisionPayloadFromSource(source2, source1);\n            (_source1$rigidBody$ev9 = source1.rigidBody.events) === null || _source1$rigidBody$ev9 === void 0 ? void 0 : (_source1$rigidBody$ev10 = _source1$rigidBody$ev9.onContactForce) === null || _source1$rigidBody$ev10 === void 0 ? void 0 : _source1$rigidBody$ev10.call(_source1$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n                totalForce: event.totalForce(),\n                totalForceMagnitude: event.totalForceMagnitude(),\n                maxForceDirection: event.maxForceDirection(),\n                maxForceMagnitude: event.maxForceMagnitude()\n            }));\n            (_source2$rigidBody$ev9 = source2.rigidBody.events) === null || _source2$rigidBody$ev9 === void 0 ? void 0 : (_source2$rigidBody$ev10 = _source2$rigidBody$ev9.onContactForce) === null || _source2$rigidBody$ev10 === void 0 ? void 0 : _source2$rigidBody$ev10.call(_source2$rigidBody$ev9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n                totalForce: event.totalForce(),\n                totalForceMagnitude: event.totalForceMagnitude(),\n                maxForceDirection: event.maxForceDirection(),\n                maxForceMagnitude: event.maxForceMagnitude()\n            }));\n            (_source1$collider$eve9 = source1.collider.events) === null || _source1$collider$eve9 === void 0 ? void 0 : (_source1$collider$eve10 = _source1$collider$eve9.onContactForce) === null || _source1$collider$eve10 === void 0 ? void 0 : _source1$collider$eve10.call(_source1$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload1), {}, {\n                totalForce: event.totalForce(),\n                totalForceMagnitude: event.totalForceMagnitude(),\n                maxForceDirection: event.maxForceDirection(),\n                maxForceMagnitude: event.maxForceMagnitude()\n            }));\n            (_source2$collider$eve9 = source2.collider.events) === null || _source2$collider$eve9 === void 0 ? void 0 : (_source2$collider$eve10 = _source2$collider$eve9.onContactForce) === null || _source2$collider$eve10 === void 0 ? void 0 : _source2$collider$eve10.call(_source2$collider$eve9, _objectSpread2(_objectSpread2({}, collisionPayload2), {}, {\n                totalForce: event.totalForce(),\n                totalForceMagnitude: event.totalForceMagnitude(),\n                maxForceDirection: event.maxForceDirection(),\n                maxForceMagnitude: event.maxForceMagnitude()\n            }));\n        });\n        world.forEachActiveRigidBody(()=>{\n            invalidate();\n        });\n    }, [\n        paused,\n        timeStep,\n        interpolate,\n        worldProxy\n    ]);\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            rapier,\n            world: worldProxy,\n            setWorld: (world)=>{\n                setWorldProxy(world);\n            },\n            physicsOptions: {\n                colliders,\n                gravity\n            },\n            rigidBodyStates,\n            colliderStates,\n            rigidBodyEvents,\n            colliderEvents,\n            beforeStepCallbacks,\n            afterStepCallbacks,\n            isPaused: paused,\n            isDebug: debug,\n            step\n        }), [\n        paused,\n        step,\n        debug,\n        colliders,\n        gravity\n    ]);\n    const stepCallback = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((delta)=>{\n        if (!paused) {\n            step(delta);\n        }\n    }, [\n        paused,\n        step\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(rapierContext.Provider, {\n        value: context\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(FrameStepper$1, {\n        onStep: stepCallback,\n        type: updateLoop,\n        updatePriority: updatePriority\n    }), debug && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Debug, null), children);\n};\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n/**\n * Initiate an instance and return a safe getter\n */ const useImperativeInstance = (createFn, destroyFn, dependencyList)=>{\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const getInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!ref.current) {\n            ref.current = createFn();\n        }\n        return ref.current;\n    }, dependencyList);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Save the destroy function and instance\n        const instance = getInstance();\n        const destroy = ()=>destroyFn(instance);\n        return ()=>{\n            destroy();\n            ref.current = undefined;\n        };\n    }, [\n        getInstance\n    ]);\n    return getInstance;\n};\n/**\n * Takes an object resembling a Vector3 and returs a Three.Vector3\n * @category Math helpers\n */ const vec3 = ({ x, y, z } = {\n    x: 0,\n    y: 0,\n    z: 0\n})=>{\n    return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n};\n/**\n * Takes an object resembling a Quaternion and returs a Three.Quaternion\n * @category Math helpers\n */ const quat = ({ x, y, z, w } = {\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 1\n})=>{\n    return new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(x, y, z, w);\n};\n/**\n * Takes an object resembling an Euler and returs a Three.Euler\n * @category Math helpers\n */ const euler = ({ x, y, z } = {\n    x: 0,\n    y: 0,\n    z: 0\n})=>{\n    return new three__WEBPACK_IMPORTED_MODULE_2__.Euler(x, y, z);\n};\nconst useForwardedRef = (forwardedRef, defaultValue = null)=>{\n    const innerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(defaultValue); // Update the forwarded ref when the inner ref changes\n    if (forwardedRef && typeof forwardedRef !== \"function\") {\n        if (!forwardedRef.current) {\n            forwardedRef.current = innerRef.current;\n        }\n        return forwardedRef;\n    }\n    return innerRef;\n};\n/**\n * A collider is a shape that can be attached to a rigid body to define its physical properties.\n * @internal\n */ const AnyCollider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    const { children, position, rotation, quaternion, scale, name } = props;\n    const { world, colliderEvents, colliderStates } = useRapier();\n    const rigidBodyContext = useRigidBodyContext();\n    const colliderRef = useForwardedRef(forwardedRef);\n    const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null); // We spread the props out here to make sure that the ref is updated when the props change.\n    const immutablePropArray = immutableColliderOptions.flatMap((key)=>Array.isArray(props[key]) ? [\n            ...props[key]\n        ] : props[key]);\n    const getInstance = useImperativeInstance(()=>{\n        const worldScale = objectRef.current.getWorldScale(vec3());\n        const collider = createColliderFromOptions(props, world, worldScale, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.getRigidBody);\n        if (typeof forwardedRef == \"function\") {\n            forwardedRef(collider);\n        }\n        colliderRef.current = collider;\n        return collider;\n    }, (collider)=>{\n        if (world.getCollider(collider.handle)) {\n            world.removeCollider(collider, true);\n        }\n    }, [\n        ...immutablePropArray,\n        rigidBodyContext\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const collider = getInstance();\n        colliderStates.set(collider.handle, createColliderState(collider, objectRef.current, rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.ref.current));\n        return ()=>{\n            colliderStates.delete(collider.handle);\n        };\n    }, [\n        getInstance\n    ]);\n    const mergedProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return _objectSpread2(_objectSpread2({}, cleanRigidBodyPropsForCollider(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options)), props);\n    }, [\n        props,\n        rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options\n    ]);\n    useUpdateColliderOptions(getInstance, mergedProps, colliderStates);\n    useColliderEvents(getInstance, mergedProps, colliderEvents, getActiveCollisionEventsFromProps(rigidBodyContext === null || rigidBodyContext === void 0 ? void 0 : rigidBodyContext.options));\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n        position: position,\n        rotation: rotation,\n        quaternion: quaternion,\n        scale: scale,\n        ref: objectRef,\n        name: name\n    }, children);\n}));\n/**\n * A cuboid collider shape\n * @category Colliders\n */ const CuboidCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>{\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"cuboid\",\n        ref: ref\n    }));\n});\nCuboidCollider.displayName = \"CuboidCollider\";\n/**\n * A round cuboid collider shape\n * @category Colliders\n */ const RoundCuboidCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"roundCuboid\",\n        ref: ref\n    })));\nRoundCuboidCollider.displayName = \"RoundCuboidCollider\";\n/**\n * A ball collider shape\n * @category Colliders\n */ const BallCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"ball\",\n        ref: ref\n    })));\nBallCollider.displayName = \"BallCollider\";\n/**\n * A capsule collider shape\n * @category Colliders\n */ const CapsuleCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"capsule\",\n        ref: ref\n    })));\nCapsuleCollider.displayName = \"CapsuleCollider\";\n/**\n * A heightfield collider shape\n * @category Colliders\n */ const HeightfieldCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"heightfield\",\n        ref: ref\n    })));\nHeightfieldCollider.displayName = \"HeightfieldCollider\";\n/**\n * A trimesh collider shape\n * @category Colliders\n */ const TrimeshCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"trimesh\",\n        ref: ref\n    })));\nTrimeshCollider.displayName = \"TrimeshCollider\";\n/**\n * A cone collider shape\n * @category Colliders\n */ const ConeCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"cone\",\n        ref: ref\n    })));\nConeCollider.displayName = \"ConeCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */ const RoundConeCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"roundCone\",\n        ref: ref\n    })));\nRoundConeCollider.displayName = \"RoundConeCollider\";\n/**\n * A cylinder collider shape\n * @category Colliders\n */ const CylinderCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"cylinder\",\n        ref: ref\n    })));\nCylinderCollider.displayName = \"CylinderCollider\";\n/**\n * A round cylinder collider shape\n * @category Colliders\n */ const RoundCylinderCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"roundCylinder\",\n        ref: ref\n    })));\nCylinderCollider.displayName = \"RoundCylinderCollider\";\n/**\n * A convex hull collider shape\n * @category Colliders\n */ const ConvexHullCollider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().forwardRef((props, ref)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({}, props, {\n        shape: \"convexHull\",\n        ref: ref\n    })));\nConvexHullCollider.displayName = \"ConvexHullCollider\";\nconst rigidBodyDescFromOptions = (options)=>{\n    var _options$canSleep;\n    const type = rigidBodyTypeFromString((options === null || options === void 0 ? void 0 : options.type) || \"dynamic\");\n    const desc = new _dimforge_rapier3d_compat__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc(type); // Apply immutable options\n    desc.canSleep = (_options$canSleep = options === null || options === void 0 ? void 0 : options.canSleep) !== null && _options$canSleep !== void 0 ? _options$canSleep : true;\n    return desc;\n};\nconst createRigidBodyState = ({ rigidBody, object, setMatrix, getMatrix, worldScale, meshType: _meshType = \"mesh\" })=>{\n    object.updateWorldMatrix(true, false);\n    const invertedWorldMatrix = object.parent.matrixWorld.clone().invert();\n    return {\n        object,\n        rigidBody,\n        invertedWorldMatrix,\n        setMatrix: setMatrix ? setMatrix : (matrix)=>{\n            object.matrix.copy(matrix);\n        },\n        getMatrix: getMatrix ? getMatrix : (matrix)=>matrix.copy(object.matrix),\n        scale: worldScale || object.getWorldScale(_scale).clone(),\n        isSleeping: false,\n        meshType: _meshType\n    };\n};\nconst immutableRigidBodyOptions = [\n    \"args\",\n    \"colliders\",\n    \"canSleep\"\n];\nconst mutableRigidBodyOptions = {\n    gravityScale: (rb, value)=>{\n        rb.setGravityScale(value, true);\n    },\n    additionalSolverIterations (rb, value) {\n        rb.setAdditionalSolverIterations(value);\n    },\n    linearDamping: (rb, value)=>{\n        rb.setLinearDamping(value);\n    },\n    angularDamping: (rb, value)=>{\n        rb.setAngularDamping(value);\n    },\n    dominanceGroup: (rb, value)=>{\n        rb.setDominanceGroup(value);\n    },\n    enabledRotations: (rb, [x, y, z])=>{\n        rb.setEnabledRotations(x, y, z, true);\n    },\n    enabledTranslations: (rb, [x, y, z])=>{\n        rb.setEnabledTranslations(x, y, z, true);\n    },\n    lockRotations: (rb, value)=>{\n        rb.lockRotations(value, true);\n    },\n    lockTranslations: (rb, value)=>{\n        rb.lockTranslations(value, true);\n    },\n    angularVelocity: (rb, [x, y, z])=>{\n        rb.setAngvel({\n            x,\n            y,\n            z\n        }, true);\n    },\n    linearVelocity: (rb, [x, y, z])=>{\n        rb.setLinvel({\n            x,\n            y,\n            z\n        }, true);\n    },\n    ccd: (rb, value)=>{\n        rb.enableCcd(value);\n    },\n    userData: (rb, value)=>{\n        rb.userData = value;\n    },\n    type (rb, value) {\n        rb.setBodyType(rigidBodyTypeFromString(value), true);\n    },\n    position: ()=>{},\n    rotation: ()=>{},\n    quaternion: ()=>{},\n    scale: ()=>{}\n};\nconst mutableRigidBodyOptionKeys = Object.keys(mutableRigidBodyOptions);\nconst setRigidBodyOptions = (rigidBody, options, states, updateTranslations = true)=>{\n    if (!rigidBody) {\n        return;\n    }\n    const state = states.get(rigidBody.handle);\n    if (state) {\n        if (updateTranslations) {\n            state.object.updateWorldMatrix(true, false);\n            _matrix4.copy(state.object.matrixWorld).decompose(_position, _rotation, _scale);\n            rigidBody.setTranslation(_position, false);\n            rigidBody.setRotation(_rotation, false);\n        }\n        mutableRigidBodyOptionKeys.forEach((key)=>{\n            if (key in options) {\n                mutableRigidBodyOptions[key](rigidBody, options[key]);\n            }\n        });\n    }\n};\nconst useUpdateRigidBodyOptions = (getRigidBody, props, states, updateTranslations = true)=>{\n    // TODO: Improve this, split each prop into its own effect\n    const mutablePropsAsFlatArray = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>mutableRigidBodyOptionKeys.flatMap((key)=>{\n            return vectorToTuple(props[key]);\n        }), [\n        props\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const rigidBody = getRigidBody();\n        setRigidBodyOptions(rigidBody, props, states, updateTranslations);\n    }, mutablePropsAsFlatArray);\n};\nconst useRigidBodyEvents = (getRigidBody, props, events)=>{\n    const { onWake, onSleep, onCollisionEnter, onCollisionExit, onIntersectionEnter, onIntersectionExit, onContactForce } = props;\n    const eventHandlers = {\n        onWake,\n        onSleep,\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const rigidBody = getRigidBody();\n        events.set(rigidBody.handle, eventHandlers);\n        return ()=>{\n            events.delete(rigidBody.handle);\n        };\n    }, [\n        onWake,\n        onSleep,\n        onCollisionEnter,\n        onCollisionExit,\n        onIntersectionEnter,\n        onIntersectionExit,\n        onContactForce\n    ]);\n};\nconst _excluded$1 = [\n    \"children\",\n    \"type\",\n    \"position\",\n    \"rotation\",\n    \"scale\",\n    \"quaternion\",\n    \"transformState\"\n];\nconst RigidBodyContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst useRigidBodyContext = ()=>(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RigidBodyContext);\n/**\n * A rigid body is a physical object that can be simulated by the physics engine.\n * @category Components\n */ const RigidBody = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    const { children, type, position, rotation, scale, quaternion, transformState } = props, objectProps = _objectWithoutProperties(props, _excluded$1);\n    const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const rigidBodyRef = useForwardedRef(forwardedRef);\n    const { world, rigidBodyStates, physicsOptions, rigidBodyEvents } = useRapier();\n    const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), props), {}, {\n            children: undefined\n        });\n    }, [\n        physicsOptions,\n        props\n    ]);\n    const immutablePropArray = immutableRigidBodyOptions.flatMap((key)=>{\n        return Array.isArray(mergedOptions[key]) ? [\n            ...mergedOptions[key]\n        ] : mergedOptions[key];\n    });\n    const childColliderProps = useChildColliderProps(objectRef, mergedOptions); // Provide a way to eagerly create rigidbody\n    const getRigidBody = useImperativeInstance(()=>{\n        const desc = rigidBodyDescFromOptions(mergedOptions);\n        const rigidBody = world.createRigidBody(desc);\n        if (typeof forwardedRef === \"function\") {\n            forwardedRef(rigidBody);\n        }\n        rigidBodyRef.current = rigidBody;\n        return rigidBody;\n    }, (rigidBody)=>{\n        if (world.getRigidBody(rigidBody.handle)) {\n            world.removeRigidBody(rigidBody);\n        }\n    }, immutablePropArray); // Only provide a object state after the ref has been set\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const rigidBody = getRigidBody();\n        const state = createRigidBodyState({\n            rigidBody,\n            object: objectRef.current\n        });\n        rigidBodyStates.set(rigidBody.handle, props.transformState ? props.transformState(state) : state);\n        return ()=>{\n            rigidBodyStates.delete(rigidBody.handle);\n        };\n    }, [\n        getRigidBody\n    ]);\n    useUpdateRigidBodyOptions(getRigidBody, mergedOptions, rigidBodyStates);\n    useRigidBodyEvents(getRigidBody, mergedOptions, rigidBodyEvents);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return {\n            ref: objectRef,\n            getRigidBody: getRigidBody,\n            options: mergedOptions\n        };\n    }, [\n        getRigidBody\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBodyContext.Provider, {\n        value: contextValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n        ref: objectRef\n    }, objectProps, {\n        position: position,\n        rotation: rotation,\n        quaternion: quaternion,\n        scale: scale\n    }), children, childColliderProps.map((colliderProps, index)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n            key: index\n        }, colliderProps)))));\n}));\nRigidBody.displayName = \"RigidBody\";\n/**\n * A mesh collider is a collider that is automatically generated from the geometry of the children.\n * @category Colliders\n */ const MeshCollider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)((props)=>{\n    const { children, type } = props;\n    const { physicsOptions } = useRapier();\n    const object = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { options } = useRigidBodyContext();\n    const mergedOptions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        return _objectSpread2(_objectSpread2(_objectSpread2({}, physicsOptions), options), {}, {\n            children: undefined,\n            colliders: type\n        });\n    }, [\n        physicsOptions,\n        options\n    ]);\n    const childColliderProps = useChildColliderProps(object, mergedOptions, false);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n        ref: object,\n        userData: {\n            r3RapierType: \"MeshCollider\"\n        }\n    }, children, childColliderProps.map((colliderProps, index)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n            key: index\n        }, colliderProps))));\n});\nMeshCollider.displayName = \"MeshCollider\";\nconst _excluded = [\n    \"children\",\n    \"instances\",\n    \"colliderNodes\",\n    \"position\",\n    \"rotation\",\n    \"quaternion\",\n    \"scale\"\n];\nconst InstancedRigidBodies = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, forwardedRef)=>{\n    const rigidBodiesRef = useForwardedRef(forwardedRef, []);\n    const objectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const instanceWrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { // instanced props\n    children, instances, colliderNodes = [], // wrapper object props\n    position, rotation, quaternion, scale } = props, rigidBodyProps = _objectWithoutProperties(props, _excluded);\n    const childColliderProps = useChildColliderProps(objectRef, _objectSpread2(_objectSpread2({}, props), {}, {\n        children: undefined\n    }));\n    const getInstancedMesh = ()=>{\n        const firstChild = instanceWrapperRef.current.children[0];\n        if (firstChild && \"isInstancedMesh\" in firstChild) {\n            return firstChild;\n        }\n        return undefined;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const instancedMesh = getInstancedMesh();\n        if (instancedMesh) {\n            instancedMesh.instanceMatrix.setUsage(three__WEBPACK_IMPORTED_MODULE_2__.DynamicDrawUsage);\n        } else {\n            console.warn(\"InstancedRigidBodies expects exactly one child, which must be an InstancedMesh\");\n        }\n    }, []); // Update the RigidBodyStates whenever the instances change\n    const applyInstancedState = (state, index)=>{\n        const instancedMesh = getInstancedMesh();\n        if (instancedMesh) {\n            return _objectSpread2(_objectSpread2({}, state), {}, {\n                getMatrix: (matrix)=>{\n                    instancedMesh.getMatrixAt(index, matrix);\n                    return matrix;\n                },\n                setMatrix: (matrix)=>{\n                    instancedMesh.setMatrixAt(index, matrix);\n                    instancedMesh.instanceMatrix.needsUpdate = true;\n                },\n                meshType: \"instancedMesh\"\n            });\n        }\n        return state;\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", _extends({\n        ref: objectRef\n    }, rigidBodyProps, {\n        position: position,\n        rotation: rotation,\n        quaternion: quaternion,\n        scale: scale\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"object3D\", {\n        ref: instanceWrapperRef\n    }, children), instances === null || instances === void 0 ? void 0 : instances.map((instance, index)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(RigidBody, _extends({}, rigidBodyProps, instance, {\n            ref: (body)=>rigidBodiesRef.current[index] = body,\n            transformState: (state)=>applyInstancedState(state, index)\n        }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null, colliderNodes.map((node, index)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                key: index\n            }, node)), childColliderProps.map((colliderProps, colliderIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1___default().createElement(AnyCollider, _extends({\n                key: colliderIndex\n            }, colliderProps)))))));\n}));\nInstancedRigidBodies.displayName = \"InstancedRigidBodies\";\n/**\n * @internal\n */ const useImpulseJoint = (body1, body2, params)=>{\n    const { world } = useRapier();\n    const jointRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useImperativeInstance(()=>{\n        if (body1.current && body2.current) {\n            const newJoint = world.createImpulseJoint(params, body1.current, body2.current, true);\n            jointRef.current = newJoint;\n            return newJoint;\n        }\n    }, (joint)=>{\n        if (joint) {\n            jointRef.current = undefined;\n            if (world.getImpulseJoint(joint.handle)) {\n                world.removeImpulseJoint(joint, true);\n            }\n        }\n    }, []);\n    return jointRef;\n};\n/**\n * A fixed joint ensures that two rigid-bodies don't move relative to each other.\n * Fixed joints are characterized by one local frame (represented by an isometry) on each rigid-body.\n * The fixed-joint makes these frames coincide in world-space.\n *\n * @category Hooks - Joints\n */ const useFixedJoint = (body1, body2, [body1Anchor, body1LocalFrame, body2Anchor, body2LocalFrame])=>{\n    const { rapier } = useRapier();\n    return useImpulseJoint(body1, body2, rapier.JointData.fixed(vector3ToRapierVector(body1Anchor), quaternionToRapierQuaternion(body1LocalFrame), vector3ToRapierVector(body2Anchor), quaternionToRapierQuaternion(body2LocalFrame)));\n};\n/**\n * The spherical joint ensures that two points on the local-spaces of two rigid-bodies always coincide (it prevents any relative\n * translational motion at this points). This is typically used to simulate ragdolls arms, pendulums, etc.\n * They are characterized by one local anchor on each rigid-body. Each anchor represents the location of the\n * points that need to coincide on the local-space of each rigid-body.\n *\n * @category Hooks - Joints\n */ const useSphericalJoint = (body1, body2, [body1Anchor, body2Anchor])=>{\n    const { rapier } = useRapier();\n    return useImpulseJoint(body1, body2, rapier.JointData.spherical(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor)));\n};\n/**\n * The revolute joint prevents any relative movement between two rigid-bodies, except for relative\n * rotations along one axis. This is typically used to simulate wheels, fans, etc.\n * They are characterized by one local anchor as well as one local axis on each rigid-body.\n *\n * @category Hooks - Joints\n */ const useRevoluteJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits])=>{\n    const { rapier } = useRapier();\n    const params = rapier.JointData.revolute(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n    if (limits) {\n        params.limitsEnabled = true;\n        params.limits = limits;\n    }\n    return useImpulseJoint(body1, body2, params);\n};\n/**\n * The prismatic joint prevents any relative movement between two rigid-bodies, except for relative translations along one axis.\n * It is characterized by one local anchor as well as one local axis on each rigid-body. In 3D, an optional\n * local tangent axis can be specified for each rigid-body.\n *\n * @category Hooks - Joints\n */ const usePrismaticJoint = (body1, body2, [body1Anchor, body2Anchor, axis, limits])=>{\n    const { rapier } = useRapier();\n    const params = rapier.JointData.prismatic(vector3ToRapierVector(body1Anchor), vector3ToRapierVector(body2Anchor), vector3ToRapierVector(axis));\n    if (limits) {\n        params.limitsEnabled = true;\n        params.limits = limits;\n    }\n    return useImpulseJoint(body1, body2, params);\n};\n/**\n * The rope joint limits the max distance between two bodies.\n * @category Hooks - Joints\n */ const useRopeJoint = (body1, body2, [body1Anchor, body2Anchor, length])=>{\n    const { rapier } = useRapier();\n    const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n    const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n    const params = rapier.JointData.rope(length, vBody1Anchor, vBody2Anchor);\n    return useImpulseJoint(body1, body2, params);\n};\n/**\n * The spring joint applies a force proportional to the distance between two objects.\n * @category Hooks - Joints\n */ const useSpringJoint = (body1, body2, [body1Anchor, body2Anchor, restLength, stiffness, damping])=>{\n    const { rapier } = useRapier();\n    const vBody1Anchor = vector3ToRapierVector(body1Anchor);\n    const vBody2Anchor = vector3ToRapierVector(body2Anchor);\n    const params = rapier.JointData.spring(restLength, stiffness, damping, vBody1Anchor, vBody2Anchor);\n    return useImpulseJoint(body1, body2, params);\n};\n/**\n * Calculates an InteractionGroup bitmask for use in the `collisionGroups` or `solverGroups`\n * properties of RigidBody or Collider components. The first argument represents a list of\n * groups the entity is in (expressed as numbers from 0 to 15). The second argument is a list\n * of groups that will be filtered against. When it is omitted, all groups are filtered against.\n *\n * @example\n * A RigidBody that is member of group 0 and will collide with everything from groups 0 and 1:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0], [0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will collide with everything else:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1])} />\n * ```\n *\n * A RigidBody that is member of groups 0 and 1 and will not collide with anything:\n *\n * ```tsx\n * <RigidBody collisionGroups={interactionGroups([0, 1], [])} />\n * ```\n *\n * Please note that Rapier needs interaction filters to evaluate to true between _both_ colliding\n * entities for collision events to trigger.\n *\n * @param memberships Groups the collider is a member of. (Values can range from 0 to 15.)\n * @param filters Groups the interaction group should filter against. (Values can range from 0 to 15.)\n * @returns An InteractionGroup bitmask.\n */ const interactionGroups = (memberships, filters)=>(bitmask(memberships) << 16) + (filters !== undefined ? bitmask(filters) : 65535);\nconst bitmask = (groups)=>[\n        groups\n    ].flat().reduce((acc, layer)=>acc | 1 << layer, 0);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL3JhcGllci9kaXN0L3JlYWN0LXRocmVlLXJhcGllci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSjtBQUN2QjtBQUNyRTtBQUNnRjtBQUNwQjtBQUM1RTtBQUNLO0FBRTdDLFNBQVNrQyxnQkFBZ0JDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxLQUFLO0lBQ3RDLElBQUlELE9BQU9ELEtBQUs7UUFDZEcsT0FBT0MsY0FBYyxDQUFDSixLQUFLQyxLQUFLO1lBQzlCQyxPQUFPQTtZQUNQRyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtRQUNaO0lBQ0YsT0FBTztRQUNMUCxHQUFHLENBQUNDLElBQUksR0FBR0M7SUFDYjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQSxTQUFTUSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFDckMsSUFBSUMsT0FBT1IsT0FBT1EsSUFBSSxDQUFDRjtJQUV2QixJQUFJTixPQUFPUyxxQkFBcUIsRUFBRTtRQUNoQyxJQUFJQyxVQUFVVixPQUFPUyxxQkFBcUIsQ0FBQ0g7UUFDM0NDLGtCQUFtQkcsQ0FBQUEsVUFBVUEsUUFBUUMsTUFBTSxDQUFDLFNBQVVDLEdBQUc7WUFDdkQsT0FBT1osT0FBT2Esd0JBQXdCLENBQUNQLFFBQVFNLEtBQUtWLFVBQVU7UUFDaEUsRUFBQyxHQUFJTSxLQUFLTSxJQUFJLENBQUNDLEtBQUssQ0FBQ1AsTUFBTUU7SUFDN0I7SUFFQSxPQUFPRjtBQUNUO0FBRUEsU0FBU1EsZUFBZUMsTUFBTTtJQUM1QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO1FBQ3pDLElBQUlHLFNBQVMsUUFBUUYsU0FBUyxDQUFDRCxFQUFFLEdBQUdDLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHLENBQUM7UUFDcERBLElBQUksSUFBSWIsUUFBUUwsT0FBT3FCLFNBQVMs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QUFDQyxJQUFJLEdBQUdDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxRQUFVRCxNQUFNLEtBQUtDLE9BQU87QUFFc1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvcmFwaWVyL2Rpc3QvcmVhY3QtdGhyZWUtcmFwaWVyLmVzbS5qcz9mNjk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgYXMgVmVjdG9yMyQxLCBRdWF0ZXJuaW9uIGFzIFF1YXRlcm5pb24kMSwgQWN0aXZlRXZlbnRzLCBDb2xsaWRlckRlc2MsIEV2ZW50UXVldWUsIFJpZ2lkQm9keURlc2MgfSBmcm9tICdAZGltZm9yZ2UvcmFwaWVyM2QtY29tcGF0JztcbmV4cG9ydCB7IENvZWZmaWNpZW50Q29tYmluZVJ1bGUsIENvbGxpZGVyIGFzIFJhcGllckNvbGxpZGVyLCBSaWdpZEJvZHkgYXMgUmFwaWVyUmlnaWRCb2R5IH0gZnJvbSAnQGRpbWZvcmdlL3JhcGllcjNkLWNvbXBhdCc7XG5pbXBvcnQgeyB1c2VGcmFtZSwgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCBtZW1vLCB1c2VNZW1vLCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgY3JlYXRlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIGZvcndhcmRSZWYsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUXVhdGVybmlvbiwgRXVsZXIsIFZlY3RvcjMsIE9iamVjdDNELCBNYXRyaXg0LCBCdWZmZXJBdHRyaWJ1dGUsIE1hdGhVdGlscywgRHluYW1pY0RyYXdVc2FnZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHN1c3BlbmQgfSBmcm9tICdzdXNwZW5kLXJlYWN0JztcbmltcG9ydCB7IG1lcmdlVmVydGljZXMgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBfcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5uZXcgRXVsZXIoKTtcbmNvbnN0IF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKTtcbm5ldyBPYmplY3QzRCgpO1xuY29uc3QgX21hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xuY29uc3QgX3Bvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9yb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jb25zdCBfc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG5jb25zdCB2ZWN0b3JBcnJheVRvVmVjdG9yMyA9IGFyciA9PiB7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IGFycjtcbiAgcmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xufTtcbmNvbnN0IHJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24gPSAoe1xuICB4LFxuICB5LFxuICB6LFxuICB3XG59KSA9PiBfcXVhdGVybmlvbi5zZXQoeCwgeSwgeiwgdyk7XG5jb25zdCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IgPSB2ID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjMkMSh2WzBdLCB2WzFdLCB2WzJdKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMyQxKHYsIHYsIHYpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRocmVlVmVjdG9yMyA9IHY7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IzJDEodGhyZWVWZWN0b3IzLngsIHRocmVlVmVjdG9yMy55LCB0aHJlZVZlY3RvcjMueik7XG4gIH1cbn07XG5jb25zdCBxdWF0ZXJuaW9uVG9SYXBpZXJRdWF0ZXJuaW9uID0gdiA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uJDEodlswXSwgdlsxXSwgdlsyXSwgdlszXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uJDEodi54LCB2LnksIHYueiwgdi53KTtcbiAgfVxufTtcbmNvbnN0IHJpZ2lkQm9keVR5cGVNYXAgPSB7XG4gIGZpeGVkOiAxLFxuICBkeW5hbWljOiAwLFxuICBraW5lbWF0aWNQb3NpdGlvbjogMixcbiAga2luZW1hdGljVmVsb2NpdHk6IDNcbn07XG5jb25zdCByaWdpZEJvZHlUeXBlRnJvbVN0cmluZyA9IHR5cGUgPT4gcmlnaWRCb2R5VHlwZU1hcFt0eXBlXTtcbmNvbnN0IHNjYWxlVmVydGljZXMgPSAodmVydGljZXMsIHNjYWxlKSA9PiB7XG4gIGNvbnN0IHNjYWxlZFZlcnRzID0gQXJyYXkuZnJvbSh2ZXJ0aWNlcyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICBzY2FsZWRWZXJ0c1tpICogM10gKj0gc2NhbGUueDtcbiAgICBzY2FsZWRWZXJ0c1tpICogMyArIDFdICo9IHNjYWxlLnk7XG4gICAgc2NhbGVkVmVydHNbaSAqIDMgKyAyXSAqPSBzY2FsZS56O1xuICB9XG5cbiAgcmV0dXJuIHNjYWxlZFZlcnRzO1xufTtcbmNvbnN0IHZlY3RvclRvVHVwbGUgPSB2ID0+IHtcbiAgaWYgKCF2KSByZXR1cm4gWzBdO1xuXG4gIGlmICh2IGluc3RhbmNlb2YgUXVhdGVybmlvbikge1xuICAgIHJldHVybiBbdi54LCB2LnksIHYueiwgdi53XTtcbiAgfVxuXG4gIGlmICh2IGluc3RhbmNlb2YgVmVjdG9yMyB8fCB2IGluc3RhbmNlb2YgRXVsZXIpIHtcbiAgICByZXR1cm4gW3YueCwgdi55LCB2LnpdO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHJldHVybiBbdl07XG59O1xuZnVuY3Rpb24gdXNlQ29uc3QoaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZigpO1xuXG4gIGlmIChyZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmLmN1cnJlbnQgPSB7XG4gICAgICB2YWx1ZTogdHlwZW9mIGluaXRpYWxWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gaW5pdGlhbFZhbHVlKCkgOiBpbml0aWFsVmFsdWVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHJlZi5jdXJyZW50LnZhbHVlO1xufVxuXG5jb25zdCB1c2VSYWYgPSBjYWxsYmFjayA9PiB7XG4gIGNvbnN0IGNiID0gdXNlUmVmKGNhbGxiYWNrKTtcbiAgY29uc3QgcmFmID0gdXNlUmVmKDApO1xuICBjb25zdCBsYXN0RnJhbWUgPSB1c2VSZWYoMCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2IuY3VycmVudCA9IGNhbGxiYWNrO1xuICB9LCBbY2FsbGJhY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb29wID0gKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkZWx0YSA9IG5vdyAtIGxhc3RGcmFtZS5jdXJyZW50O1xuICAgICAgcmFmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgICBjYi5jdXJyZW50KGRlbHRhIC8gMTAwMCk7XG4gICAgICBsYXN0RnJhbWUuY3VycmVudCA9IG5vdztcbiAgICB9O1xuXG4gICAgcmFmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZi5jdXJyZW50KTtcbiAgfSwgW10pO1xufTtcblxuY29uc3QgVXNlRnJhbWVTdGVwcGVyID0gKHtcbiAgb25TdGVwLFxuICB1cGRhdGVQcmlvcml0eVxufSkgPT4ge1xuICB1c2VGcmFtZSgoXywgZHQpID0+IHtcbiAgICBvblN0ZXAoZHQpO1xuICB9LCB1cGRhdGVQcmlvcml0eSk7XG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgUmFmU3RlcHBlciA9ICh7XG4gIG9uU3RlcFxufSkgPT4ge1xuICB1c2VSYWYoZHQgPT4ge1xuICAgIG9uU3RlcChkdCk7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IEZyYW1lU3RlcHBlciA9ICh7XG4gIG9uU3RlcCxcbiAgdHlwZSxcbiAgdXBkYXRlUHJpb3JpdHlcbn0pID0+IHtcbiAgcmV0dXJuIHR5cGUgPT09IFwiaW5kZXBlbmRlbnRcIiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJhZlN0ZXBwZXIsIHtcbiAgICBvblN0ZXA6IG9uU3RlcFxuICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFVzZUZyYW1lU3RlcHBlciwge1xuICAgIG9uU3RlcDogb25TdGVwLFxuICAgIHVwZGF0ZVByaW9yaXR5OiB1cGRhdGVQcmlvcml0eVxuICB9KTtcbn07XG5cbnZhciBGcmFtZVN0ZXBwZXIkMSA9IC8qI19fUFVSRV9fKi9tZW1vKEZyYW1lU3RlcHBlcik7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBfZXhjbHVkZWQkMiA9IFtcIm1hc3NcIiwgXCJsaW5lYXJEYW1waW5nXCIsIFwiYW5ndWxhckRhbXBpbmdcIiwgXCJ0eXBlXCIsIFwib25Db2xsaXNpb25FbnRlclwiLCBcIm9uQ29sbGlzaW9uRXhpdFwiLCBcIm9uSW50ZXJzZWN0aW9uRW50ZXJcIiwgXCJvbkludGVyc2VjdGlvbkV4aXRcIiwgXCJvbkNvbnRhY3RGb3JjZVwiLCBcImNoaWxkcmVuXCIsIFwiY2FuU2xlZXBcIiwgXCJjY2RcIiwgXCJncmF2aXR5U2NhbGVcIl07XG5jb25zdCBzY2FsZUNvbGxpZGVyQXJncyA9IChzaGFwZSwgYXJncywgc2NhbGUpID0+IHtcbiAgY29uc3QgbmV3QXJncyA9IGFyZ3Muc2xpY2UoKTsgLy8gSGVpZ2h0ZmllbGQgdXNlcyBhIHZlY3RvclxuXG4gIGlmIChzaGFwZSA9PT0gXCJoZWlnaHRmaWVsZFwiKSB7XG4gICAgY29uc3QgcyA9IG5ld0FyZ3NbM107XG4gICAgcy54ICo9IHNjYWxlLng7XG4gICAgcy54ICo9IHNjYWxlLnk7XG4gICAgcy54ICo9IHNjYWxlLno7XG4gICAgcmV0dXJuIG5ld0FyZ3M7XG4gIH0gLy8gVHJpbWVzaCBhbmQgY29udmV4IHNjYWxlIHRoZSB2ZXJ0aWNlc1xuXG5cbiAgaWYgKHNoYXBlID09PSBcInRyaW1lc2hcIiB8fCBzaGFwZSA9PT0gXCJjb252ZXhIdWxsXCIpIHtcbiAgICBuZXdBcmdzWzBdID0gc2NhbGVWZXJ0aWNlcyhuZXdBcmdzWzBdLCBzY2FsZSk7XG4gICAgcmV0dXJuIG5ld0FyZ3M7XG4gIH0gLy8gUHJlcGZpbGwgd2l0aCBzb21lIGV4dHJhXG5cblxuICBjb25zdCBzY2FsZUFycmF5ID0gW3NjYWxlLngsIHNjYWxlLnksIHNjYWxlLnosIHNjYWxlLngsIHNjYWxlLnhdO1xuICByZXR1cm4gbmV3QXJncy5tYXAoKGFyZywgaW5kZXgpID0+IHNjYWxlQXJyYXlbaW5kZXhdICogYXJnKTtcbn07XG5jb25zdCBjcmVhdGVDb2xsaWRlckZyb21PcHRpb25zID0gKG9wdGlvbnMsIHdvcmxkLCBzY2FsZSwgZ2V0UmlnaWRCb2R5KSA9PiB7XG4gIGNvbnN0IHNjYWxlZEFyZ3MgPSBzY2FsZUNvbGxpZGVyQXJncyhvcHRpb25zLnNoYXBlLCBvcHRpb25zLmFyZ3MsIHNjYWxlKTsgLy8gQHRzLWlnbm9yZVxuXG4gIGNvbnN0IGRlc2MgPSBDb2xsaWRlckRlc2Nbb3B0aW9ucy5zaGFwZV0oLi4uc2NhbGVkQXJncyk7XG4gIHJldHVybiB3b3JsZC5jcmVhdGVDb2xsaWRlcihkZXNjLCBnZXRSaWdpZEJvZHkgPT09IG51bGwgfHwgZ2V0UmlnaWRCb2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRSaWdpZEJvZHkoKSk7XG59O1xuY29uc3QgaW1tdXRhYmxlQ29sbGlkZXJPcHRpb25zID0gW1wic2hhcGVcIiwgXCJhcmdzXCJdO1xuY29uc3QgbWFzc1Byb3BlcnRpZXNDb25mbGljdEVycm9yID0gXCJQbGVhc2UgcGljayBPTkxZIE9ORSBvZiB0aGUgYGRlbnNpdHlgLCBgbWFzc2AgYW5kIGBtYXNzUHJvcGVydGllc2Agb3B0aW9ucy5cIjtcblxuY29uc3Qgc2V0Q29sbGlkZXJNYXNzT3B0aW9ucyA9IChjb2xsaWRlciwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucy5kZW5zaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5tYXNzICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXNzUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWFzc1Byb3BlcnRpZXNDb25mbGljdEVycm9yKTtcbiAgICB9XG5cbiAgICBjb2xsaWRlci5zZXREZW5zaXR5KG9wdGlvbnMuZGVuc2l0eSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubWFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMubWFzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1hc3NQcm9wZXJ0aWVzQ29uZmxpY3RFcnJvcik7XG4gICAgfVxuXG4gICAgY29sbGlkZXIuc2V0TWFzcyhvcHRpb25zLm1hc3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvcHRpb25zLm1hc3NQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb2xsaWRlci5zZXRNYXNzUHJvcGVydGllcyhvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLm1hc3MsIG9wdGlvbnMubWFzc1Byb3BlcnRpZXMuY2VudGVyT2ZNYXNzLCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLnByaW5jaXBhbEFuZ3VsYXJJbmVydGlhLCBvcHRpb25zLm1hc3NQcm9wZXJ0aWVzLmFuZ3VsYXJJbmVydGlhTG9jYWxGcmFtZSk7XG4gIH1cbn07XG5cbmNvbnN0IG11dGFibGVDb2xsaWRlck9wdGlvbnMgPSB7XG4gIHNlbnNvcjogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldFNlbnNvcih2YWx1ZSk7XG4gIH0sXG4gIGNvbGxpc2lvbkdyb3VwczogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldENvbGxpc2lvbkdyb3Vwcyh2YWx1ZSk7XG4gIH0sXG4gIHNvbHZlckdyb3VwczogKGNvbGxpZGVyLCB2YWx1ZSkgPT4ge1xuICAgIGNvbGxpZGVyLnNldFNvbHZlckdyb3Vwcyh2YWx1ZSk7XG4gIH0sXG4gIGZyaWN0aW9uOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0RnJpY3Rpb24odmFsdWUpO1xuICB9LFxuICBmcmljdGlvbkNvbWJpbmVSdWxlOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0RnJpY3Rpb25Db21iaW5lUnVsZSh2YWx1ZSk7XG4gIH0sXG4gIHJlc3RpdHV0aW9uOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0UmVzdGl0dXRpb24odmFsdWUpO1xuICB9LFxuICByZXN0aXR1dGlvbkNvbWJpbmVSdWxlOiAoY29sbGlkZXIsIHZhbHVlKSA9PiB7XG4gICAgY29sbGlkZXIuc2V0UmVzdGl0dXRpb25Db21iaW5lUnVsZSh2YWx1ZSk7XG4gIH0sXG4gIC8vIFRvIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBhbGwgbXV0YWJsZSBvcHRpb25zIGFyZSBsaXN0ZWRcbiAgcXVhdGVybmlvbjogKCkgPT4ge30sXG4gIHBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgcm90YXRpb246ICgpID0+IHt9LFxuICBzY2FsZTogKCkgPT4ge31cbn07XG5jb25zdCBtdXRhYmxlQ29sbGlkZXJPcHRpb25LZXlzID0gT2JqZWN0LmtleXMobXV0YWJsZUNvbGxpZGVyT3B0aW9ucyk7XG5jb25zdCBzZXRDb2xsaWRlck9wdGlvbnMgPSAoY29sbGlkZXIsIG9wdGlvbnMsIHN0YXRlcykgPT4ge1xuICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQoY29sbGlkZXIuaGFuZGxlKTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICB2YXIgX3N0YXRlJHdvcmxkUGFyZW50O1xuXG4gICAgLy8gVXBkYXRlIGNvbGxpZGVyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBvYmplY3QncyBwb3NpdGlvblxuICAgIGNvbnN0IHBhcmVudFdvcmxkU2NhbGUgPSBzdGF0ZS5vYmplY3QucGFyZW50LmdldFdvcmxkU2NhbGUoX3ZlY3RvcjMpO1xuICAgIGNvbnN0IHBhcmVudEludmVydGVkV29ybGRNYXRyaXggPSAoX3N0YXRlJHdvcmxkUGFyZW50ID0gc3RhdGUud29ybGRQYXJlbnQpID09PSBudWxsIHx8IF9zdGF0ZSR3b3JsZFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJHdvcmxkUGFyZW50Lm1hdHJpeFdvcmxkLmNsb25lKCkuaW52ZXJ0KCk7XG4gICAgc3RhdGUub2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblxuICAgIF9tYXRyaXg0LmNvcHkoc3RhdGUub2JqZWN0Lm1hdHJpeFdvcmxkKTtcblxuICAgIGlmIChwYXJlbnRJbnZlcnRlZFdvcmxkTWF0cml4KSB7XG4gICAgICBfbWF0cml4NC5wcmVtdWx0aXBseShwYXJlbnRJbnZlcnRlZFdvcmxkTWF0cml4KTtcbiAgICB9XG5cbiAgICBfbWF0cml4NC5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7XG5cbiAgICBpZiAoY29sbGlkZXIucGFyZW50KCkpIHtcbiAgICAgIGNvbGxpZGVyLnNldFRyYW5zbGF0aW9uV3J0UGFyZW50KHtcbiAgICAgICAgeDogX3Bvc2l0aW9uLnggKiBwYXJlbnRXb3JsZFNjYWxlLngsXG4gICAgICAgIHk6IF9wb3NpdGlvbi55ICogcGFyZW50V29ybGRTY2FsZS55LFxuICAgICAgICB6OiBfcG9zaXRpb24ueiAqIHBhcmVudFdvcmxkU2NhbGUuelxuICAgICAgfSk7XG4gICAgICBjb2xsaWRlci5zZXRSb3RhdGlvbldydFBhcmVudChfcm90YXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xsaWRlci5zZXRUcmFuc2xhdGlvbih7XG4gICAgICAgIHg6IF9wb3NpdGlvbi54ICogcGFyZW50V29ybGRTY2FsZS54LFxuICAgICAgICB5OiBfcG9zaXRpb24ueSAqIHBhcmVudFdvcmxkU2NhbGUueSxcbiAgICAgICAgejogX3Bvc2l0aW9uLnogKiBwYXJlbnRXb3JsZFNjYWxlLnpcbiAgICAgIH0pO1xuICAgICAgY29sbGlkZXIuc2V0Um90YXRpb24oX3JvdGF0aW9uKTtcbiAgICB9XG5cbiAgICBtdXRhYmxlQ29sbGlkZXJPcHRpb25LZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBvcHRpb25zW2tleV07XG4gICAgICAgIG11dGFibGVDb2xsaWRlck9wdGlvbnNba2V5XShjb2xsaWRlciwgLy8gQHRzLWlnbm9yZSBPcHRpb24gZG9lcyBub3Qgd2FudCB0byBmaXQgaW50byB0aGUgZnVuY3Rpb24sIGJ1dCBpdCB3aWxsXG4gICAgICAgIG9wdGlvbiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7IC8vIGhhbmRsZSBtYXNzIHNlcGFyYXRlbHksIGJlY2F1c2UgdGhlIGFzc2lnbm1lbnRzXG4gICAgLy8gYXJlIGV4Y2x1c2l2ZS5cblxuICAgIHNldENvbGxpZGVyTWFzc09wdGlvbnMoY29sbGlkZXIsIG9wdGlvbnMpO1xuICB9XG59O1xuY29uc3QgdXNlVXBkYXRlQ29sbGlkZXJPcHRpb25zID0gKGdldENvbGxpZGVyLCBwcm9wcywgc3RhdGVzKSA9PiB7XG4gIC8vIFRPRE86IEltcHJvdmUgdGhpcywgc3BsaXQgZWFjaCBwcm9wIGludG8gaXRzIG93biBlZmZlY3RcbiAgY29uc3QgbXV0YWJsZVByb3BzQXNGbGF0QXJyYXkgPSB1c2VNZW1vKCgpID0+IG11dGFibGVDb2xsaWRlck9wdGlvbktleXMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiB2ZWN0b3JUb1R1cGxlKHByb3BzW2tleV0pO1xuICB9KSwgW3Byb3BzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29sbGlkZXIgPSBnZXRDb2xsaWRlcigpO1xuICAgIHNldENvbGxpZGVyT3B0aW9ucyhjb2xsaWRlciwgcHJvcHMsIHN0YXRlcyk7XG4gIH0sIFsuLi5tdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSwgZ2V0Q29sbGlkZXJdKTtcbn07XG5cbmNvbnN0IGlzQ2hpbGRPZk1lc2hDb2xsaWRlciA9IGNoaWxkID0+IHtcbiAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgY2hpbGQudHJhdmVyc2VBbmNlc3RvcnMoYSA9PiB7XG4gICAgaWYgKGEudXNlckRhdGEucjNSYXBpZXJUeXBlID09PSBcIk1lc2hDb2xsaWRlclwiKSBmbGFnID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiBmbGFnO1xufTtcblxuY29uc3QgY3JlYXRlQ29sbGlkZXJTdGF0ZSA9IChjb2xsaWRlciwgb2JqZWN0LCByaWdpZEJvZHlPYmplY3QpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBjb2xsaWRlcixcbiAgICB3b3JsZFBhcmVudDogcmlnaWRCb2R5T2JqZWN0IHx8IHVuZGVmaW5lZCxcbiAgICBvYmplY3RcbiAgfTtcbn07XG5jb25zdCBhdXRvQ29sbGlkZXJNYXAgPSB7XG4gIGN1Ym9pZDogXCJjdWJvaWRcIixcbiAgYmFsbDogXCJiYWxsXCIsXG4gIGh1bGw6IFwiY29udmV4SHVsbFwiLFxuICB0cmltZXNoOiBcInRyaW1lc2hcIlxufTtcbmNvbnN0IGNyZWF0ZUNvbGxpZGVyUHJvcHNGcm9tQ2hpbGRyZW4gPSAoe1xuICBvYmplY3QsXG4gIGlnbm9yZU1lc2hDb2xsaWRlcnM6IF9pZ25vcmVNZXNoQ29sbGlkZXJzID0gdHJ1ZSxcbiAgb3B0aW9uc1xufSkgPT4ge1xuICBjb25zdCBjaGlsZENvbGxpZGVyUHJvcHMgPSBbXTtcbiAgb2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcbiAgY29uc3QgaW52ZXJ0ZWRQYXJlbnRNYXRyaXhXb3JsZCA9IG9iamVjdC5tYXRyaXhXb3JsZC5jbG9uZSgpLmludmVydCgpO1xuXG4gIGNvbnN0IGNvbGxpZGVyRnJvbUNoaWxkID0gY2hpbGQgPT4ge1xuICAgIGlmIChcImlzTWVzaFwiIGluIGNoaWxkKSB7XG4gICAgICBpZiAoX2lnbm9yZU1lc2hDb2xsaWRlcnMgJiYgaXNDaGlsZE9mTWVzaENvbGxpZGVyKGNoaWxkKSkgcmV0dXJuO1xuICAgICAgY29uc3Qgd29ybGRTY2FsZSA9IGNoaWxkLmdldFdvcmxkU2NhbGUoX3NjYWxlKTtcbiAgICAgIGNvbnN0IHNoYXBlID0gYXV0b0NvbGxpZGVyTWFwW29wdGlvbnMuY29sbGlkZXJzIHx8IFwiY3Vib2lkXCJdO1xuICAgICAgY2hpbGQudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuXG4gICAgICBfbWF0cml4NC5jb3B5KGNoaWxkLm1hdHJpeFdvcmxkKS5wcmVtdWx0aXBseShpbnZlcnRlZFBhcmVudE1hdHJpeFdvcmxkKS5kZWNvbXBvc2UoX3Bvc2l0aW9uLCBfcm90YXRpb24sIF9zY2FsZSk7XG5cbiAgICAgIGNvbnN0IHJvdGF0aW9uRXVsZXIgPSBuZXcgRXVsZXIoKS5zZXRGcm9tUXVhdGVybmlvbihfcm90YXRpb24sIFwiWFlaXCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBnZW9tZXRyeVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcmdzLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBnZXRDb2xsaWRlckFyZ3NGcm9tR2VvbWV0cnkoZ2VvbWV0cnksIG9wdGlvbnMuY29sbGlkZXJzIHx8IFwiY3Vib2lkXCIpO1xuXG4gICAgICBjb25zdCBjb2xsaWRlclByb3BzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlcihvcHRpb25zKSksIHt9LCB7XG4gICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgcm90YXRpb246IFtyb3RhdGlvbkV1bGVyLngsIHJvdGF0aW9uRXVsZXIueSwgcm90YXRpb25FdWxlci56XSxcbiAgICAgICAgcG9zaXRpb246IFtfcG9zaXRpb24ueCArIG9mZnNldC54ICogd29ybGRTY2FsZS54LCBfcG9zaXRpb24ueSArIG9mZnNldC55ICogd29ybGRTY2FsZS55LCBfcG9zaXRpb24ueiArIG9mZnNldC56ICogd29ybGRTY2FsZS56XSxcbiAgICAgICAgc2NhbGU6IFt3b3JsZFNjYWxlLngsIHdvcmxkU2NhbGUueSwgd29ybGRTY2FsZS56XVxuICAgICAgfSk7XG5cbiAgICAgIGNoaWxkQ29sbGlkZXJQcm9wcy5wdXNoKGNvbGxpZGVyUHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBpZiAob3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlKSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKGNvbGxpZGVyRnJvbUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3QudHJhdmVyc2VWaXNpYmxlKGNvbGxpZGVyRnJvbUNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZENvbGxpZGVyUHJvcHM7XG59O1xuY29uc3QgZ2V0Q29sbGlkZXJBcmdzRnJvbUdlb21ldHJ5ID0gKGdlb21ldHJ5LCBjb2xsaWRlcnMpID0+IHtcbiAgc3dpdGNoIChjb2xsaWRlcnMpIHtcbiAgICBjYXNlIFwiY3Vib2lkXCI6XG4gICAgICB7XG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYm91bmRpbmdCb3hcbiAgICAgICAgfSA9IGdlb21ldHJ5O1xuICAgICAgICBjb25zdCBzaXplID0gYm91bmRpbmdCb3guZ2V0U2l6ZShuZXcgVmVjdG9yMygpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbc2l6ZS54IC8gMiwgc2l6ZS55IC8gMiwgc2l6ZS56IC8gMl0sXG4gICAgICAgICAgb2Zmc2V0OiBib3VuZGluZ0JveC5nZXRDZW50ZXIobmV3IFZlY3RvcjMoKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJiYWxsXCI6XG4gICAgICB7XG4gICAgICAgIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYm91bmRpbmdTcGhlcmVcbiAgICAgICAgfSA9IGdlb21ldHJ5O1xuICAgICAgICBjb25zdCByYWRpdXMgPSBib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXJnczogW3JhZGl1c10sXG4gICAgICAgICAgb2Zmc2V0OiBib3VuZGluZ1NwaGVyZS5jZW50ZXJcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJ0cmltZXNoXCI6XG4gICAgICB7XG4gICAgICAgIHZhciBfY2xvbmVkR2VvbWV0cnkkaW5kZXg7XG5cbiAgICAgICAgY29uc3QgY2xvbmVkR2VvbWV0cnkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmNsb25lKCkgOiBtZXJnZVZlcnRpY2VzKGdlb21ldHJ5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbY2xvbmVkR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheSwgKF9jbG9uZWRHZW9tZXRyeSRpbmRleCA9IGNsb25lZEdlb21ldHJ5LmluZGV4KSA9PT0gbnVsbCB8fCBfY2xvbmVkR2VvbWV0cnkkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jbG9uZWRHZW9tZXRyeSRpbmRleC5hcnJheV0sXG4gICAgICAgICAgb2Zmc2V0OiBuZXcgVmVjdG9yMygpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlIFwiaHVsbFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCBnID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhcmdzOiBbZy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5XSxcbiAgICAgICAgICBvZmZzZXQ6IG5ldyBWZWN0b3IzKClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYXJnczogW10sXG4gICAgb2Zmc2V0OiBuZXcgVmVjdG9yMygpXG4gIH07XG59O1xuY29uc3QgZ2V0QWN0aXZlQ29sbGlzaW9uRXZlbnRzRnJvbVByb3BzID0gcHJvcHMgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbGxpc2lvbjogISEocHJvcHMgIT09IG51bGwgJiYgcHJvcHMgIT09IHZvaWQgMCAmJiBwcm9wcy5vbkNvbGxpc2lvbkVudGVyIHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25Db2xsaXNpb25FeGl0IHx8IHByb3BzICE9PSBudWxsICYmIHByb3BzICE9PSB2b2lkIDAgJiYgcHJvcHMub25JbnRlcnNlY3Rpb25FbnRlciB8fCBwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uSW50ZXJzZWN0aW9uRXhpdCksXG4gICAgY29udGFjdEZvcmNlOiAhIShwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdm9pZCAwICYmIHByb3BzLm9uQ29udGFjdEZvcmNlKVxuICB9O1xufTtcbmNvbnN0IHVzZUNvbGxpZGVyRXZlbnRzID0gKGdldENvbGxpZGVyLCBwcm9wcywgZXZlbnRzLFxuLyoqXG4gKiBUaGUgUmlnaWRCb2R5IGNhbiBwYXNzIGRvd24gYWN0aXZlIGV2ZW50cyB0byB0aGUgY29sbGlkZXIgd2l0aG91dCBhdHRhY2hpbmcgdGhlIGV2ZW50IGxpc3RuZXJzXG4gKi9cbmFjdGl2ZUV2ZW50cyA9IHt9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgIG9uQ29sbGlzaW9uRXhpdCxcbiAgICBvbkludGVyc2VjdGlvbkVudGVyLFxuICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICBvbkNvbnRhY3RGb3JjZVxuICB9ID0gcHJvcHM7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29sbGlkZXIgPSBnZXRDb2xsaWRlcigpO1xuXG4gICAgaWYgKGNvbGxpZGVyKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxpc2lvbjogY29sbGlzaW9uRXZlbnRzQWN0aXZlLFxuICAgICAgICBjb250YWN0Rm9yY2U6IGNvbnRhY3RGb3JjZUV2ZW50c0FjdGl2ZVxuICAgICAgfSA9IGdldEFjdGl2ZUNvbGxpc2lvbkV2ZW50c0Zyb21Qcm9wcyhwcm9wcyk7XG4gICAgICBjb25zdCBoYXNDb2xsaXNpb25FdmVudCA9IGNvbGxpc2lvbkV2ZW50c0FjdGl2ZSB8fCBhY3RpdmVFdmVudHMuY29sbGlzaW9uO1xuICAgICAgY29uc3QgaGFzQ29udGFjdEZvcmNlRXZlbnQgPSBjb250YWN0Rm9yY2VFdmVudHNBY3RpdmUgfHwgYWN0aXZlRXZlbnRzLmNvbnRhY3RGb3JjZTtcblxuICAgICAgaWYgKGhhc0NvbGxpc2lvbkV2ZW50ICYmIGhhc0NvbnRhY3RGb3JjZUV2ZW50KSB7XG4gICAgICAgIGNvbGxpZGVyLnNldEFjdGl2ZUV2ZW50cyhBY3RpdmVFdmVudHMuQ09MTElTSU9OX0VWRU5UUyB8IEFjdGl2ZUV2ZW50cy5DT05UQUNUX0ZPUkNFX0VWRU5UUyk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbGxpc2lvbkV2ZW50KSB7XG4gICAgICAgIGNvbGxpZGVyLnNldEFjdGl2ZUV2ZW50cyhBY3RpdmVFdmVudHMuQ09MTElTSU9OX0VWRU5UUyk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbnRhY3RGb3JjZUV2ZW50KSB7XG4gICAgICAgIGNvbGxpZGVyLnNldEFjdGl2ZUV2ZW50cyhBY3RpdmVFdmVudHMuQ09OVEFDVF9GT1JDRV9FVkVOVFMpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMuc2V0KGNvbGxpZGVyLmhhbmRsZSwge1xuICAgICAgICBvbkNvbGxpc2lvbkVudGVyLFxuICAgICAgICBvbkNvbGxpc2lvbkV4aXQsXG4gICAgICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgICAgIG9uSW50ZXJzZWN0aW9uRXhpdCxcbiAgICAgICAgb25Db250YWN0Rm9yY2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoY29sbGlkZXIpIHtcbiAgICAgICAgZXZlbnRzLmRlbGV0ZShjb2xsaWRlci5oYW5kbGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvbkNvbGxpc2lvbkVudGVyLCBvbkNvbGxpc2lvbkV4aXQsIG9uSW50ZXJzZWN0aW9uRW50ZXIsIG9uSW50ZXJzZWN0aW9uRXhpdCwgb25Db250YWN0Rm9yY2UsIGFjdGl2ZUV2ZW50c10pO1xufTtcbmNvbnN0IGNsZWFuUmlnaWRCb2R5UHJvcHNGb3JDb2xsaWRlciA9IChwcm9wcyA9IHt9KSA9PiB7XG4gIGNvbnN0IHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQyKTtcblxuICByZXR1cm4gcmVzdDtcbn07XG5cbmNvbnN0IHVzZU11dGFibGVDYWxsYmFjayA9IGZuID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKGZuKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IGZuO1xuICB9LCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn07IC8vIEV4dGVybmFsIGhvb2tzXG5cbi8qKlxuICogRXhwb3NlcyB0aGUgUmFwaWVyIGNvbnRleHQsIGFuZCB3b3JsZFxuICogQGNhdGVnb3J5IEhvb2tzXG4gKi9cblxuXG5jb25zdCB1c2VSYXBpZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHJhcGllciA9IHVzZUNvbnRleHQocmFwaWVyQ29udGV4dCk7XG4gIGlmICghcmFwaWVyKSB0aHJvdyBuZXcgRXJyb3IoXCJyZWFjdC10aHJlZS1yYXBpZXI6IHVzZVJhcGllciBtdXN0IGJlIHVzZWQgd2l0aGluIDxQaHlzaWNzIC8+IVwiKTtcbiAgcmV0dXJuIHJhcGllcjtcbn07XG4vKipcbiAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBiZWZvcmUgdGhlIHBoeXNpY3Mgc3RlcFxuICogQGNhdGVnb3J5IEhvb2tzXG4gKi9cblxuY29uc3QgdXNlQmVmb3JlUGh5c2ljc1N0ZXAgPSBjYWxsYmFjayA9PiB7XG4gIGNvbnN0IHtcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLmFkZChyZWYpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLmRlbGV0ZShyZWYpO1xuICAgIH07XG4gIH0sIFtdKTtcbn07XG4vKipcbiAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBhZnRlciB0aGUgcGh5c2ljcyBzdGVwXG4gKiBAY2F0ZWdvcnkgSG9va3NcbiAqL1xuXG5jb25zdCB1c2VBZnRlclBoeXNpY3NTdGVwID0gY2FsbGJhY2sgPT4ge1xuICBjb25zdCB7XG4gICAgYWZ0ZXJTdGVwQ2FsbGJhY2tzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBhZnRlclN0ZXBDYWxsYmFja3MuYWRkKHJlZik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrcy5kZWxldGUocmVmKTtcbiAgICB9O1xuICB9LCBbXSk7XG59OyAvLyBJbnRlcm5hbCBob29rc1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmNvbnN0IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyA9IChyZWYsIG9wdGlvbnMsIGlnbm9yZU1lc2hDb2xsaWRlcnMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IFtjb2xsaWRlclByb3BzLCBzZXRDb2xsaWRlclByb3BzXSA9IHVzZVN0YXRlKFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvYmplY3QgPSByZWYuY3VycmVudDtcblxuICAgIGlmIChvYmplY3QgJiYgb3B0aW9ucy5jb2xsaWRlcnMgIT09IGZhbHNlKSB7XG4gICAgICBzZXRDb2xsaWRlclByb3BzKGNyZWF0ZUNvbGxpZGVyUHJvcHNGcm9tQ2hpbGRyZW4oe1xuICAgICAgICBvYmplY3Q6IHJlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpZ25vcmVNZXNoQ29sbGlkZXJzXG4gICAgICB9KSk7XG4gICAgfVxuICB9LCBbb3B0aW9ucy5jb2xsaWRlcnNdKTtcbiAgcmV0dXJuIGNvbGxpZGVyUHJvcHM7XG59O1xuXG5jb25zdCBEZWJ1ZyA9IC8qI19fUFVSRV9fKi9tZW1vKCgpID0+IHtcbiAgY29uc3Qge1xuICAgIHdvcmxkXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgY29uc3QgbWVzaCA9IHJlZi5jdXJyZW50O1xuICAgIGlmICghbWVzaCkgcmV0dXJuO1xuICAgIGNvbnN0IGJ1ZmZlcnMgPSB3b3JsZC5kZWJ1Z1JlbmRlcigpO1xuICAgIG1lc2guZ2VvbWV0cnkuc2V0QXR0cmlidXRlKFwicG9zaXRpb25cIiwgbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXJzLnZlcnRpY2VzLCAzKSk7XG4gICAgbWVzaC5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoXCJjb2xvclwiLCBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcnMuY29sb3JzLCA0KSk7XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVTZWdtZW50c1wiLCB7XG4gICAgcmVmOiByZWYsXG4gICAgZnJ1c3R1bUN1bGxlZDogZmFsc2VcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lQmFzaWNNYXRlcmlhbFwiLCB7XG4gICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgIHZlcnRleENvbG9yczogdHJ1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJHZW9tZXRyeVwiLCBudWxsKSkpO1xufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByb3h5IHRoYXQgd2lsbCBjcmVhdGUgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIGNsYXNzXG4gKiB3aGVuIGEgcHJvcGVydHkgaXMgYWNjZXNzZWQsIGFuZCBub3QgYmVmb3JlLlxuICpcbiAqIEByZXR1cm5zIEEgcHJveHkgYW5kIGEgcmVzZXQgZnVuY3Rpb24sIHNvIHRoYXQgdGhlIGluc3RhbmNlIGNhbiBjcmVhdGVkIGFnYWluXG4gKi9cbmNvbnN0IGNyZWF0ZVNpbmdsZXRvblByb3h5ID0gY3JlYXRlSW5zdGFuY2UgPT4ge1xuICBsZXQgaW5zdGFuY2U7XG4gIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmdldChpbnN0YW5jZSwgcHJvcCk7XG4gICAgfSxcblxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KGluc3RhbmNlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxuXG4gIH07XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCBoYW5kbGVyKTtcblxuICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICBpbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICBjb25zdCBzZXQgPSBuZXdJbnN0YW5jZSA9PiB7XG4gICAgaW5zdGFuY2UgPSBuZXdJbnN0YW5jZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcHJveHkgYW5kIGEgcmVzZXQgZnVuY3Rpb25cbiAgICovXG5cblxuICByZXR1cm4ge1xuICAgIHByb3h5LFxuICAgIHJlc2V0LFxuICAgIHNldFxuICB9O1xufTtcblxuY29uc3QgcmFwaWVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmNvbnN0IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlID0gKHRhcmdldCwgb3RoZXIpID0+IHtcbiAgdmFyIF90YXJnZXQkY29sbGlkZXIkc3RhdCwgX3RhcmdldCRyaWdpZEJvZHkkc3RhLCBfb3RoZXIkY29sbGlkZXIkc3RhdGUsIF9vdGhlciRyaWdpZEJvZHkkc3RhdCwgX290aGVyJGNvbGxpZGVyJHN0YXRlMiwgX290aGVyJHJpZ2lkQm9keSRzdGF0MjtcblxuICByZXR1cm4ge1xuICAgIHRhcmdldDoge1xuICAgICAgcmlnaWRCb2R5OiB0YXJnZXQucmlnaWRCb2R5Lm9iamVjdCxcbiAgICAgIGNvbGxpZGVyOiB0YXJnZXQuY29sbGlkZXIub2JqZWN0LFxuICAgICAgY29sbGlkZXJPYmplY3Q6IChfdGFyZ2V0JGNvbGxpZGVyJHN0YXQgPSB0YXJnZXQuY29sbGlkZXIuc3RhdGUpID09PSBudWxsIHx8IF90YXJnZXQkY29sbGlkZXIkc3RhdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldCRjb2xsaWRlciRzdGF0Lm9iamVjdCxcbiAgICAgIHJpZ2lkQm9keU9iamVjdDogKF90YXJnZXQkcmlnaWRCb2R5JHN0YSA9IHRhcmdldC5yaWdpZEJvZHkuc3RhdGUpID09PSBudWxsIHx8IF90YXJnZXQkcmlnaWRCb2R5JHN0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RhcmdldCRyaWdpZEJvZHkkc3RhLm9iamVjdFxuICAgIH0sXG4gICAgb3RoZXI6IHtcbiAgICAgIHJpZ2lkQm9keTogb3RoZXIucmlnaWRCb2R5Lm9iamVjdCxcbiAgICAgIGNvbGxpZGVyOiBvdGhlci5jb2xsaWRlci5vYmplY3QsXG4gICAgICBjb2xsaWRlck9iamVjdDogKF9vdGhlciRjb2xsaWRlciRzdGF0ZSA9IG90aGVyLmNvbGxpZGVyLnN0YXRlKSA9PT0gbnVsbCB8fCBfb3RoZXIkY29sbGlkZXIkc3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vdGhlciRjb2xsaWRlciRzdGF0ZS5vYmplY3QsXG4gICAgICByaWdpZEJvZHlPYmplY3Q6IChfb3RoZXIkcmlnaWRCb2R5JHN0YXQgPSBvdGhlci5yaWdpZEJvZHkuc3RhdGUpID09PSBudWxsIHx8IF9vdGhlciRyaWdpZEJvZHkkc3RhdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX290aGVyJHJpZ2lkQm9keSRzdGF0Lm9iamVjdFxuICAgIH0sXG4gICAgcmlnaWRCb2R5OiBvdGhlci5yaWdpZEJvZHkub2JqZWN0LFxuICAgIGNvbGxpZGVyOiBvdGhlci5jb2xsaWRlci5vYmplY3QsXG4gICAgY29sbGlkZXJPYmplY3Q6IChfb3RoZXIkY29sbGlkZXIkc3RhdGUyID0gb3RoZXIuY29sbGlkZXIuc3RhdGUpID09PSBudWxsIHx8IF9vdGhlciRjb2xsaWRlciRzdGF0ZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vdGhlciRjb2xsaWRlciRzdGF0ZTIub2JqZWN0LFxuICAgIHJpZ2lkQm9keU9iamVjdDogKF9vdGhlciRyaWdpZEJvZHkkc3RhdDIgPSBvdGhlci5yaWdpZEJvZHkuc3RhdGUpID09PSBudWxsIHx8IF9vdGhlciRyaWdpZEJvZHkkc3RhdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vdGhlciRyaWdpZEJvZHkkc3RhdDIub2JqZWN0XG4gIH07XG59O1xuXG5jb25zdCBpbXBvcnRSYXBpZXIgPSBhc3luYyAoKSA9PiB7XG4gIGxldCByID0gYXdhaXQgaW1wb3J0KCdAZGltZm9yZ2UvcmFwaWVyM2QtY29tcGF0Jyk7XG4gIGF3YWl0IHIuaW5pdCgpO1xuICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogVGhlIG1haW4gcGh5c2ljcyBjb21wb25lbnQgdXNlZCB0byBjcmVhdGUgYSBwaHlzaWNzIHdvcmxkLlxuICogQGNhdGVnb3J5IENvbXBvbmVudHNcbiAqL1xuY29uc3QgUGh5c2ljcyA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbGxpZGVycyA9IFwiY3Vib2lkXCIsXG4gICAgY2hpbGRyZW4sXG4gICAgdGltZVN0ZXAgPSAxIC8gNjAsXG4gICAgcGF1c2VkID0gZmFsc2UsXG4gICAgaW50ZXJwb2xhdGUgPSB0cnVlLFxuICAgIHVwZGF0ZVByaW9yaXR5LFxuICAgIHVwZGF0ZUxvb3AgPSBcImZvbGxvd1wiLFxuICAgIGRlYnVnID0gZmFsc2UsXG4gICAgZ3Jhdml0eSA9IFswLCAtOS44MSwgMF0sXG4gICAgYWxsb3dlZExpbmVhckVycm9yID0gMC4wMDEsXG4gICAgcHJlZGljdGlvbkRpc3RhbmNlID0gMC4wMDIsXG4gICAgbnVtU29sdmVySXRlcmF0aW9ucyA9IDQsXG4gICAgbnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucyA9IDQsXG4gICAgbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zID0gMSxcbiAgICBtaW5Jc2xhbmRTaXplID0gMTI4LFxuICAgIG1heENjZFN1YnN0ZXBzID0gMSxcbiAgICBlcnAgPSAwLjhcbiAgfSA9IHByb3BzO1xuICBjb25zdCByYXBpZXIgPSBzdXNwZW5kKGltcG9ydFJhcGllciwgW1wiQHJlYWN0LXRoZWUvcmFwaWVyXCIsIGltcG9ydFJhcGllcl0pO1xuICBjb25zdCB7XG4gICAgaW52YWxpZGF0ZVxuICB9ID0gdXNlVGhyZWUoKTtcbiAgY29uc3QgcmlnaWRCb2R5U3RhdGVzID0gdXNlQ29uc3QoKCkgPT4gbmV3IE1hcCgpKTtcbiAgY29uc3QgY29sbGlkZXJTdGF0ZXMgPSB1c2VDb25zdCgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCByaWdpZEJvZHlFdmVudHMgPSB1c2VDb25zdCgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCBjb2xsaWRlckV2ZW50cyA9IHVzZUNvbnN0KCgpID0+IG5ldyBNYXAoKSk7XG4gIGNvbnN0IGV2ZW50UXVldWUgPSB1c2VDb25zdCgoKSA9PiBuZXcgRXZlbnRRdWV1ZShmYWxzZSkpO1xuICBjb25zdCBiZWZvcmVTdGVwQ2FsbGJhY2tzID0gdXNlQ29uc3QoKCkgPT4gbmV3IFNldCgpKTtcbiAgY29uc3QgYWZ0ZXJTdGVwQ2FsbGJhY2tzID0gdXNlQ29uc3QoKCkgPT4gbmV3IFNldCgpKTtcbiAgLyoqXG4gICAqIEluaXRpYXRlIHRoZSB3b3JsZFxuICAgKiBUaGlzIGNyZWF0ZXMgYSBzaW5nbGV0b24gcHJveHksIHNvIHRoYXQgdGhlIHdvcmxkIGlzIG9ubHkgY3JlYXRlZCB3aGVuXG4gICAqIHNvbWV0aGluZyB3aXRoaW4gaXQgaXMgYWNjZXNzZWQuXG4gICAqL1xuXG4gIGNvbnN0IHtcbiAgICBwcm94eTogd29ybGRQcm94eSxcbiAgICByZXNldDogcmVzZXRXb3JsZFByb3h5LFxuICAgIHNldDogc2V0V29ybGRQcm94eVxuICB9ID0gdXNlQ29uc3QoKCkgPT4gY3JlYXRlU2luZ2xldG9uUHJveHkoKCkgPT4gbmV3IHJhcGllci5Xb3JsZCh2ZWN0b3JBcnJheVRvVmVjdG9yMyhncmF2aXR5KSkpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd29ybGRQcm94eS5mcmVlKCk7XG4gICAgICByZXNldFdvcmxkUHJveHkoKTtcbiAgICB9O1xuICB9LCBbXSk7IC8vIFVwZGF0ZSBtdXRhYmxlIHByb3BzXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB3b3JsZFByb3h5LmdyYXZpdHkgPSB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoZ3Jhdml0eSk7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubnVtU29sdmVySXRlcmF0aW9ucyA9IG51bVNvbHZlckl0ZXJhdGlvbnM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubnVtQWRkaXRpb25hbEZyaWN0aW9uSXRlcmF0aW9ucyA9IG51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnM7XG4gICAgd29ybGRQcm94eS5pbnRlZ3JhdGlvblBhcmFtZXRlcnMubnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zID0gbnVtSW50ZXJuYWxQZ3NJdGVyYXRpb25zO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLmFsbG93ZWRMaW5lYXJFcnJvciA9IGFsbG93ZWRMaW5lYXJFcnJvcjtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5taW5Jc2xhbmRTaXplID0gbWluSXNsYW5kU2l6ZTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5tYXhDY2RTdWJzdGVwcyA9IG1heENjZFN1YnN0ZXBzO1xuICAgIHdvcmxkUHJveHkuaW50ZWdyYXRpb25QYXJhbWV0ZXJzLnByZWRpY3Rpb25EaXN0YW5jZSA9IHByZWRpY3Rpb25EaXN0YW5jZTtcbiAgICB3b3JsZFByb3h5LmludGVncmF0aW9uUGFyYW1ldGVycy5lcnAgPSBlcnA7XG4gIH0sIFt3b3JsZFByb3h5LCAuLi5ncmF2aXR5LCBudW1Tb2x2ZXJJdGVyYXRpb25zLCBudW1BZGRpdGlvbmFsRnJpY3Rpb25JdGVyYXRpb25zLCBudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnMsIGFsbG93ZWRMaW5lYXJFcnJvciwgbWluSXNsYW5kU2l6ZSwgbWF4Q2NkU3Vic3RlcHMsIHByZWRpY3Rpb25EaXN0YW5jZSwgZXJwXSk7XG4gIGNvbnN0IGdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZSA9IHVzZUNhbGxiYWNrKGhhbmRsZSA9PiB7XG4gICAgdmFyIF9jb2xsaWRlciRwYXJlbnQ7XG5cbiAgICBjb25zdCBjb2xsaWRlciA9IHdvcmxkUHJveHkuZ2V0Q29sbGlkZXIoaGFuZGxlKTtcbiAgICBjb25zdCBjb2xFdmVudHMgPSBjb2xsaWRlckV2ZW50cy5nZXQoaGFuZGxlKTtcbiAgICBjb25zdCBjb2xsaWRlclN0YXRlID0gY29sbGlkZXJTdGF0ZXMuZ2V0KGhhbmRsZSk7XG4gICAgY29uc3QgcmlnaWRCb2R5SGFuZGxlID0gY29sbGlkZXIgPT09IG51bGwgfHwgY29sbGlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfY29sbGlkZXIkcGFyZW50ID0gY29sbGlkZXIucGFyZW50KCkpID09PSBudWxsIHx8IF9jb2xsaWRlciRwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb2xsaWRlciRwYXJlbnQuaGFuZGxlO1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gd29ybGRQcm94eS5nZXRSaWdpZEJvZHkocmlnaWRCb2R5SGFuZGxlKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByYkV2ZW50cyA9IHJpZ2lkQm9keSAmJiByaWdpZEJvZHlIYW5kbGUgIT09IHVuZGVmaW5lZCA/IHJpZ2lkQm9keUV2ZW50cy5nZXQocmlnaWRCb2R5SGFuZGxlKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByaWdpZEJvZHlTdGF0ZSA9IHJpZ2lkQm9keUhhbmRsZSAhPT0gdW5kZWZpbmVkID8gcmlnaWRCb2R5U3RhdGVzLmdldChyaWdpZEJvZHlIYW5kbGUpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHNvdXJjZSA9IHtcbiAgICAgIGNvbGxpZGVyOiB7XG4gICAgICAgIG9iamVjdDogY29sbGlkZXIsXG4gICAgICAgIGV2ZW50czogY29sRXZlbnRzLFxuICAgICAgICBzdGF0ZTogY29sbGlkZXJTdGF0ZVxuICAgICAgfSxcbiAgICAgIHJpZ2lkQm9keToge1xuICAgICAgICBvYmplY3Q6IHJpZ2lkQm9keSxcbiAgICAgICAgZXZlbnRzOiByYkV2ZW50cyxcbiAgICAgICAgc3RhdGU6IHJpZ2lkQm9keVN0YXRlXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LCBbXSk7XG4gIGNvbnN0IFtzdGVwcGluZ1N0YXRlXSA9IHVzZVN0YXRlKHtcbiAgICBwcmV2aW91c1N0YXRlOiB7fSxcbiAgICBhY2N1bXVsYXRvcjogMFxuICB9KTtcbiAgY29uc3Qgc3RlcCA9IHVzZUNhbGxiYWNrKGR0ID0+IHtcbiAgICBjb25zdCB3b3JsZCA9IHdvcmxkUHJveHk7XG4gICAgLyogQ2hlY2sgaWYgdGhlIHRpbWVzdGVwIGlzIHN1cHBvc2VkIHRvIGJlIHZhcmlhYmxlLiBXZSdsbCBkbyB0aGlzIGhlcmVcbiAgICAgIG9uY2Ugc28gd2UgZG9uJ3QgaGF2ZSB0byBzdHJpbmctY2hlY2sgZXZlcnkgZnJhbWUuICovXG5cbiAgICBjb25zdCB0aW1lU3RlcFZhcmlhYmxlID0gdGltZVN0ZXAgPT09IFwidmFyeVwiO1xuICAgIC8qKlxuICAgICAqIEZpeGVkIHRpbWVTdGVwIHNpbXVsYXRpb24gcHJvZ3Jlc3Npb25cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2FmZmVyb25nYW1lcy5jb20vcG9zdC9maXhfeW91cl90aW1lc3RlcC9cbiAgICAgKi9cblxuICAgIGNvbnN0IGNsYW1wZWREZWx0YSA9IE1hdGhVdGlscy5jbGFtcChkdCwgMCwgMC41KTtcblxuICAgIGNvbnN0IHN0ZXBXb3JsZCA9IGRlbHRhID0+IHtcbiAgICAgIC8vIFRyaWdnZXIgYmVmb3JlU3RlcCBjYWxsYmFja3NcbiAgICAgIGJlZm9yZVN0ZXBDYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiB7XG4gICAgICAgIGNhbGxiYWNrLmN1cnJlbnQod29ybGQpO1xuICAgICAgfSk7XG4gICAgICB3b3JsZC50aW1lc3RlcCA9IGRlbHRhO1xuICAgICAgd29ybGQuc3RlcChldmVudFF1ZXVlKTsgLy8gVHJpZ2dlciBhZnRlclN0ZXAgY2FsbGJhY2tzXG5cbiAgICAgIGFmdGVyU3RlcENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IHtcbiAgICAgICAgY2FsbGJhY2suY3VycmVudCh3b3JsZCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKHRpbWVTdGVwVmFyaWFibGUpIHtcbiAgICAgIHN0ZXBXb3JsZChjbGFtcGVkRGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb24ndCBzdGVwIHRpbWUgZm9yd2FyZHMgaWYgcGF1c2VkXG4gICAgICAvLyBJbmNyZWFzZSBhY2N1bXVsYXRvclxuICAgICAgc3RlcHBpbmdTdGF0ZS5hY2N1bXVsYXRvciArPSBjbGFtcGVkRGVsdGE7XG5cbiAgICAgIHdoaWxlIChzdGVwcGluZ1N0YXRlLmFjY3VtdWxhdG9yID49IHRpbWVTdGVwKSB7XG4gICAgICAgIC8vIFNldCB1cCBwcmV2aW91cyBzdGF0ZVxuICAgICAgICAvLyBuZWVkZWQgZm9yIGFjY3VyYXRlIGludGVycG9sYXRpb25zIGlmIHRoZSB3b3JsZCBzdGVwcyBtb3JlIHRoYW4gb25jZVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICBzdGVwcGluZ1N0YXRlLnByZXZpb3VzU3RhdGUgPSB7fTtcbiAgICAgICAgICB3b3JsZC5mb3JFYWNoUmlnaWRCb2R5KGJvZHkgPT4ge1xuICAgICAgICAgICAgc3RlcHBpbmdTdGF0ZS5wcmV2aW91c1N0YXRlW2JvZHkuaGFuZGxlXSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb246IGJvZHkudHJhbnNsYXRpb24oKSxcbiAgICAgICAgICAgICAgcm90YXRpb246IGJvZHkucm90YXRpb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ZXBXb3JsZCh0aW1lU3RlcCk7XG4gICAgICAgIHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgLT0gdGltZVN0ZXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJwb2xhdGlvbkFscGhhID0gdGltZVN0ZXBWYXJpYWJsZSB8fCAhaW50ZXJwb2xhdGUgfHwgcGF1c2VkID8gMSA6IHN0ZXBwaW5nU3RhdGUuYWNjdW11bGF0b3IgLyB0aW1lU3RlcDsgLy8gVXBkYXRlIG1lc2hlc1xuXG4gICAgcmlnaWRCb2R5U3RhdGVzLmZvckVhY2goKHN0YXRlLCBoYW5kbGUpID0+IHtcbiAgICAgIGNvbnN0IHJpZ2lkQm9keSA9IHdvcmxkLmdldFJpZ2lkQm9keShoYW5kbGUpO1xuICAgICAgY29uc3QgZXZlbnRzID0gcmlnaWRCb2R5RXZlbnRzLmdldChoYW5kbGUpO1xuXG4gICAgICBpZiAoZXZlbnRzICE9PSBudWxsICYmIGV2ZW50cyAhPT0gdm9pZCAwICYmIGV2ZW50cy5vblNsZWVwIHx8IGV2ZW50cyAhPT0gbnVsbCAmJiBldmVudHMgIT09IHZvaWQgMCAmJiBldmVudHMub25XYWtlKSB7XG4gICAgICAgIGlmIChyaWdpZEJvZHkuaXNTbGVlcGluZygpICYmICFzdGF0ZS5pc1NsZWVwaW5nKSB7XG4gICAgICAgICAgdmFyIF9ldmVudHMkb25TbGVlcDtcblxuICAgICAgICAgIGV2ZW50cyA9PT0gbnVsbCB8fCBldmVudHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZXZlbnRzJG9uU2xlZXAgPSBldmVudHMub25TbGVlcCkgPT09IG51bGwgfHwgX2V2ZW50cyRvblNsZWVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZXZlbnRzJG9uU2xlZXAuY2FsbChldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyaWdpZEJvZHkuaXNTbGVlcGluZygpICYmIHN0YXRlLmlzU2xlZXBpbmcpIHtcbiAgICAgICAgICB2YXIgX2V2ZW50cyRvbldha2U7XG5cbiAgICAgICAgICBldmVudHMgPT09IG51bGwgfHwgZXZlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2V2ZW50cyRvbldha2UgPSBldmVudHMub25XYWtlKSA9PT0gbnVsbCB8fCBfZXZlbnRzJG9uV2FrZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2ZW50cyRvbldha2UuY2FsbChldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNTbGVlcGluZyA9IHJpZ2lkQm9keS5pc1NsZWVwaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmlnaWRCb2R5IHx8IHJpZ2lkQm9keS5pc1NsZWVwaW5nKCkgJiYgIShcImlzSW5zdGFuY2VkTWVzaFwiIGluIHN0YXRlLm9iamVjdCkgfHwgIXN0YXRlLnNldE1hdHJpeCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIE5ldyBzdGF0ZXNcblxuXG4gICAgICBsZXQgdCA9IHJpZ2lkQm9keS50cmFuc2xhdGlvbigpO1xuICAgICAgbGV0IHIgPSByaWdpZEJvZHkucm90YXRpb24oKTtcbiAgICAgIGxldCBwcmV2aW91c1N0YXRlID0gc3RlcHBpbmdTdGF0ZS5wcmV2aW91c1N0YXRlW2hhbmRsZV07XG5cbiAgICAgIGlmIChwcmV2aW91c1N0YXRlKSB7XG4gICAgICAgIC8vIEdldCBwcmV2aW91cyBzaW11bGF0ZWQgd29ybGQgcG9zaXRpb25cbiAgICAgICAgX21hdHJpeDQuY29tcG9zZShwcmV2aW91c1N0YXRlLnBvc2l0aW9uLCByYXBpZXJRdWF0ZXJuaW9uVG9RdWF0ZXJuaW9uKHByZXZpb3VzU3RhdGUucm90YXRpb24pLCBzdGF0ZS5zY2FsZSkucHJlbXVsdGlwbHkoc3RhdGUuaW52ZXJ0ZWRXb3JsZE1hdHJpeCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpOyAvLyBBcHBseSBwcmV2aW91cyB0aWNrIHBvc2l0aW9uXG5cblxuICAgICAgICBpZiAoc3RhdGUubWVzaFR5cGUgPT0gXCJtZXNoXCIpIHtcbiAgICAgICAgICBzdGF0ZS5vYmplY3QucG9zaXRpb24uY29weShfcG9zaXRpb24pO1xuICAgICAgICAgIHN0YXRlLm9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoX3JvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBHZXQgbmV3IHBvc2l0aW9uXG5cblxuICAgICAgX21hdHJpeDQuY29tcG9zZSh0LCByYXBpZXJRdWF0ZXJuaW9uVG9RdWF0ZXJuaW9uKHIpLCBzdGF0ZS5zY2FsZSkucHJlbXVsdGlwbHkoc3RhdGUuaW52ZXJ0ZWRXb3JsZE1hdHJpeCkuZGVjb21wb3NlKF9wb3NpdGlvbiwgX3JvdGF0aW9uLCBfc2NhbGUpO1xuXG4gICAgICBpZiAoc3RhdGUubWVzaFR5cGUgPT0gXCJpbnN0YW5jZWRNZXNoXCIpIHtcbiAgICAgICAgc3RhdGUuc2V0TWF0cml4KF9tYXRyaXg0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEludGVycG9sYXRlIHRvIG5ldyBwb3NpdGlvblxuICAgICAgICBzdGF0ZS5vYmplY3QucG9zaXRpb24ubGVycChfcG9zaXRpb24sIGludGVycG9sYXRpb25BbHBoYSk7XG4gICAgICAgIHN0YXRlLm9iamVjdC5xdWF0ZXJuaW9uLnNsZXJwKF9yb3RhdGlvbiwgaW50ZXJwb2xhdGlvbkFscGhhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBldmVudFF1ZXVlLmRyYWluQ29sbGlzaW9uRXZlbnRzKChoYW5kbGUxLCBoYW5kbGUyLCBzdGFydGVkKSA9PiB7XG4gICAgICBjb25zdCBzb3VyY2UxID0gZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlKGhhbmRsZTEpO1xuICAgICAgY29uc3Qgc291cmNlMiA9IGdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZShoYW5kbGUyKTsgLy8gQ29sbGlzaW9uIEV2ZW50c1xuXG4gICAgICBpZiAoIShzb3VyY2UxICE9PSBudWxsICYmIHNvdXJjZTEgIT09IHZvaWQgMCAmJiBzb3VyY2UxLmNvbGxpZGVyLm9iamVjdCkgfHwgIShzb3VyY2UyICE9PSBudWxsICYmIHNvdXJjZTIgIT09IHZvaWQgMCAmJiBzb3VyY2UyLmNvbGxpZGVyLm9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb2xsaXNpb25QYXlsb2FkMSA9IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlKHNvdXJjZTEsIHNvdXJjZTIpO1xuICAgICAgY29uc3QgY29sbGlzaW9uUGF5bG9hZDIgPSBnZXRDb2xsaXNpb25QYXlsb2FkRnJvbVNvdXJjZShzb3VyY2UyLCBzb3VyY2UxKTtcblxuICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgd29ybGQuY29udGFjdFBhaXIoc291cmNlMS5jb2xsaWRlci5vYmplY3QsIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0LCAobWFuaWZvbGQsIGZsaXBwZWQpID0+IHtcbiAgICAgICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2LCBfc291cmNlMSRyaWdpZEJvZHkkZXYyLCBfc291cmNlMiRyaWdpZEJvZHkkZXYsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjIsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZSwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMiwgX3NvdXJjZTIkY29sbGlkZXIkZXZlLCBfc291cmNlMiRjb2xsaWRlciRldmUyO1xuXG4gICAgICAgICAgLyogUmlnaWRCb2R5IGV2ZW50cyAqL1xuICAgICAgICAgIChfc291cmNlMSRyaWdpZEJvZHkkZXYgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjIgPSBfc291cmNlMSRyaWdpZEJvZHkkZXYub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2Mi5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2ID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXYyID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2Lm9uQ29sbGlzaW9uRW50ZXIpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjIuY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMiksIHt9LCB7XG4gICAgICAgICAgICBtYW5pZm9sZCxcbiAgICAgICAgICAgIGZsaXBwZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgLyogQ29sbGlkZXIgZXZlbnRzICovXG5cbiAgICAgICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTIgPSBfc291cmNlMSRjb2xsaWRlciRldmUub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlMi5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQxKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTIgPSBfc291cmNlMiRjb2xsaWRlciRldmUub25Db2xsaXNpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlMi5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbGxpc2lvblBheWxvYWQyKSwge30sIHtcbiAgICAgICAgICAgIG1hbmlmb2xkLFxuICAgICAgICAgICAgZmxpcHBlZFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MywgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2MywgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NCwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMywgX3NvdXJjZTEkY29sbGlkZXIkZXZlNCwgX3NvdXJjZTIkY29sbGlkZXIkZXZlMywgX3NvdXJjZTIkY29sbGlkZXIkZXZlNDtcblxuICAgICAgICAoX3NvdXJjZTEkcmlnaWRCb2R5JGV2MyA9IHNvdXJjZTEucmlnaWRCb2R5LmV2ZW50cykgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zb3VyY2UxJHJpZ2lkQm9keSRldjQgPSBfc291cmNlMSRyaWdpZEJvZHkkZXYzLm9uQ29sbGlzaW9uRXhpdCkgPT09IG51bGwgfHwgX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkcmlnaWRCb2R5JGV2NC5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjMsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgKF9zb3VyY2UyJHJpZ2lkQm9keSRldjMgPSBzb3VyY2UyLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRyaWdpZEJvZHkkZXY0ID0gX3NvdXJjZTIkcmlnaWRCb2R5JGV2My5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJHJpZ2lkQm9keSRldjQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJHJpZ2lkQm9keSRldjQuY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXYzLCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICAgIChfc291cmNlMSRjb2xsaWRlciRldmUzID0gc291cmNlMS5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRjb2xsaWRlciRldmU0ID0gX3NvdXJjZTEkY29sbGlkZXIkZXZlMy5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQuY2FsbChfc291cmNlMSRjb2xsaWRlciRldmUzLCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRjb2xsaWRlciRldmUzID0gc291cmNlMi5jb2xsaWRlci5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMiRjb2xsaWRlciRldmU0ID0gX3NvdXJjZTIkY29sbGlkZXIkZXZlMy5vbkNvbGxpc2lvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTQuY2FsbChfc291cmNlMiRjb2xsaWRlciRldmUzLCBjb2xsaXNpb25QYXlsb2FkMik7XG4gICAgICB9IC8vIFNlbnNvciBJbnRlcnNlY3Rpb25zXG5cblxuICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKHdvcmxkLmludGVyc2VjdGlvblBhaXIoc291cmNlMS5jb2xsaWRlci5vYmplY3QsIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICAgIHZhciBfc291cmNlMSRyaWdpZEJvZHkkZXY1LCBfc291cmNlMSRyaWdpZEJvZHkkZXY2LCBfc291cmNlMiRyaWdpZEJvZHkkZXY1LCBfc291cmNlMiRyaWdpZEJvZHkkZXY2LCBfc291cmNlMSRjb2xsaWRlciRldmU1LCBfc291cmNlMSRjb2xsaWRlciRldmU2LCBfc291cmNlMiRjb2xsaWRlciRldmU1LCBfc291cmNlMiRjb2xsaWRlciRldmU2O1xuXG4gICAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldjUgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRyaWdpZEJvZHkkZXY2ID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2NS5vbkludGVyc2VjdGlvbkVudGVyKSA9PT0gbnVsbCB8fCBfc291cmNlMSRyaWdpZEJvZHkkZXY2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXY2LmNhbGwoX3NvdXJjZTEkcmlnaWRCb2R5JGV2NSwgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXY1ID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NiA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkcmlnaWRCb2R5JGV2NiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2Ni5jYWxsKF9zb3VyY2UyJHJpZ2lkQm9keSRldjUsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlNSA9IHNvdXJjZTEuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlNiA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTEkY29sbGlkZXIkZXZlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlNi5jYWxsKF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTUsIGNvbGxpc2lvblBheWxvYWQxKTtcbiAgICAgICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlNSA9IHNvdXJjZTIuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlNiA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUub25JbnRlcnNlY3Rpb25FbnRlcikgPT09IG51bGwgfHwgX3NvdXJjZTIkY29sbGlkZXIkZXZlNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlNi5jYWxsKF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTUsIGNvbGxpc2lvblBheWxvYWQyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldjcsIF9zb3VyY2UxJHJpZ2lkQm9keSRldjgsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjcsIF9zb3VyY2UyJHJpZ2lkQm9keSRldjgsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcsIF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTgsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTg7XG5cbiAgICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldjcgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRyaWdpZEJvZHkkZXY4ID0gX3NvdXJjZTEkcmlnaWRCb2R5JGV2Ny5vbkludGVyc2VjdGlvbkV4aXQpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zb3VyY2UxJHJpZ2lkQm9keSRldjguY2FsbChfc291cmNlMSRyaWdpZEJvZHkkZXY3LCBjb2xsaXNpb25QYXlsb2FkMSk7XG4gICAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXY3ID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2OCA9IF9zb3VyY2UyJHJpZ2lkQm9keSRldjcub25JbnRlcnNlY3Rpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRyaWdpZEJvZHkkZXY4LmNhbGwoX3NvdXJjZTIkcmlnaWRCb2R5JGV2NywgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlNyA9IHNvdXJjZTEuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlOCA9IF9zb3VyY2UxJGNvbGxpZGVyJGV2ZTcub25JbnRlcnNlY3Rpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRjb2xsaWRlciRldmU4LmNhbGwoX3NvdXJjZTEkY29sbGlkZXIkZXZlNywgY29sbGlzaW9uUGF5bG9hZDEpO1xuICAgICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlNyA9IHNvdXJjZTIuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlOCA9IF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTcub25JbnRlcnNlY3Rpb25FeGl0KSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMiRjb2xsaWRlciRldmU4LmNhbGwoX3NvdXJjZTIkY29sbGlkZXIkZXZlNywgY29sbGlzaW9uUGF5bG9hZDIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGV2ZW50UXVldWUuZHJhaW5Db250YWN0Rm9yY2VFdmVudHMoZXZlbnQgPT4ge1xuICAgICAgdmFyIF9zb3VyY2UxJHJpZ2lkQm9keSRldjksIF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwLCBfc291cmNlMiRyaWdpZEJvZHkkZXY5LCBfc291cmNlMiRyaWdpZEJvZHkkZXYxMCwgX3NvdXJjZTEkY29sbGlkZXIkZXZlOSwgX3NvdXJjZTEkY29sbGlkZXIkZXZlMTAsIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTksIF9zb3VyY2UyJGNvbGxpZGVyJGV2ZTEwO1xuXG4gICAgICBjb25zdCBzb3VyY2UxID0gZ2V0U291cmNlRnJvbUNvbGxpZGVySGFuZGxlKGV2ZW50LmNvbGxpZGVyMSgpKTtcbiAgICAgIGNvbnN0IHNvdXJjZTIgPSBnZXRTb3VyY2VGcm9tQ29sbGlkZXJIYW5kbGUoZXZlbnQuY29sbGlkZXIyKCkpOyAvLyBDb2xsaXNpb24gRXZlbnRzXG5cbiAgICAgIGlmICghKHNvdXJjZTEgIT09IG51bGwgJiYgc291cmNlMSAhPT0gdm9pZCAwICYmIHNvdXJjZTEuY29sbGlkZXIub2JqZWN0KSB8fCAhKHNvdXJjZTIgIT09IG51bGwgJiYgc291cmNlMiAhPT0gdm9pZCAwICYmIHNvdXJjZTIuY29sbGlkZXIub2JqZWN0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbGxpc2lvblBheWxvYWQxID0gZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2Uoc291cmNlMSwgc291cmNlMik7XG4gICAgICBjb25zdCBjb2xsaXNpb25QYXlsb2FkMiA9IGdldENvbGxpc2lvblBheWxvYWRGcm9tU291cmNlKHNvdXJjZTIsIHNvdXJjZTEpO1xuICAgICAgKF9zb3VyY2UxJHJpZ2lkQm9keSRldjkgPSBzb3VyY2UxLnJpZ2lkQm9keS5ldmVudHMpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc291cmNlMSRyaWdpZEJvZHkkZXYxMCA9IF9zb3VyY2UxJHJpZ2lkQm9keSRldjkub25Db250YWN0Rm9yY2UpID09PSBudWxsIHx8IF9zb3VyY2UxJHJpZ2lkQm9keSRldjEwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc291cmNlMSRyaWdpZEJvZHkkZXYxMC5jYWxsKF9zb3VyY2UxJHJpZ2lkQm9keSRldjksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb2xsaXNpb25QYXlsb2FkMSksIHt9LCB7XG4gICAgICAgIHRvdGFsRm9yY2U6IGV2ZW50LnRvdGFsRm9yY2UoKSxcbiAgICAgICAgdG90YWxGb3JjZU1hZ25pdHVkZTogZXZlbnQudG90YWxGb3JjZU1hZ25pdHVkZSgpLFxuICAgICAgICBtYXhGb3JjZURpcmVjdGlvbjogZXZlbnQubWF4Rm9yY2VEaXJlY3Rpb24oKSxcbiAgICAgICAgbWF4Rm9yY2VNYWduaXR1ZGU6IGV2ZW50Lm1heEZvcmNlTWFnbml0dWRlKClcbiAgICAgIH0pKTtcbiAgICAgIChfc291cmNlMiRyaWdpZEJvZHkkZXY5ID0gc291cmNlMi5yaWdpZEJvZHkuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXY5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkcmlnaWRCb2R5JGV2MTAgPSBfc291cmNlMiRyaWdpZEJvZHkkZXY5Lm9uQ29udGFjdEZvcmNlKSA9PT0gbnVsbCB8fCBfc291cmNlMiRyaWdpZEJvZHkkZXYxMCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkcmlnaWRCb2R5JGV2MTAuY2FsbChfc291cmNlMiRyaWdpZEJvZHkkZXY5LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDIpLCB7fSwge1xuICAgICAgICB0b3RhbEZvcmNlOiBldmVudC50b3RhbEZvcmNlKCksXG4gICAgICAgIHRvdGFsRm9yY2VNYWduaXR1ZGU6IGV2ZW50LnRvdGFsRm9yY2VNYWduaXR1ZGUoKSxcbiAgICAgICAgbWF4Rm9yY2VEaXJlY3Rpb246IGV2ZW50Lm1heEZvcmNlRGlyZWN0aW9uKCksXG4gICAgICAgIG1heEZvcmNlTWFnbml0dWRlOiBldmVudC5tYXhGb3JjZU1hZ25pdHVkZSgpXG4gICAgICB9KSk7XG4gICAgICAoX3NvdXJjZTEkY29sbGlkZXIkZXZlOSA9IHNvdXJjZTEuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmU5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTEkY29sbGlkZXIkZXZlMTAgPSBfc291cmNlMSRjb2xsaWRlciRldmU5Lm9uQ29udGFjdEZvcmNlKSA9PT0gbnVsbCB8fCBfc291cmNlMSRjb2xsaWRlciRldmUxMCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTEkY29sbGlkZXIkZXZlMTAuY2FsbChfc291cmNlMSRjb2xsaWRlciRldmU5LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDEpLCB7fSwge1xuICAgICAgICB0b3RhbEZvcmNlOiBldmVudC50b3RhbEZvcmNlKCksXG4gICAgICAgIHRvdGFsRm9yY2VNYWduaXR1ZGU6IGV2ZW50LnRvdGFsRm9yY2VNYWduaXR1ZGUoKSxcbiAgICAgICAgbWF4Rm9yY2VEaXJlY3Rpb246IGV2ZW50Lm1heEZvcmNlRGlyZWN0aW9uKCksXG4gICAgICAgIG1heEZvcmNlTWFnbml0dWRlOiBldmVudC5tYXhGb3JjZU1hZ25pdHVkZSgpXG4gICAgICB9KSk7XG4gICAgICAoX3NvdXJjZTIkY29sbGlkZXIkZXZlOSA9IHNvdXJjZTIuY29sbGlkZXIuZXZlbnRzKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmU5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3NvdXJjZTIkY29sbGlkZXIkZXZlMTAgPSBfc291cmNlMiRjb2xsaWRlciRldmU5Lm9uQ29udGFjdEZvcmNlKSA9PT0gbnVsbCB8fCBfc291cmNlMiRjb2xsaWRlciRldmUxMCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NvdXJjZTIkY29sbGlkZXIkZXZlMTAuY2FsbChfc291cmNlMiRjb2xsaWRlciRldmU5LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29sbGlzaW9uUGF5bG9hZDIpLCB7fSwge1xuICAgICAgICB0b3RhbEZvcmNlOiBldmVudC50b3RhbEZvcmNlKCksXG4gICAgICAgIHRvdGFsRm9yY2VNYWduaXR1ZGU6IGV2ZW50LnRvdGFsRm9yY2VNYWduaXR1ZGUoKSxcbiAgICAgICAgbWF4Rm9yY2VEaXJlY3Rpb246IGV2ZW50Lm1heEZvcmNlRGlyZWN0aW9uKCksXG4gICAgICAgIG1heEZvcmNlTWFnbml0dWRlOiBldmVudC5tYXhGb3JjZU1hZ25pdHVkZSgpXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgd29ybGQuZm9yRWFjaEFjdGl2ZVJpZ2lkQm9keSgoKSA9PiB7XG4gICAgICBpbnZhbGlkYXRlKCk7XG4gICAgfSk7XG4gIH0sIFtwYXVzZWQsIHRpbWVTdGVwLCBpbnRlcnBvbGF0ZSwgd29ybGRQcm94eV0pO1xuICBjb25zdCBjb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHJhcGllcixcbiAgICB3b3JsZDogd29ybGRQcm94eSxcbiAgICBzZXRXb3JsZDogd29ybGQgPT4ge1xuICAgICAgc2V0V29ybGRQcm94eSh3b3JsZCk7XG4gICAgfSxcbiAgICBwaHlzaWNzT3B0aW9uczoge1xuICAgICAgY29sbGlkZXJzLFxuICAgICAgZ3Jhdml0eVxuICAgIH0sXG4gICAgcmlnaWRCb2R5U3RhdGVzLFxuICAgIGNvbGxpZGVyU3RhdGVzLFxuICAgIHJpZ2lkQm9keUV2ZW50cyxcbiAgICBjb2xsaWRlckV2ZW50cyxcbiAgICBiZWZvcmVTdGVwQ2FsbGJhY2tzLFxuICAgIGFmdGVyU3RlcENhbGxiYWNrcyxcbiAgICBpc1BhdXNlZDogcGF1c2VkLFxuICAgIGlzRGVidWc6IGRlYnVnLFxuICAgIHN0ZXBcbiAgfSksIFtwYXVzZWQsIHN0ZXAsIGRlYnVnLCBjb2xsaWRlcnMsIGdyYXZpdHldKTtcbiAgY29uc3Qgc3RlcENhbGxiYWNrID0gdXNlQ2FsbGJhY2soZGVsdGEgPT4ge1xuICAgIGlmICghcGF1c2VkKSB7XG4gICAgICBzdGVwKGRlbHRhKTtcbiAgICB9XG4gIH0sIFtwYXVzZWQsIHN0ZXBdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHJhcGllckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGcmFtZVN0ZXBwZXIkMSwge1xuICAgIG9uU3RlcDogc3RlcENhbGxiYWNrLFxuICAgIHR5cGU6IHVwZGF0ZUxvb3AsXG4gICAgdXBkYXRlUHJpb3JpdHk6IHVwZGF0ZVByaW9yaXR5XG4gIH0pLCBkZWJ1ZyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWJ1ZywgbnVsbCksIGNoaWxkcmVuKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSBhbiBpbnN0YW5jZSBhbmQgcmV0dXJuIGEgc2FmZSBnZXR0ZXJcbiAqL1xuXG5jb25zdCB1c2VJbXBlcmF0aXZlSW5zdGFuY2UgPSAoY3JlYXRlRm4sIGRlc3Ryb3lGbiwgZGVwZW5kZW5jeUxpc3QpID0+IHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG4gIGNvbnN0IGdldEluc3RhbmNlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gY3JlYXRlRm4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gIH0sIGRlcGVuZGVuY3lMaXN0KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTYXZlIHRoZSBkZXN0cm95IGZ1bmN0aW9uIGFuZCBpbnN0YW5jZVxuICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0SW5zdGFuY2UoKTtcblxuICAgIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiBkZXN0cm95Rm4oaW5zdGFuY2UpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlc3Ryb3koKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gIH0sIFtnZXRJbnN0YW5jZV0pO1xuICByZXR1cm4gZ2V0SW5zdGFuY2U7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCByZXNlbWJsaW5nIGEgVmVjdG9yMyBhbmQgcmV0dXJzIGEgVGhyZWUuVmVjdG9yM1xuICogQGNhdGVnb3J5IE1hdGggaGVscGVyc1xuICovXG5cbmNvbnN0IHZlYzMgPSAoe1xuICB4LFxuICB5LFxuICB6XG59ID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6OiAwXG59KSA9PiB7XG4gIHJldHVybiBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcbn07XG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCByZXNlbWJsaW5nIGEgUXVhdGVybmlvbiBhbmQgcmV0dXJzIGEgVGhyZWUuUXVhdGVybmlvblxuICogQGNhdGVnb3J5IE1hdGggaGVscGVyc1xuICovXG5cbmNvbnN0IHF1YXQgPSAoe1xuICB4LFxuICB5LFxuICB6LFxuICB3XG59ID0ge1xuICB4OiAwLFxuICB5OiAwLFxuICB6OiAwLFxuICB3OiAxXG59KSA9PiB7XG4gIHJldHVybiBuZXcgUXVhdGVybmlvbih4LCB5LCB6LCB3KTtcbn07XG4vKipcbiAqIFRha2VzIGFuIG9iamVjdCByZXNlbWJsaW5nIGFuIEV1bGVyIGFuZCByZXR1cnMgYSBUaHJlZS5FdWxlclxuICogQGNhdGVnb3J5IE1hdGggaGVscGVyc1xuICovXG5cbmNvbnN0IGV1bGVyID0gKHtcbiAgeCxcbiAgeSxcbiAgelxufSA9IHtcbiAgeDogMCxcbiAgeTogMCxcbiAgejogMFxufSkgPT4ge1xuICByZXR1cm4gbmV3IEV1bGVyKHgsIHksIHopO1xufTtcblxuY29uc3QgdXNlRm9yd2FyZGVkUmVmID0gKGZvcndhcmRlZFJlZiwgZGVmYXVsdFZhbHVlID0gbnVsbCkgPT4ge1xuICBjb25zdCBpbm5lclJlZiA9IHVzZVJlZihkZWZhdWx0VmFsdWUpOyAvLyBVcGRhdGUgdGhlIGZvcndhcmRlZCByZWYgd2hlbiB0aGUgaW5uZXIgcmVmIGNoYW5nZXNcblxuICBpZiAoZm9yd2FyZGVkUmVmICYmIHR5cGVvZiBmb3J3YXJkZWRSZWYgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmICghZm9yd2FyZGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gaW5uZXJSZWYuY3VycmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9yd2FyZGVkUmVmO1xuICB9XG5cbiAgcmV0dXJuIGlubmVyUmVmO1xufTtcblxuLyoqXG4gKiBBIGNvbGxpZGVyIGlzIGEgc2hhcGUgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSByaWdpZCBib2R5IHRvIGRlZmluZSBpdHMgcGh5c2ljYWwgcHJvcGVydGllcy5cbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBBbnlDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgcG9zaXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgcXVhdGVybmlvbixcbiAgICBzY2FsZSxcbiAgICBuYW1lXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIHdvcmxkLFxuICAgIGNvbGxpZGVyRXZlbnRzLFxuICAgIGNvbGxpZGVyU3RhdGVzXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgcmlnaWRCb2R5Q29udGV4dCA9IHVzZVJpZ2lkQm9keUNvbnRleHQoKTtcbiAgY29uc3QgY29sbGlkZXJSZWYgPSB1c2VGb3J3YXJkZWRSZWYoZm9yd2FyZGVkUmVmKTtcbiAgY29uc3Qgb2JqZWN0UmVmID0gdXNlUmVmKG51bGwpOyAvLyBXZSBzcHJlYWQgdGhlIHByb3BzIG91dCBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSByZWYgaXMgdXBkYXRlZCB3aGVuIHRoZSBwcm9wcyBjaGFuZ2UuXG5cbiAgY29uc3QgaW1tdXRhYmxlUHJvcEFycmF5ID0gaW1tdXRhYmxlQ29sbGlkZXJPcHRpb25zLmZsYXRNYXAoa2V5ID0+IEFycmF5LmlzQXJyYXkocHJvcHNba2V5XSkgPyBbLi4ucHJvcHNba2V5XV0gOiBwcm9wc1trZXldKTtcbiAgY29uc3QgZ2V0SW5zdGFuY2UgPSB1c2VJbXBlcmF0aXZlSW5zdGFuY2UoKCkgPT4ge1xuICAgIGNvbnN0IHdvcmxkU2NhbGUgPSBvYmplY3RSZWYuY3VycmVudC5nZXRXb3JsZFNjYWxlKHZlYzMoKSk7XG4gICAgY29uc3QgY29sbGlkZXIgPSBjcmVhdGVDb2xsaWRlckZyb21PcHRpb25zKHByb3BzLCB3b3JsZCwgd29ybGRTY2FsZSwgcmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0LmdldFJpZ2lkQm9keSk7XG5cbiAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvcndhcmRlZFJlZihjb2xsaWRlcik7XG4gICAgfVxuXG4gICAgY29sbGlkZXJSZWYuY3VycmVudCA9IGNvbGxpZGVyO1xuICAgIHJldHVybiBjb2xsaWRlcjtcbiAgfSwgY29sbGlkZXIgPT4ge1xuICAgIGlmICh3b3JsZC5nZXRDb2xsaWRlcihjb2xsaWRlci5oYW5kbGUpKSB7XG4gICAgICB3b3JsZC5yZW1vdmVDb2xsaWRlcihjb2xsaWRlciwgdHJ1ZSk7XG4gICAgfVxuICB9LCBbLi4uaW1tdXRhYmxlUHJvcEFycmF5LCByaWdpZEJvZHlDb250ZXh0XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29sbGlkZXIgPSBnZXRJbnN0YW5jZSgpO1xuICAgIGNvbGxpZGVyU3RhdGVzLnNldChjb2xsaWRlci5oYW5kbGUsIGNyZWF0ZUNvbGxpZGVyU3RhdGUoY29sbGlkZXIsIG9iamVjdFJlZi5jdXJyZW50LCByaWdpZEJvZHlDb250ZXh0ID09PSBudWxsIHx8IHJpZ2lkQm9keUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJpZ2lkQm9keUNvbnRleHQucmVmLmN1cnJlbnQpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29sbGlkZXJTdGF0ZXMuZGVsZXRlKGNvbGxpZGVyLmhhbmRsZSk7XG4gICAgfTtcbiAgfSwgW2dldEluc3RhbmNlXSk7XG4gIGNvbnN0IG1lcmdlZFByb3BzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjbGVhblJpZ2lkQm9keVByb3BzRm9yQ29sbGlkZXIocmlnaWRCb2R5Q29udGV4dCA9PT0gbnVsbCB8fCByaWdpZEJvZHlDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByaWdpZEJvZHlDb250ZXh0Lm9wdGlvbnMpKSwgcHJvcHMpO1xuICB9LCBbcHJvcHMsIHJpZ2lkQm9keUNvbnRleHQgPT09IG51bGwgfHwgcmlnaWRCb2R5Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaWRCb2R5Q29udGV4dC5vcHRpb25zXSk7XG4gIHVzZVVwZGF0ZUNvbGxpZGVyT3B0aW9ucyhnZXRJbnN0YW5jZSwgbWVyZ2VkUHJvcHMsIGNvbGxpZGVyU3RhdGVzKTtcbiAgdXNlQ29sbGlkZXJFdmVudHMoZ2V0SW5zdGFuY2UsIG1lcmdlZFByb3BzLCBjb2xsaWRlckV2ZW50cywgZ2V0QWN0aXZlQ29sbGlzaW9uRXZlbnRzRnJvbVByb3BzKHJpZ2lkQm9keUNvbnRleHQgPT09IG51bGwgfHwgcmlnaWRCb2R5Q29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmlnaWRCb2R5Q29udGV4dC5vcHRpb25zKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHJlZjogb2JqZWN0UmVmLFxuICAgIG5hbWU6IG5hbWVcbiAgfSwgY2hpbGRyZW4pO1xufSkpO1xuXG4vKipcbiAqIEEgY3Vib2lkIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IEN1Ym9pZENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBzaGFwZTogXCJjdWJvaWRcIixcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbkN1Ym9pZENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJDdWJvaWRDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgcm91bmQgY3Vib2lkIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IFJvdW5kQ3Vib2lkQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJyb3VuZEN1Ym9pZFwiLFxuICByZWY6IHJlZlxufSkpKTtcblJvdW5kQ3Vib2lkQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlJvdW5kQ3Vib2lkQ29sbGlkZXJcIjtcblxuLyoqXG4gKiBBIGJhbGwgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQmFsbENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiYmFsbFwiLFxuICByZWY6IHJlZlxufSkpKTtcbkJhbGxDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQmFsbENvbGxpZGVyXCI7XG5cbi8qKlxuICogQSBjYXBzdWxlIGNvbGxpZGVyIHNoYXBlXG4gKiBAY2F0ZWdvcnkgQ29sbGlkZXJzXG4gKi9cbmNvbnN0IENhcHN1bGVDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImNhcHN1bGVcIixcbiAgcmVmOiByZWZcbn0pKSk7XG5DYXBzdWxlQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIkNhcHN1bGVDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgaGVpZ2h0ZmllbGQgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgSGVpZ2h0ZmllbGRDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImhlaWdodGZpZWxkXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuSGVpZ2h0ZmllbGRDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiSGVpZ2h0ZmllbGRDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgdHJpbWVzaCBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBUcmltZXNoQ29sbGlkZXIgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICBzaGFwZTogXCJ0cmltZXNoXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuVHJpbWVzaENvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJUcmltZXNoQ29sbGlkZXJcIjtcblxuLyoqXG4gKiBBIGNvbmUgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ29uZUNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY29uZVwiLFxuICByZWY6IHJlZlxufSkpKTtcbkNvbmVDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ29uZUNvbGxpZGVyXCI7XG5cbi8qKlxuICogQSByb3VuZCBjeWxpbmRlciBjb2xsaWRlciBzaGFwZVxuICogQGNhdGVnb3J5IENvbGxpZGVyc1xuICovXG5jb25zdCBSb3VuZENvbmVDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcInJvdW5kQ29uZVwiLFxuICByZWY6IHJlZlxufSkpKTtcblJvdW5kQ29uZUNvbGxpZGVyLmRpc3BsYXlOYW1lID0gXCJSb3VuZENvbmVDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgY3lsaW5kZXIgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ3lsaW5kZXJDb2xsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gIHNoYXBlOiBcImN5bGluZGVyXCIsXG4gIHJlZjogcmVmXG59KSkpO1xuQ3lsaW5kZXJDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ3lsaW5kZXJDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgcm91bmQgY3lsaW5kZXIgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgUm91bmRDeWxpbmRlckNvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwicm91bmRDeWxpbmRlclwiLFxuICByZWY6IHJlZlxufSkpKTtcbkN5bGluZGVyQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIlJvdW5kQ3lsaW5kZXJDb2xsaWRlclwiO1xuXG4vKipcbiAqIEEgY29udmV4IGh1bGwgY29sbGlkZXIgc2hhcGVcbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgQ29udmV4SHVsbENvbGxpZGVyID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFueUNvbGxpZGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgc2hhcGU6IFwiY29udmV4SHVsbFwiLFxuICByZWY6IHJlZlxufSkpKTtcbkNvbnZleEh1bGxDb2xsaWRlci5kaXNwbGF5TmFtZSA9IFwiQ29udmV4SHVsbENvbGxpZGVyXCI7XG5cbmNvbnN0IHJpZ2lkQm9keURlc2NGcm9tT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICB2YXIgX29wdGlvbnMkY2FuU2xlZXA7XG5cbiAgY29uc3QgdHlwZSA9IHJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSkgfHwgXCJkeW5hbWljXCIpO1xuICBjb25zdCBkZXNjID0gbmV3IFJpZ2lkQm9keURlc2ModHlwZSk7IC8vIEFwcGx5IGltbXV0YWJsZSBvcHRpb25zXG5cbiAgZGVzYy5jYW5TbGVlcCA9IChfb3B0aW9ucyRjYW5TbGVlcCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYW5TbGVlcCkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FuU2xlZXAgIT09IHZvaWQgMCA/IF9vcHRpb25zJGNhblNsZWVwIDogdHJ1ZTtcbiAgcmV0dXJuIGRlc2M7XG59O1xuY29uc3QgY3JlYXRlUmlnaWRCb2R5U3RhdGUgPSAoe1xuICByaWdpZEJvZHksXG4gIG9iamVjdCxcbiAgc2V0TWF0cml4LFxuICBnZXRNYXRyaXgsXG4gIHdvcmxkU2NhbGUsXG4gIG1lc2hUeXBlOiBfbWVzaFR5cGUgPSBcIm1lc2hcIlxufSkgPT4ge1xuICBvYmplY3QudXBkYXRlV29ybGRNYXRyaXgodHJ1ZSwgZmFsc2UpO1xuICBjb25zdCBpbnZlcnRlZFdvcmxkTWF0cml4ID0gb2JqZWN0LnBhcmVudC5tYXRyaXhXb3JsZC5jbG9uZSgpLmludmVydCgpO1xuICByZXR1cm4ge1xuICAgIG9iamVjdCxcbiAgICByaWdpZEJvZHksXG4gICAgaW52ZXJ0ZWRXb3JsZE1hdHJpeCxcbiAgICBzZXRNYXRyaXg6IHNldE1hdHJpeCA/IHNldE1hdHJpeCA6IG1hdHJpeCA9PiB7XG4gICAgICBvYmplY3QubWF0cml4LmNvcHkobWF0cml4KTtcbiAgICB9LFxuICAgIGdldE1hdHJpeDogZ2V0TWF0cml4ID8gZ2V0TWF0cml4IDogbWF0cml4ID0+IG1hdHJpeC5jb3B5KG9iamVjdC5tYXRyaXgpLFxuICAgIHNjYWxlOiB3b3JsZFNjYWxlIHx8IG9iamVjdC5nZXRXb3JsZFNjYWxlKF9zY2FsZSkuY2xvbmUoKSxcbiAgICBpc1NsZWVwaW5nOiBmYWxzZSxcbiAgICBtZXNoVHlwZTogX21lc2hUeXBlXG4gIH07XG59O1xuY29uc3QgaW1tdXRhYmxlUmlnaWRCb2R5T3B0aW9ucyA9IFtcImFyZ3NcIiwgXCJjb2xsaWRlcnNcIiwgXCJjYW5TbGVlcFwiXTtcbmNvbnN0IG11dGFibGVSaWdpZEJvZHlPcHRpb25zID0ge1xuICBncmF2aXR5U2NhbGU6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5zZXRHcmF2aXR5U2NhbGUodmFsdWUsIHRydWUpO1xuICB9LFxuXG4gIGFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zKHJiLCB2YWx1ZSkge1xuICAgIHJiLnNldEFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zKHZhbHVlKTtcbiAgfSxcblxuICBsaW5lYXJEYW1waW5nOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0TGluZWFyRGFtcGluZyh2YWx1ZSk7XG4gIH0sXG4gIGFuZ3VsYXJEYW1waW5nOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIuc2V0QW5ndWxhckRhbXBpbmcodmFsdWUpO1xuICB9LFxuICBkb21pbmFuY2VHcm91cDogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLnNldERvbWluYW5jZUdyb3VwKHZhbHVlKTtcbiAgfSxcbiAgZW5hYmxlZFJvdGF0aW9uczogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRFbmFibGVkUm90YXRpb25zKHgsIHksIHosIHRydWUpO1xuICB9LFxuICBlbmFibGVkVHJhbnNsYXRpb25zOiAocmIsIFt4LCB5LCB6XSkgPT4ge1xuICAgIHJiLnNldEVuYWJsZWRUcmFuc2xhdGlvbnMoeCwgeSwgeiwgdHJ1ZSk7XG4gIH0sXG4gIGxvY2tSb3RhdGlvbnM6IChyYiwgdmFsdWUpID0+IHtcbiAgICByYi5sb2NrUm90YXRpb25zKHZhbHVlLCB0cnVlKTtcbiAgfSxcbiAgbG9ja1RyYW5zbGF0aW9uczogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmxvY2tUcmFuc2xhdGlvbnModmFsdWUsIHRydWUpO1xuICB9LFxuICBhbmd1bGFyVmVsb2NpdHk6IChyYiwgW3gsIHksIHpdKSA9PiB7XG4gICAgcmIuc2V0QW5ndmVsKHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgelxuICAgIH0sIHRydWUpO1xuICB9LFxuICBsaW5lYXJWZWxvY2l0eTogKHJiLCBbeCwgeSwgel0pID0+IHtcbiAgICByYi5zZXRMaW52ZWwoe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6XG4gICAgfSwgdHJ1ZSk7XG4gIH0sXG4gIGNjZDogKHJiLCB2YWx1ZSkgPT4ge1xuICAgIHJiLmVuYWJsZUNjZCh2YWx1ZSk7XG4gIH0sXG4gIHVzZXJEYXRhOiAocmIsIHZhbHVlKSA9PiB7XG4gICAgcmIudXNlckRhdGEgPSB2YWx1ZTtcbiAgfSxcblxuICB0eXBlKHJiLCB2YWx1ZSkge1xuICAgIHJiLnNldEJvZHlUeXBlKHJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nKHZhbHVlKSwgdHJ1ZSk7XG4gIH0sXG5cbiAgcG9zaXRpb246ICgpID0+IHt9LFxuICByb3RhdGlvbjogKCkgPT4ge30sXG4gIHF1YXRlcm5pb246ICgpID0+IHt9LFxuICBzY2FsZTogKCkgPT4ge31cbn07XG5jb25zdCBtdXRhYmxlUmlnaWRCb2R5T3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG11dGFibGVSaWdpZEJvZHlPcHRpb25zKTtcbmNvbnN0IHNldFJpZ2lkQm9keU9wdGlvbnMgPSAocmlnaWRCb2R5LCBvcHRpb25zLCBzdGF0ZXMsIHVwZGF0ZVRyYW5zbGF0aW9ucyA9IHRydWUpID0+IHtcbiAgaWYgKCFyaWdpZEJvZHkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHN0YXRlcy5nZXQocmlnaWRCb2R5LmhhbmRsZSk7XG5cbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHVwZGF0ZVRyYW5zbGF0aW9ucykge1xuICAgICAgc3RhdGUub2JqZWN0LnVwZGF0ZVdvcmxkTWF0cml4KHRydWUsIGZhbHNlKTtcblxuICAgICAgX21hdHJpeDQuY29weShzdGF0ZS5vYmplY3QubWF0cml4V29ybGQpLmRlY29tcG9zZShfcG9zaXRpb24sIF9yb3RhdGlvbiwgX3NjYWxlKTtcblxuICAgICAgcmlnaWRCb2R5LnNldFRyYW5zbGF0aW9uKF9wb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgcmlnaWRCb2R5LnNldFJvdGF0aW9uKF9yb3RhdGlvbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIG11dGFibGVSaWdpZEJvZHlPcHRpb25LZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBtdXRhYmxlUmlnaWRCb2R5T3B0aW9uc1trZXldKHJpZ2lkQm9keSwgb3B0aW9uc1trZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmNvbnN0IHVzZVVwZGF0ZVJpZ2lkQm9keU9wdGlvbnMgPSAoZ2V0UmlnaWRCb2R5LCBwcm9wcywgc3RhdGVzLCB1cGRhdGVUcmFuc2xhdGlvbnMgPSB0cnVlKSA9PiB7XG4gIC8vIFRPRE86IEltcHJvdmUgdGhpcywgc3BsaXQgZWFjaCBwcm9wIGludG8gaXRzIG93biBlZmZlY3RcbiAgY29uc3QgbXV0YWJsZVByb3BzQXNGbGF0QXJyYXkgPSB1c2VNZW1vKCgpID0+IG11dGFibGVSaWdpZEJvZHlPcHRpb25LZXlzLmZsYXRNYXAoa2V5ID0+IHtcbiAgICByZXR1cm4gdmVjdG9yVG9UdXBsZShwcm9wc1trZXldKTtcbiAgfSksIFtwcm9wc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHJpZ2lkQm9keSA9IGdldFJpZ2lkQm9keSgpO1xuICAgIHNldFJpZ2lkQm9keU9wdGlvbnMocmlnaWRCb2R5LCBwcm9wcywgc3RhdGVzLCB1cGRhdGVUcmFuc2xhdGlvbnMpO1xuICB9LCBtdXRhYmxlUHJvcHNBc0ZsYXRBcnJheSk7XG59O1xuY29uc3QgdXNlUmlnaWRCb2R5RXZlbnRzID0gKGdldFJpZ2lkQm9keSwgcHJvcHMsIGV2ZW50cykgPT4ge1xuICBjb25zdCB7XG4gICAgb25XYWtlLFxuICAgIG9uU2xlZXAsXG4gICAgb25Db2xsaXNpb25FbnRlcixcbiAgICBvbkNvbGxpc2lvbkV4aXQsXG4gICAgb25JbnRlcnNlY3Rpb25FbnRlcixcbiAgICBvbkludGVyc2VjdGlvbkV4aXQsXG4gICAgb25Db250YWN0Rm9yY2VcbiAgfSA9IHByb3BzO1xuICBjb25zdCBldmVudEhhbmRsZXJzID0ge1xuICAgIG9uV2FrZSxcbiAgICBvblNsZWVwLFxuICAgIG9uQ29sbGlzaW9uRW50ZXIsXG4gICAgb25Db2xsaXNpb25FeGl0LFxuICAgIG9uSW50ZXJzZWN0aW9uRW50ZXIsXG4gICAgb25JbnRlcnNlY3Rpb25FeGl0LFxuICAgIG9uQ29udGFjdEZvcmNlXG4gIH07XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgcmlnaWRCb2R5ID0gZ2V0UmlnaWRCb2R5KCk7XG4gICAgZXZlbnRzLnNldChyaWdpZEJvZHkuaGFuZGxlLCBldmVudEhhbmRsZXJzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLmRlbGV0ZShyaWdpZEJvZHkuaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbb25XYWtlLCBvblNsZWVwLCBvbkNvbGxpc2lvbkVudGVyLCBvbkNvbGxpc2lvbkV4aXQsIG9uSW50ZXJzZWN0aW9uRW50ZXIsIG9uSW50ZXJzZWN0aW9uRXhpdCwgb25Db250YWN0Rm9yY2VdKTtcbn07XG5cbmNvbnN0IF9leGNsdWRlZCQxID0gW1wiY2hpbGRyZW5cIiwgXCJ0eXBlXCIsIFwicG9zaXRpb25cIiwgXCJyb3RhdGlvblwiLCBcInNjYWxlXCIsIFwicXVhdGVybmlvblwiLCBcInRyYW5zZm9ybVN0YXRlXCJdO1xuY29uc3QgUmlnaWRCb2R5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCB1c2VSaWdpZEJvZHlDb250ZXh0ID0gKCkgPT4gdXNlQ29udGV4dChSaWdpZEJvZHlDb250ZXh0KTtcblxuLyoqXG4gKiBBIHJpZ2lkIGJvZHkgaXMgYSBwaHlzaWNhbCBvYmplY3QgdGhhdCBjYW4gYmUgc2ltdWxhdGVkIGJ5IHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAqIEBjYXRlZ29yeSBDb21wb25lbnRzXG4gKi9cbmNvbnN0IFJpZ2lkQm9keSA9IC8qI19fUFVSRV9fKi9tZW1vKCAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigocHJvcHMsIGZvcndhcmRlZFJlZikgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgdHlwZSxcbiAgICBwb3NpdGlvbixcbiAgICByb3RhdGlvbixcbiAgICBzY2FsZSxcbiAgICBxdWF0ZXJuaW9uLFxuICAgIHRyYW5zZm9ybVN0YXRlXG4gIH0gPSBwcm9wcyxcbiAgICAgICAgb2JqZWN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIF9leGNsdWRlZCQxKTtcblxuICBjb25zdCBvYmplY3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJpZ2lkQm9keVJlZiA9IHVzZUZvcndhcmRlZFJlZihmb3J3YXJkZWRSZWYpO1xuICBjb25zdCB7XG4gICAgd29ybGQsXG4gICAgcmlnaWRCb2R5U3RhdGVzLFxuICAgIHBoeXNpY3NPcHRpb25zLFxuICAgIHJpZ2lkQm9keUV2ZW50c1xuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBoeXNpY3NPcHRpb25zKSwgcHJvcHMpLCB7fSwge1xuICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LCBbcGh5c2ljc09wdGlvbnMsIHByb3BzXSk7XG4gIGNvbnN0IGltbXV0YWJsZVByb3BBcnJheSA9IGltbXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMuZmxhdE1hcChrZXkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG1lcmdlZE9wdGlvbnNba2V5XSkgPyBbLi4ubWVyZ2VkT3B0aW9uc1trZXldXSA6IG1lcmdlZE9wdGlvbnNba2V5XTtcbiAgfSk7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyhvYmplY3RSZWYsIG1lcmdlZE9wdGlvbnMpOyAvLyBQcm92aWRlIGEgd2F5IHRvIGVhZ2VybHkgY3JlYXRlIHJpZ2lkYm9keVxuXG4gIGNvbnN0IGdldFJpZ2lkQm9keSA9IHVzZUltcGVyYXRpdmVJbnN0YW5jZSgoKSA9PiB7XG4gICAgY29uc3QgZGVzYyA9IHJpZ2lkQm9keURlc2NGcm9tT3B0aW9ucyhtZXJnZWRPcHRpb25zKTtcbiAgICBjb25zdCByaWdpZEJvZHkgPSB3b3JsZC5jcmVhdGVSaWdpZEJvZHkoZGVzYyk7XG5cbiAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3J3YXJkZWRSZWYocmlnaWRCb2R5KTtcbiAgICB9XG5cbiAgICByaWdpZEJvZHlSZWYuY3VycmVudCA9IHJpZ2lkQm9keTtcbiAgICByZXR1cm4gcmlnaWRCb2R5O1xuICB9LCByaWdpZEJvZHkgPT4ge1xuICAgIGlmICh3b3JsZC5nZXRSaWdpZEJvZHkocmlnaWRCb2R5LmhhbmRsZSkpIHtcbiAgICAgIHdvcmxkLnJlbW92ZVJpZ2lkQm9keShyaWdpZEJvZHkpO1xuICAgIH1cbiAgfSwgaW1tdXRhYmxlUHJvcEFycmF5KTsgLy8gT25seSBwcm92aWRlIGEgb2JqZWN0IHN0YXRlIGFmdGVyIHRoZSByZWYgaGFzIGJlZW4gc2V0XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCByaWdpZEJvZHkgPSBnZXRSaWdpZEJvZHkoKTtcbiAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZVJpZ2lkQm9keVN0YXRlKHtcbiAgICAgIHJpZ2lkQm9keSxcbiAgICAgIG9iamVjdDogb2JqZWN0UmVmLmN1cnJlbnRcbiAgICB9KTtcbiAgICByaWdpZEJvZHlTdGF0ZXMuc2V0KHJpZ2lkQm9keS5oYW5kbGUsIHByb3BzLnRyYW5zZm9ybVN0YXRlID8gcHJvcHMudHJhbnNmb3JtU3RhdGUoc3RhdGUpIDogc3RhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByaWdpZEJvZHlTdGF0ZXMuZGVsZXRlKHJpZ2lkQm9keS5oYW5kbGUpO1xuICAgIH07XG4gIH0sIFtnZXRSaWdpZEJvZHldKTtcbiAgdXNlVXBkYXRlUmlnaWRCb2R5T3B0aW9ucyhnZXRSaWdpZEJvZHksIG1lcmdlZE9wdGlvbnMsIHJpZ2lkQm9keVN0YXRlcyk7XG4gIHVzZVJpZ2lkQm9keUV2ZW50cyhnZXRSaWdpZEJvZHksIG1lcmdlZE9wdGlvbnMsIHJpZ2lkQm9keUV2ZW50cyk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWY6IG9iamVjdFJlZixcbiAgICAgIGdldFJpZ2lkQm9keTogZ2V0UmlnaWRCb2R5LFxuICAgICAgb3B0aW9uczogbWVyZ2VkT3B0aW9uc1xuICAgIH07XG4gIH0sIFtnZXRSaWdpZEJvZHldKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJpZ2lkQm9keUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogb2JqZWN0UmVmXG4gIH0sIG9iamVjdFByb3BzLCB7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICBxdWF0ZXJuaW9uOiBxdWF0ZXJuaW9uLFxuICAgIHNjYWxlOiBzY2FsZVxuICB9KSwgY2hpbGRyZW4sIGNoaWxkQ29sbGlkZXJQcm9wcy5tYXAoKGNvbGxpZGVyUHJvcHMsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe1xuICAgIGtleTogaW5kZXhcbiAgfSwgY29sbGlkZXJQcm9wcykpKSkpO1xufSkpO1xuUmlnaWRCb2R5LmRpc3BsYXlOYW1lID0gXCJSaWdpZEJvZHlcIjtcblxuLyoqXG4gKiBBIG1lc2ggY29sbGlkZXIgaXMgYSBjb2xsaWRlciB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdGhlIGdlb21ldHJ5IG9mIHRoZSBjaGlsZHJlbi5cbiAqIEBjYXRlZ29yeSBDb2xsaWRlcnNcbiAqL1xuY29uc3QgTWVzaENvbGxpZGVyID0gLyojX19QVVJFX18qL21lbW8ocHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgdHlwZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBwaHlzaWNzT3B0aW9uc1xuICB9ID0gdXNlUmFwaWVyKCk7XG4gIGNvbnN0IG9iamVjdCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNcbiAgfSA9IHVzZVJpZ2lkQm9keUNvbnRleHQoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGh5c2ljc09wdGlvbnMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gICAgICBjb2xsaWRlcnM6IHR5cGVcbiAgICB9KTtcbiAgfSwgW3BoeXNpY3NPcHRpb25zLCBvcHRpb25zXSk7XG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyhvYmplY3QsIG1lcmdlZE9wdGlvbnMsIGZhbHNlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib2JqZWN0M0RcIiwge1xuICAgIHJlZjogb2JqZWN0LFxuICAgIHVzZXJEYXRhOiB7XG4gICAgICByM1JhcGllclR5cGU6IFwiTWVzaENvbGxpZGVyXCJcbiAgICB9XG4gIH0sIGNoaWxkcmVuLCBjaGlsZENvbGxpZGVyUHJvcHMubWFwKChjb2xsaWRlclByb3BzLCBpbmRleCkgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQW55Q29sbGlkZXIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGluZGV4XG4gIH0sIGNvbGxpZGVyUHJvcHMpKSkpO1xufSk7XG5NZXNoQ29sbGlkZXIuZGlzcGxheU5hbWUgPSBcIk1lc2hDb2xsaWRlclwiO1xuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiLCBcImluc3RhbmNlc1wiLCBcImNvbGxpZGVyTm9kZXNcIiwgXCJwb3NpdGlvblwiLCBcInJvdGF0aW9uXCIsIFwicXVhdGVybmlvblwiLCBcInNjYWxlXCJdO1xuY29uc3QgSW5zdGFuY2VkUmlnaWRCb2RpZXMgPSAvKiNfX1BVUkVfXyovbWVtbyggLyojX19QVVJFX18qL2ZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgY29uc3QgcmlnaWRCb2RpZXNSZWYgPSB1c2VGb3J3YXJkZWRSZWYoZm9yd2FyZGVkUmVmLCBbXSk7XG4gIGNvbnN0IG9iamVjdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5zdGFuY2VXcmFwcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIGNvbnN0IHtcbiAgICAvLyBpbnN0YW5jZWQgcHJvcHNcbiAgICBjaGlsZHJlbixcbiAgICBpbnN0YW5jZXMsXG4gICAgY29sbGlkZXJOb2RlcyA9IFtdLFxuICAgIC8vIHdyYXBwZXIgb2JqZWN0IHByb3BzXG4gICAgcG9zaXRpb24sXG4gICAgcm90YXRpb24sXG4gICAgcXVhdGVybmlvbixcbiAgICBzY2FsZVxuICB9ID0gcHJvcHMsXG4gICAgICAgIHJpZ2lkQm9keVByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIGNvbnN0IGNoaWxkQ29sbGlkZXJQcm9wcyA9IHVzZUNoaWxkQ29sbGlkZXJQcm9wcyhvYmplY3RSZWYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICB9KSk7XG5cbiAgY29uc3QgZ2V0SW5zdGFuY2VkTWVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gaW5zdGFuY2VXcmFwcGVyUmVmLmN1cnJlbnQuY2hpbGRyZW5bMF07XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBcImlzSW5zdGFuY2VkTWVzaFwiIGluIGZpcnN0Q2hpbGQpIHtcbiAgICAgIHJldHVybiBmaXJzdENoaWxkO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gZ2V0SW5zdGFuY2VkTWVzaCgpO1xuXG4gICAgaWYgKGluc3RhbmNlZE1lc2gpIHtcbiAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VNYXRyaXguc2V0VXNhZ2UoRHluYW1pY0RyYXdVc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkluc3RhbmNlZFJpZ2lkQm9kaWVzIGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQsIHdoaWNoIG11c3QgYmUgYW4gSW5zdGFuY2VkTWVzaFwiKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gVXBkYXRlIHRoZSBSaWdpZEJvZHlTdGF0ZXMgd2hlbmV2ZXIgdGhlIGluc3RhbmNlcyBjaGFuZ2VcblxuICBjb25zdCBhcHBseUluc3RhbmNlZFN0YXRlID0gKHN0YXRlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlZE1lc2ggPSBnZXRJbnN0YW5jZWRNZXNoKCk7XG5cbiAgICBpZiAoaW5zdGFuY2VkTWVzaCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzdGF0ZSksIHt9LCB7XG4gICAgICAgIGdldE1hdHJpeDogbWF0cml4ID0+IHtcbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLmdldE1hdHJpeEF0KGluZGV4LCBtYXRyaXgpO1xuICAgICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldE1hdHJpeDogbWF0cml4ID0+IHtcbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGluZGV4LCBtYXRyaXgpO1xuICAgICAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBtZXNoVHlwZTogXCJpbnN0YW5jZWRNZXNoXCJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3QzRFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBvYmplY3RSZWZcbiAgfSwgcmlnaWRCb2R5UHJvcHMsIHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sXG4gICAgc2NhbGU6IHNjYWxlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm9iamVjdDNEXCIsIHtcbiAgICByZWY6IGluc3RhbmNlV3JhcHBlclJlZlxuICB9LCBjaGlsZHJlbiksIGluc3RhbmNlcyA9PT0gbnVsbCB8fCBpbnN0YW5jZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlcy5tYXAoKGluc3RhbmNlLCBpbmRleCkgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmlnaWRCb2R5LCBfZXh0ZW5kcyh7fSwgcmlnaWRCb2R5UHJvcHMsIGluc3RhbmNlLCB7XG4gICAgcmVmOiBib2R5ID0+IHJpZ2lkQm9kaWVzUmVmLmN1cnJlbnRbaW5kZXhdID0gYm9keSxcbiAgICB0cmFuc2Zvcm1TdGF0ZTogc3RhdGUgPT4gYXBwbHlJbnN0YW5jZWRTdGF0ZShzdGF0ZSwgaW5kZXgpXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29sbGlkZXJOb2Rlcy5tYXAoKG5vZGUsIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGcmFnbWVudCwge1xuICAgIGtleTogaW5kZXhcbiAgfSwgbm9kZSkpLCBjaGlsZENvbGxpZGVyUHJvcHMubWFwKChjb2xsaWRlclByb3BzLCBjb2xsaWRlckluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBbnlDb2xsaWRlciwgX2V4dGVuZHMoe1xuICAgIGtleTogY29sbGlkZXJJbmRleFxuICB9LCBjb2xsaWRlclByb3BzKSkpKSkpKTtcbn0pKTtcbkluc3RhbmNlZFJpZ2lkQm9kaWVzLmRpc3BsYXlOYW1lID0gXCJJbnN0YW5jZWRSaWdpZEJvZGllc1wiO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbmNvbnN0IHVzZUltcHVsc2VKb2ludCA9IChib2R5MSwgYm9keTIsIHBhcmFtcykgPT4ge1xuICBjb25zdCB7XG4gICAgd29ybGRcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCBqb2ludFJlZiA9IHVzZVJlZigpO1xuICB1c2VJbXBlcmF0aXZlSW5zdGFuY2UoKCkgPT4ge1xuICAgIGlmIChib2R5MS5jdXJyZW50ICYmIGJvZHkyLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IG5ld0pvaW50ID0gd29ybGQuY3JlYXRlSW1wdWxzZUpvaW50KHBhcmFtcywgYm9keTEuY3VycmVudCwgYm9keTIuY3VycmVudCwgdHJ1ZSk7XG4gICAgICBqb2ludFJlZi5jdXJyZW50ID0gbmV3Sm9pbnQ7XG4gICAgICByZXR1cm4gbmV3Sm9pbnQ7XG4gICAgfVxuICB9LCBqb2ludCA9PiB7XG4gICAgaWYgKGpvaW50KSB7XG4gICAgICBqb2ludFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAod29ybGQuZ2V0SW1wdWxzZUpvaW50KGpvaW50LmhhbmRsZSkpIHtcbiAgICAgICAgd29ybGQucmVtb3ZlSW1wdWxzZUpvaW50KGpvaW50LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGpvaW50UmVmO1xufTtcbi8qKlxuICogQSBmaXhlZCBqb2ludCBlbnN1cmVzIHRoYXQgdHdvIHJpZ2lkLWJvZGllcyBkb24ndCBtb3ZlIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuXG4gKiBGaXhlZCBqb2ludHMgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGZyYW1lIChyZXByZXNlbnRlZCBieSBhbiBpc29tZXRyeSkgb24gZWFjaCByaWdpZC1ib2R5LlxuICogVGhlIGZpeGVkLWpvaW50IG1ha2VzIHRoZXNlIGZyYW1lcyBjb2luY2lkZSBpbiB3b3JsZC1zcGFjZS5cbiAqXG4gKiBAY2F0ZWdvcnkgSG9va3MgLSBKb2ludHNcbiAqL1xuXG5jb25zdCB1c2VGaXhlZEpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MUxvY2FsRnJhbWUsIGJvZHkyQW5jaG9yLCBib2R5MkxvY2FsRnJhbWVdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICByZXR1cm4gdXNlSW1wdWxzZUpvaW50KGJvZHkxLCBib2R5MiwgcmFwaWVyLkpvaW50RGF0YS5maXhlZCh2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpLCBxdWF0ZXJuaW9uVG9SYXBpZXJRdWF0ZXJuaW9uKGJvZHkxTG9jYWxGcmFtZSksIHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MkFuY2hvciksIHF1YXRlcm5pb25Ub1JhcGllclF1YXRlcm5pb24oYm9keTJMb2NhbEZyYW1lKSkpO1xufTtcbi8qKlxuICogVGhlIHNwaGVyaWNhbCBqb2ludCBlbnN1cmVzIHRoYXQgdHdvIHBvaW50cyBvbiB0aGUgbG9jYWwtc3BhY2VzIG9mIHR3byByaWdpZC1ib2RpZXMgYWx3YXlzIGNvaW5jaWRlIChpdCBwcmV2ZW50cyBhbnkgcmVsYXRpdmVcbiAqIHRyYW5zbGF0aW9uYWwgbW90aW9uIGF0IHRoaXMgcG9pbnRzKS4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBzaW11bGF0ZSByYWdkb2xscyBhcm1zLCBwZW5kdWx1bXMsIGV0Yy5cbiAqIFRoZXkgYXJlIGNoYXJhY3Rlcml6ZWQgYnkgb25lIGxvY2FsIGFuY2hvciBvbiBlYWNoIHJpZ2lkLWJvZHkuIEVhY2ggYW5jaG9yIHJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIHRoZVxuICogcG9pbnRzIHRoYXQgbmVlZCB0byBjb2luY2lkZSBvbiB0aGUgbG9jYWwtc3BhY2Ugb2YgZWFjaCByaWdpZC1ib2R5LlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZVNwaGVyaWNhbEpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvcl0pID0+IHtcbiAgY29uc3Qge1xuICAgIHJhcGllclxuICB9ID0gdXNlUmFwaWVyKCk7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCByYXBpZXIuSm9pbnREYXRhLnNwaGVyaWNhbCh2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpKSk7XG59O1xuLyoqXG4gKiBUaGUgcmV2b2x1dGUgam9pbnQgcHJldmVudHMgYW55IHJlbGF0aXZlIG1vdmVtZW50IGJldHdlZW4gdHdvIHJpZ2lkLWJvZGllcywgZXhjZXB0IGZvciByZWxhdGl2ZVxuICogcm90YXRpb25zIGFsb25nIG9uZSBheGlzLiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIHNpbXVsYXRlIHdoZWVscywgZmFucywgZXRjLlxuICogVGhleSBhcmUgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgYW5jaG9yIGFzIHdlbGwgYXMgb25lIGxvY2FsIGF4aXMgb24gZWFjaCByaWdpZC1ib2R5LlxuICpcbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZVJldm9sdXRlSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCBheGlzLCBsaW1pdHNdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnJldm9sdXRlKHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MUFuY2hvciksIHZlY3RvcjNUb1JhcGllclZlY3Rvcihib2R5MkFuY2hvciksIHZlY3RvcjNUb1JhcGllclZlY3RvcihheGlzKSk7XG5cbiAgaWYgKGxpbWl0cykge1xuICAgIHBhcmFtcy5saW1pdHNFbmFibGVkID0gdHJ1ZTtcbiAgICBwYXJhbXMubGltaXRzID0gbGltaXRzO1xuICB9XG5cbiAgcmV0dXJuIHVzZUltcHVsc2VKb2ludChib2R5MSwgYm9keTIsIHBhcmFtcyk7XG59O1xuLyoqXG4gKiBUaGUgcHJpc21hdGljIGpvaW50IHByZXZlbnRzIGFueSByZWxhdGl2ZSBtb3ZlbWVudCBiZXR3ZWVuIHR3byByaWdpZC1ib2RpZXMsIGV4Y2VwdCBmb3IgcmVsYXRpdmUgdHJhbnNsYXRpb25zIGFsb25nIG9uZSBheGlzLlxuICogSXQgaXMgY2hhcmFjdGVyaXplZCBieSBvbmUgbG9jYWwgYW5jaG9yIGFzIHdlbGwgYXMgb25lIGxvY2FsIGF4aXMgb24gZWFjaCByaWdpZC1ib2R5LiBJbiAzRCwgYW4gb3B0aW9uYWxcbiAqIGxvY2FsIHRhbmdlbnQgYXhpcyBjYW4gYmUgc3BlY2lmaWVkIGZvciBlYWNoIHJpZ2lkLWJvZHkuXG4gKlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cblxuY29uc3QgdXNlUHJpc21hdGljSm9pbnQgPSAoYm9keTEsIGJvZHkyLCBbYm9keTFBbmNob3IsIGJvZHkyQW5jaG9yLCBheGlzLCBsaW1pdHNdKSA9PiB7XG4gIGNvbnN0IHtcbiAgICByYXBpZXJcbiAgfSA9IHVzZVJhcGllcigpO1xuICBjb25zdCBwYXJhbXMgPSByYXBpZXIuSm9pbnREYXRhLnByaXNtYXRpYyh2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTFBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYm9keTJBbmNob3IpLCB2ZWN0b3IzVG9SYXBpZXJWZWN0b3IoYXhpcykpO1xuXG4gIGlmIChsaW1pdHMpIHtcbiAgICBwYXJhbXMubGltaXRzRW5hYmxlZCA9IHRydWU7XG4gICAgcGFyYW1zLmxpbWl0cyA9IGxpbWl0cztcbiAgfVxuXG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcbi8qKlxuICogVGhlIHJvcGUgam9pbnQgbGltaXRzIHRoZSBtYXggZGlzdGFuY2UgYmV0d2VlbiB0d28gYm9kaWVzLlxuICogQGNhdGVnb3J5IEhvb2tzIC0gSm9pbnRzXG4gKi9cblxuY29uc3QgdXNlUm9wZUpvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgbGVuZ3RoXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgdkJvZHkxQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKTtcbiAgY29uc3QgdkJvZHkyQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5yb3BlKGxlbmd0aCwgdkJvZHkxQW5jaG9yLCB2Qm9keTJBbmNob3IpO1xuICByZXR1cm4gdXNlSW1wdWxzZUpvaW50KGJvZHkxLCBib2R5MiwgcGFyYW1zKTtcbn07XG4vKipcbiAqIFRoZSBzcHJpbmcgam9pbnQgYXBwbGllcyBhIGZvcmNlIHByb3BvcnRpb25hbCB0byB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gb2JqZWN0cy5cbiAqIEBjYXRlZ29yeSBIb29rcyAtIEpvaW50c1xuICovXG5cbmNvbnN0IHVzZVNwcmluZ0pvaW50ID0gKGJvZHkxLCBib2R5MiwgW2JvZHkxQW5jaG9yLCBib2R5MkFuY2hvciwgcmVzdExlbmd0aCwgc3RpZmZuZXNzLCBkYW1waW5nXSkgPT4ge1xuICBjb25zdCB7XG4gICAgcmFwaWVyXG4gIH0gPSB1c2VSYXBpZXIoKTtcbiAgY29uc3QgdkJvZHkxQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkxQW5jaG9yKTtcbiAgY29uc3QgdkJvZHkyQW5jaG9yID0gdmVjdG9yM1RvUmFwaWVyVmVjdG9yKGJvZHkyQW5jaG9yKTtcbiAgY29uc3QgcGFyYW1zID0gcmFwaWVyLkpvaW50RGF0YS5zcHJpbmcocmVzdExlbmd0aCwgc3RpZmZuZXNzLCBkYW1waW5nLCB2Qm9keTFBbmNob3IsIHZCb2R5MkFuY2hvcik7XG4gIHJldHVybiB1c2VJbXB1bHNlSm9pbnQoYm9keTEsIGJvZHkyLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGFuIEludGVyYWN0aW9uR3JvdXAgYml0bWFzayBmb3IgdXNlIGluIHRoZSBgY29sbGlzaW9uR3JvdXBzYCBvciBgc29sdmVyR3JvdXBzYFxuICogcHJvcGVydGllcyBvZiBSaWdpZEJvZHkgb3IgQ29sbGlkZXIgY29tcG9uZW50cy4gVGhlIGZpcnN0IGFyZ3VtZW50IHJlcHJlc2VudHMgYSBsaXN0IG9mXG4gKiBncm91cHMgdGhlIGVudGl0eSBpcyBpbiAoZXhwcmVzc2VkIGFzIG51bWJlcnMgZnJvbSAwIHRvIDE1KS4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGxpc3RcbiAqIG9mIGdyb3VwcyB0aGF0IHdpbGwgYmUgZmlsdGVyZWQgYWdhaW5zdC4gV2hlbiBpdCBpcyBvbWl0dGVkLCBhbGwgZ3JvdXBzIGFyZSBmaWx0ZXJlZCBhZ2FpbnN0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBBIFJpZ2lkQm9keSB0aGF0IGlzIG1lbWJlciBvZiBncm91cCAwIGFuZCB3aWxsIGNvbGxpZGUgd2l0aCBldmVyeXRoaW5nIGZyb20gZ3JvdXBzIDAgYW5kIDE6XG4gKlxuICogYGBgdHN4XG4gKiA8UmlnaWRCb2R5IGNvbGxpc2lvbkdyb3Vwcz17aW50ZXJhY3Rpb25Hcm91cHMoWzBdLCBbMCwgMV0pfSAvPlxuICogYGBgXG4gKlxuICogQSBSaWdpZEJvZHkgdGhhdCBpcyBtZW1iZXIgb2YgZ3JvdXBzIDAgYW5kIDEgYW5kIHdpbGwgY29sbGlkZSB3aXRoIGV2ZXJ5dGhpbmcgZWxzZTpcbiAqXG4gKiBgYGB0c3hcbiAqIDxSaWdpZEJvZHkgY29sbGlzaW9uR3JvdXBzPXtpbnRlcmFjdGlvbkdyb3VwcyhbMCwgMV0pfSAvPlxuICogYGBgXG4gKlxuICogQSBSaWdpZEJvZHkgdGhhdCBpcyBtZW1iZXIgb2YgZ3JvdXBzIDAgYW5kIDEgYW5kIHdpbGwgbm90IGNvbGxpZGUgd2l0aCBhbnl0aGluZzpcbiAqXG4gKiBgYGB0c3hcbiAqIDxSaWdpZEJvZHkgY29sbGlzaW9uR3JvdXBzPXtpbnRlcmFjdGlvbkdyb3VwcyhbMCwgMV0sIFtdKX0gLz5cbiAqIGBgYFxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgUmFwaWVyIG5lZWRzIGludGVyYWN0aW9uIGZpbHRlcnMgdG8gZXZhbHVhdGUgdG8gdHJ1ZSBiZXR3ZWVuIF9ib3RoXyBjb2xsaWRpbmdcbiAqIGVudGl0aWVzIGZvciBjb2xsaXNpb24gZXZlbnRzIHRvIHRyaWdnZXIuXG4gKlxuICogQHBhcmFtIG1lbWJlcnNoaXBzIEdyb3VwcyB0aGUgY29sbGlkZXIgaXMgYSBtZW1iZXIgb2YuIChWYWx1ZXMgY2FuIHJhbmdlIGZyb20gMCB0byAxNS4pXG4gKiBAcGFyYW0gZmlsdGVycyBHcm91cHMgdGhlIGludGVyYWN0aW9uIGdyb3VwIHNob3VsZCBmaWx0ZXIgYWdhaW5zdC4gKFZhbHVlcyBjYW4gcmFuZ2UgZnJvbSAwIHRvIDE1LilcbiAqIEByZXR1cm5zIEFuIEludGVyYWN0aW9uR3JvdXAgYml0bWFzay5cbiAqL1xuY29uc3QgaW50ZXJhY3Rpb25Hcm91cHMgPSAobWVtYmVyc2hpcHMsIGZpbHRlcnMpID0+IChiaXRtYXNrKG1lbWJlcnNoaXBzKSA8PCAxNikgKyAoZmlsdGVycyAhPT0gdW5kZWZpbmVkID8gYml0bWFzayhmaWx0ZXJzKSA6IDBiMTExMTExMTExMTExMTExMSk7XG5cbmNvbnN0IGJpdG1hc2sgPSBncm91cHMgPT4gW2dyb3Vwc10uZmxhdCgpLnJlZHVjZSgoYWNjLCBsYXllcikgPT4gYWNjIHwgMSA8PCBsYXllciwgMCk7XG5cbmV4cG9ydCB7IEFueUNvbGxpZGVyLCBCYWxsQ29sbGlkZXIsIENhcHN1bGVDb2xsaWRlciwgQ29uZUNvbGxpZGVyLCBDb252ZXhIdWxsQ29sbGlkZXIsIEN1Ym9pZENvbGxpZGVyLCBDeWxpbmRlckNvbGxpZGVyLCBIZWlnaHRmaWVsZENvbGxpZGVyLCBJbnN0YW5jZWRSaWdpZEJvZGllcywgTWVzaENvbGxpZGVyLCBQaHlzaWNzLCBSaWdpZEJvZHksIFJvdW5kQ29uZUNvbGxpZGVyLCBSb3VuZEN1Ym9pZENvbGxpZGVyLCBSb3VuZEN5bGluZGVyQ29sbGlkZXIsIFRyaW1lc2hDb2xsaWRlciwgZXVsZXIsIGludGVyYWN0aW9uR3JvdXBzLCBxdWF0LCB1c2VBZnRlclBoeXNpY3NTdGVwLCB1c2VCZWZvcmVQaHlzaWNzU3RlcCwgdXNlRml4ZWRKb2ludCwgdXNlSW1wdWxzZUpvaW50LCB1c2VQcmlzbWF0aWNKb2ludCwgdXNlUmFwaWVyLCB1c2VSZXZvbHV0ZUpvaW50LCB1c2VSb3BlSm9pbnQsIHVzZVNwaGVyaWNhbEpvaW50LCB1c2VTcHJpbmdKb2ludCwgdmVjMyB9O1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJWZWN0b3IzJDEiLCJRdWF0ZXJuaW9uIiwiUXVhdGVybmlvbiQxIiwiQWN0aXZlRXZlbnRzIiwiQ29sbGlkZXJEZXNjIiwiRXZlbnRRdWV1ZSIsIlJpZ2lkQm9keURlc2MiLCJDb2VmZmljaWVudENvbWJpbmVSdWxlIiwiQ29sbGlkZXIiLCJSYXBpZXJDb2xsaWRlciIsIlJpZ2lkQm9keSIsIlJhcGllclJpZ2lkQm9keSIsInVzZUZyYW1lIiwidXNlVGhyZWUiLCJSZWFjdCIsInVzZVJlZiIsInVzZUVmZmVjdCIsIm1lbW8iLCJ1c2VNZW1vIiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwiY3JlYXRlQ29udGV4dCIsInVzZUNhbGxiYWNrIiwiZm9yd2FyZFJlZiIsIkZyYWdtZW50IiwiRXVsZXIiLCJPYmplY3QzRCIsIk1hdHJpeDQiLCJCdWZmZXJBdHRyaWJ1dGUiLCJNYXRoVXRpbHMiLCJEeW5hbWljRHJhd1VzYWdlIiwic3VzcGVuZCIsIm1lcmdlVmVydGljZXMiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwib3duS2V5cyIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJmaWx0ZXIiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkMiIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfcXVhdGVybmlvbiIsIl92ZWN0b3IzIiwiX21hdHJpeDQiLCJfcG9zaXRpb24iLCJfcm90YXRpb24iLCJfc2NhbGUiLCJ2ZWN0b3JBcnJheVRvVmVjdG9yMyIsImFyciIsIngiLCJ5IiwieiIsInJhcGllclF1YXRlcm5pb25Ub1F1YXRlcm5pb24iLCJ3Iiwic2V0IiwidmVjdG9yM1RvUmFwaWVyVmVjdG9yIiwidiIsIkFycmF5IiwiaXNBcnJheSIsInRocmVlVmVjdG9yMyIsInF1YXRlcm5pb25Ub1JhcGllclF1YXRlcm5pb24iLCJyaWdpZEJvZHlUeXBlTWFwIiwiZml4ZWQiLCJkeW5hbWljIiwia2luZW1hdGljUG9zaXRpb24iLCJraW5lbWF0aWNWZWxvY2l0eSIsInJpZ2lkQm9keVR5cGVGcm9tU3RyaW5nIiwidHlwZSIsInNjYWxlVmVydGljZXMiLCJ2ZXJ0aWNlcyIsInNjYWxlIiwic2NhbGVkVmVydHMiLCJmcm9tIiwidmVjdG9yVG9UdXBsZSIsInVzZUNvbnN0IiwiaW5pdGlhbFZhbHVlIiwicmVmIiwiY3VycmVudCIsInVuZGVmaW5lZCIsInVzZVJhZiIsImNhbGxiYWNrIiwiY2IiLCJyYWYiLCJsYXN0RnJhbWUiLCJsb29wIiwibm93IiwicGVyZm9ybWFuY2UiLCJkZWx0YSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiVXNlRnJhbWVTdGVwcGVyIiwib25TdGVwIiwidXBkYXRlUHJpb3JpdHkiLCJfIiwiZHQiLCJSYWZTdGVwcGVyIiwiRnJhbWVTdGVwcGVyIiwiY3JlYXRlRWxlbWVudCIsIkZyYW1lU3RlcHBlciQxIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJleGNsdWRlZCIsInNvdXJjZUtleXMiLCJpbmRleE9mIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwic291cmNlU3ltYm9sS2V5cyIsInByb3RvdHlwZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiY2FsbCIsIl9leGNsdWRlZCQyIiwic2NhbGVDb2xsaWRlckFyZ3MiLCJzaGFwZSIsImFyZ3MiLCJuZXdBcmdzIiwic2xpY2UiLCJzIiwic2NhbGVBcnJheSIsIm1hcCIsImFyZyIsImluZGV4IiwiY3JlYXRlQ29sbGlkZXJGcm9tT3B0aW9ucyIsIm9wdGlvbnMiLCJ3b3JsZCIsImdldFJpZ2lkQm9keSIsInNjYWxlZEFyZ3MiLCJkZXNjIiwiY3JlYXRlQ29sbGlkZXIiLCJpbW11dGFibGVDb2xsaWRlck9wdGlvbnMiLCJtYXNzUHJvcGVydGllc0NvbmZsaWN0RXJyb3IiLCJzZXRDb2xsaWRlck1hc3NPcHRpb25zIiwiY29sbGlkZXIiLCJkZW5zaXR5IiwibWFzcyIsIm1hc3NQcm9wZXJ0aWVzIiwiRXJyb3IiLCJzZXREZW5zaXR5Iiwic2V0TWFzcyIsInNldE1hc3NQcm9wZXJ0aWVzIiwiY2VudGVyT2ZNYXNzIiwicHJpbmNpcGFsQW5ndWxhckluZXJ0aWEiLCJhbmd1bGFySW5lcnRpYUxvY2FsRnJhbWUiLCJtdXRhYmxlQ29sbGlkZXJPcHRpb25zIiwic2Vuc29yIiwic2V0U2Vuc29yIiwiY29sbGlzaW9uR3JvdXBzIiwic2V0Q29sbGlzaW9uR3JvdXBzIiwic29sdmVyR3JvdXBzIiwic2V0U29sdmVyR3JvdXBzIiwiZnJpY3Rpb24iLCJzZXRGcmljdGlvbiIsImZyaWN0aW9uQ29tYmluZVJ1bGUiLCJzZXRGcmljdGlvbkNvbWJpbmVSdWxlIiwicmVzdGl0dXRpb24iLCJzZXRSZXN0aXR1dGlvbiIsInJlc3RpdHV0aW9uQ29tYmluZVJ1bGUiLCJzZXRSZXN0aXR1dGlvbkNvbWJpbmVSdWxlIiwicXVhdGVybmlvbiIsInBvc2l0aW9uIiwicm90YXRpb24iLCJtdXRhYmxlQ29sbGlkZXJPcHRpb25LZXlzIiwic2V0Q29sbGlkZXJPcHRpb25zIiwic3RhdGVzIiwic3RhdGUiLCJnZXQiLCJoYW5kbGUiLCJfc3RhdGUkd29ybGRQYXJlbnQiLCJwYXJlbnRXb3JsZFNjYWxlIiwicGFyZW50IiwiZ2V0V29ybGRTY2FsZSIsInBhcmVudEludmVydGVkV29ybGRNYXRyaXgiLCJ3b3JsZFBhcmVudCIsIm1hdHJpeFdvcmxkIiwiY2xvbmUiLCJpbnZlcnQiLCJ1cGRhdGVXb3JsZE1hdHJpeCIsImNvcHkiLCJwcmVtdWx0aXBseSIsImRlY29tcG9zZSIsInNldFRyYW5zbGF0aW9uV3J0UGFyZW50Iiwic2V0Um90YXRpb25XcnRQYXJlbnQiLCJzZXRUcmFuc2xhdGlvbiIsInNldFJvdGF0aW9uIiwib3B0aW9uIiwidXNlVXBkYXRlQ29sbGlkZXJPcHRpb25zIiwiZ2V0Q29sbGlkZXIiLCJwcm9wcyIsIm11dGFibGVQcm9wc0FzRmxhdEFycmF5IiwiZmxhdE1hcCIsImlzQ2hpbGRPZk1lc2hDb2xsaWRlciIsImNoaWxkIiwiZmxhZyIsInRyYXZlcnNlQW5jZXN0b3JzIiwiYSIsInVzZXJEYXRhIiwicjNSYXBpZXJUeXBlIiwiY3JlYXRlQ29sbGlkZXJTdGF0ZSIsInJpZ2lkQm9keU9iamVjdCIsImF1dG9Db2xsaWRlck1hcCIsImN1Ym9pZCIsImJhbGwiLCJodWxsIiwidHJpbWVzaCIsImNyZWF0ZUNvbGxpZGVyUHJvcHNGcm9tQ2hpbGRyZW4iLCJpZ25vcmVNZXNoQ29sbGlkZXJzIiwiX2lnbm9yZU1lc2hDb2xsaWRlcnMiLCJjaGlsZENvbGxpZGVyUHJvcHMiLCJpbnZlcnRlZFBhcmVudE1hdHJpeFdvcmxkIiwiY29sbGlkZXJGcm9tQ2hpbGQiLCJ3b3JsZFNjYWxlIiwiY29sbGlkZXJzIiwicm90YXRpb25FdWxlciIsInNldEZyb21RdWF0ZXJuaW9uIiwiZ2VvbWV0cnkiLCJvZmZzZXQiLCJnZXRDb2xsaWRlckFyZ3NGcm9tR2VvbWV0cnkiLCJjb2xsaWRlclByb3BzIiwiY2xlYW5SaWdpZEJvZHlQcm9wc0ZvckNvbGxpZGVyIiwiaW5jbHVkZUludmlzaWJsZSIsInRyYXZlcnNlIiwidHJhdmVyc2VWaXNpYmxlIiwiY29tcHV0ZUJvdW5kaW5nQm94IiwiYm91bmRpbmdCb3giLCJzaXplIiwiZ2V0U2l6ZSIsImdldENlbnRlciIsImNvbXB1dGVCb3VuZGluZ1NwaGVyZSIsImJvdW5kaW5nU3BoZXJlIiwicmFkaXVzIiwiY2VudGVyIiwiX2Nsb25lZEdlb21ldHJ5JGluZGV4IiwiY2xvbmVkR2VvbWV0cnkiLCJhdHRyaWJ1dGVzIiwiYXJyYXkiLCJnIiwiZ2V0QWN0aXZlQ29sbGlzaW9uRXZlbnRzRnJvbVByb3BzIiwiY29sbGlzaW9uIiwib25Db2xsaXNpb25FbnRlciIsIm9uQ29sbGlzaW9uRXhpdCIsIm9uSW50ZXJzZWN0aW9uRW50ZXIiLCJvbkludGVyc2VjdGlvbkV4aXQiLCJjb250YWN0Rm9yY2UiLCJvbkNvbnRhY3RGb3JjZSIsInVzZUNvbGxpZGVyRXZlbnRzIiwiZXZlbnRzIiwiYWN0aXZlRXZlbnRzIiwiY29sbGlzaW9uRXZlbnRzQWN0aXZlIiwiY29udGFjdEZvcmNlRXZlbnRzQWN0aXZlIiwiaGFzQ29sbGlzaW9uRXZlbnQiLCJoYXNDb250YWN0Rm9yY2VFdmVudCIsInNldEFjdGl2ZUV2ZW50cyIsIkNPTExJU0lPTl9FVkVOVFMiLCJDT05UQUNUX0ZPUkNFX0VWRU5UUyIsImRlbGV0ZSIsInJlc3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInVzZVJhcGllciIsInJhcGllciIsInJhcGllckNvbnRleHQiLCJ1c2VCZWZvcmVQaHlzaWNzU3RlcCIsImJlZm9yZVN0ZXBDYWxsYmFja3MiLCJhZGQiLCJ1c2VBZnRlclBoeXNpY3NTdGVwIiwiYWZ0ZXJTdGVwQ2FsbGJhY2tzIiwidXNlQ2hpbGRDb2xsaWRlclByb3BzIiwic2V0Q29sbGlkZXJQcm9wcyIsIkRlYnVnIiwibWVzaCIsImJ1ZmZlcnMiLCJkZWJ1Z1JlbmRlciIsInNldEF0dHJpYnV0ZSIsImNvbG9ycyIsImZydXN0dW1DdWxsZWQiLCJjb2xvciIsInZlcnRleENvbG9ycyIsImNyZWF0ZVNpbmdsZXRvblByb3h5IiwiY3JlYXRlSW5zdGFuY2UiLCJpbnN0YW5jZSIsImhhbmRsZXIiLCJwcm9wIiwiUmVmbGVjdCIsInByb3h5IiwiUHJveHkiLCJyZXNldCIsIm5ld0luc3RhbmNlIiwiZ2V0Q29sbGlzaW9uUGF5bG9hZEZyb21Tb3VyY2UiLCJvdGhlciIsIl90YXJnZXQkY29sbGlkZXIkc3RhdCIsIl90YXJnZXQkcmlnaWRCb2R5JHN0YSIsIl9vdGhlciRjb2xsaWRlciRzdGF0ZSIsIl9vdGhlciRyaWdpZEJvZHkkc3RhdCIsIl9vdGhlciRjb2xsaWRlciRzdGF0ZTIiLCJfb3RoZXIkcmlnaWRCb2R5JHN0YXQyIiwicmlnaWRCb2R5IiwiY29sbGlkZXJPYmplY3QiLCJpbXBvcnRSYXBpZXIiLCJyIiwiaW5pdCIsIlBoeXNpY3MiLCJjaGlsZHJlbiIsInRpbWVTdGVwIiwicGF1c2VkIiwiaW50ZXJwb2xhdGUiLCJ1cGRhdGVMb29wIiwiZGVidWciLCJncmF2aXR5IiwiYWxsb3dlZExpbmVhckVycm9yIiwicHJlZGljdGlvbkRpc3RhbmNlIiwibnVtU29sdmVySXRlcmF0aW9ucyIsIm51bUFkZGl0aW9uYWxGcmljdGlvbkl0ZXJhdGlvbnMiLCJudW1JbnRlcm5hbFBnc0l0ZXJhdGlvbnMiLCJtaW5Jc2xhbmRTaXplIiwibWF4Q2NkU3Vic3RlcHMiLCJlcnAiLCJpbnZhbGlkYXRlIiwicmlnaWRCb2R5U3RhdGVzIiwiTWFwIiwiY29sbGlkZXJTdGF0ZXMiLCJyaWdpZEJvZHlFdmVudHMiLCJjb2xsaWRlckV2ZW50cyIsImV2ZW50UXVldWUiLCJTZXQiLCJ3b3JsZFByb3h5IiwicmVzZXRXb3JsZFByb3h5Iiwic2V0V29ybGRQcm94eSIsIldvcmxkIiwiZnJlZSIsImludGVncmF0aW9uUGFyYW1ldGVycyIsImdldFNvdXJjZUZyb21Db2xsaWRlckhhbmRsZSIsIl9jb2xsaWRlciRwYXJlbnQiLCJjb2xFdmVudHMiLCJjb2xsaWRlclN0YXRlIiwicmlnaWRCb2R5SGFuZGxlIiwicmJFdmVudHMiLCJyaWdpZEJvZHlTdGF0ZSIsInN0ZXBwaW5nU3RhdGUiLCJwcmV2aW91c1N0YXRlIiwiYWNjdW11bGF0b3IiLCJzdGVwIiwidGltZVN0ZXBWYXJpYWJsZSIsImNsYW1wZWREZWx0YSIsImNsYW1wIiwic3RlcFdvcmxkIiwidGltZXN0ZXAiLCJmb3JFYWNoUmlnaWRCb2R5IiwiYm9keSIsInRyYW5zbGF0aW9uIiwiaW50ZXJwb2xhdGlvbkFscGhhIiwib25TbGVlcCIsIm9uV2FrZSIsImlzU2xlZXBpbmciLCJfZXZlbnRzJG9uU2xlZXAiLCJfZXZlbnRzJG9uV2FrZSIsInNldE1hdHJpeCIsInQiLCJjb21wb3NlIiwiaW52ZXJ0ZWRXb3JsZE1hdHJpeCIsIm1lc2hUeXBlIiwibGVycCIsInNsZXJwIiwiZHJhaW5Db2xsaXNpb25FdmVudHMiLCJoYW5kbGUxIiwiaGFuZGxlMiIsInN0YXJ0ZWQiLCJzb3VyY2UxIiwic291cmNlMiIsImNvbGxpc2lvblBheWxvYWQxIiwiY29sbGlzaW9uUGF5bG9hZDIiLCJjb250YWN0UGFpciIsIm1hbmlmb2xkIiwiZmxpcHBlZCIsIl9zb3VyY2UxJHJpZ2lkQm9keSRldiIsIl9zb3VyY2UxJHJpZ2lkQm9keSRldjIiLCJfc291cmNlMiRyaWdpZEJvZHkkZXYiLCJfc291cmNlMiRyaWdpZEJvZHkkZXYyIiwiX3NvdXJjZTEkY29sbGlkZXIkZXZlIiwiX3NvdXJjZTEkY29sbGlkZXIkZXZlMiIsIl9zb3VyY2UyJGNvbGxpZGVyJGV2ZSIsIl9zb3VyY2UyJGNvbGxpZGVyJGV2ZTIiLCJfc291cmNlMSRyaWdpZEJvZHkkZXYzIiwiX3NvdXJjZTEkcmlnaWRCb2R5JGV2NCIsIl9zb3VyY2UyJHJpZ2lkQm9keSRldjMiLCJfc291cmNlMiRyaWdpZEJvZHkkZXY0IiwiX3NvdXJjZTEkY29sbGlkZXIkZXZlMyIsIl9zb3VyY2UxJGNvbGxpZGVyJGV2ZTQiLCJfc291cmNlMiRjb2xsaWRlciRldmUzIiwiX3NvdXJjZTIkY29sbGlkZXIkZXZlNCIsImludGVyc2VjdGlvblBhaXIiLCJfc291cmNlMSRyaWdpZEJvZHkkZXY1IiwiX3NvdXJjZTEkcmlnaWRCb2R5JGV2NiIsIl9zb3VyY2UyJHJpZ2lkQm9keSRldjUiLCJfc291cmNlMiRyaWdpZEJvZHkkZXY2IiwiX3NvdXJjZTEkY29sbGlkZXIkZXZlNSIsIl9zb3VyY2UxJGNvbGxpZGVyJGV2ZTYiLCJfc291cmNlMiRjb2xsaWRlciRldmU1IiwiX3NvdXJjZTIkY29sbGlkZXIkZXZlNiIsIl9zb3VyY2UxJHJpZ2lkQm9keSRldjciLCJfc291cmNlMSRyaWdpZEJvZHkkZXY4IiwiX3NvdXJjZTIkcmlnaWRCb2R5JGV2NyIsIl9zb3VyY2UyJHJpZ2lkQm9keSRldjgiLCJfc291cmNlMSRjb2xsaWRlciRldmU3IiwiX3NvdXJjZTEkY29sbGlkZXIkZXZlOCIsIl9zb3VyY2UyJGNvbGxpZGVyJGV2ZTciLCJfc291cmNlMiRjb2xsaWRlciRldmU4IiwiZHJhaW5Db250YWN0Rm9yY2VFdmVudHMiLCJldmVudCIsIl9zb3VyY2UxJHJpZ2lkQm9keSRldjkiLCJfc291cmNlMSRyaWdpZEJvZHkkZXYxMCIsIl9zb3VyY2UyJHJpZ2lkQm9keSRldjkiLCJfc291cmNlMiRyaWdpZEJvZHkkZXYxMCIsIl9zb3VyY2UxJGNvbGxpZGVyJGV2ZTkiLCJfc291cmNlMSRjb2xsaWRlciRldmUxMCIsIl9zb3VyY2UyJGNvbGxpZGVyJGV2ZTkiLCJfc291cmNlMiRjb2xsaWRlciRldmUxMCIsImNvbGxpZGVyMSIsImNvbGxpZGVyMiIsInRvdGFsRm9yY2UiLCJ0b3RhbEZvcmNlTWFnbml0dWRlIiwibWF4Rm9yY2VEaXJlY3Rpb24iLCJtYXhGb3JjZU1hZ25pdHVkZSIsImZvckVhY2hBY3RpdmVSaWdpZEJvZHkiLCJjb250ZXh0Iiwic2V0V29ybGQiLCJwaHlzaWNzT3B0aW9ucyIsImlzUGF1c2VkIiwiaXNEZWJ1ZyIsInN0ZXBDYWxsYmFjayIsIlByb3ZpZGVyIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJiaW5kIiwiaGFzT3duUHJvcGVydHkiLCJ1c2VJbXBlcmF0aXZlSW5zdGFuY2UiLCJjcmVhdGVGbiIsImRlc3Ryb3lGbiIsImRlcGVuZGVuY3lMaXN0IiwiZ2V0SW5zdGFuY2UiLCJkZXN0cm95IiwidmVjMyIsInF1YXQiLCJldWxlciIsInVzZUZvcndhcmRlZFJlZiIsImZvcndhcmRlZFJlZiIsImRlZmF1bHRWYWx1ZSIsImlubmVyUmVmIiwiQW55Q29sbGlkZXIiLCJuYW1lIiwicmlnaWRCb2R5Q29udGV4dCIsInVzZVJpZ2lkQm9keUNvbnRleHQiLCJjb2xsaWRlclJlZiIsIm9iamVjdFJlZiIsImltbXV0YWJsZVByb3BBcnJheSIsInJlbW92ZUNvbGxpZGVyIiwibWVyZ2VkUHJvcHMiLCJDdWJvaWRDb2xsaWRlciIsImRpc3BsYXlOYW1lIiwiUm91bmRDdWJvaWRDb2xsaWRlciIsIkJhbGxDb2xsaWRlciIsIkNhcHN1bGVDb2xsaWRlciIsIkhlaWdodGZpZWxkQ29sbGlkZXIiLCJUcmltZXNoQ29sbGlkZXIiLCJDb25lQ29sbGlkZXIiLCJSb3VuZENvbmVDb2xsaWRlciIsIkN5bGluZGVyQ29sbGlkZXIiLCJSb3VuZEN5bGluZGVyQ29sbGlkZXIiLCJDb252ZXhIdWxsQ29sbGlkZXIiLCJyaWdpZEJvZHlEZXNjRnJvbU9wdGlvbnMiLCJfb3B0aW9ucyRjYW5TbGVlcCIsImNhblNsZWVwIiwiY3JlYXRlUmlnaWRCb2R5U3RhdGUiLCJnZXRNYXRyaXgiLCJfbWVzaFR5cGUiLCJtYXRyaXgiLCJpbW11dGFibGVSaWdpZEJvZHlPcHRpb25zIiwibXV0YWJsZVJpZ2lkQm9keU9wdGlvbnMiLCJncmF2aXR5U2NhbGUiLCJyYiIsInNldEdyYXZpdHlTY2FsZSIsImFkZGl0aW9uYWxTb2x2ZXJJdGVyYXRpb25zIiwic2V0QWRkaXRpb25hbFNvbHZlckl0ZXJhdGlvbnMiLCJsaW5lYXJEYW1waW5nIiwic2V0TGluZWFyRGFtcGluZyIsImFuZ3VsYXJEYW1waW5nIiwic2V0QW5ndWxhckRhbXBpbmciLCJkb21pbmFuY2VHcm91cCIsInNldERvbWluYW5jZUdyb3VwIiwiZW5hYmxlZFJvdGF0aW9ucyIsInNldEVuYWJsZWRSb3RhdGlvbnMiLCJlbmFibGVkVHJhbnNsYXRpb25zIiwic2V0RW5hYmxlZFRyYW5zbGF0aW9ucyIsImxvY2tSb3RhdGlvbnMiLCJsb2NrVHJhbnNsYXRpb25zIiwiYW5ndWxhclZlbG9jaXR5Iiwic2V0QW5ndmVsIiwibGluZWFyVmVsb2NpdHkiLCJzZXRMaW52ZWwiLCJjY2QiLCJlbmFibGVDY2QiLCJzZXRCb2R5VHlwZSIsIm11dGFibGVSaWdpZEJvZHlPcHRpb25LZXlzIiwic2V0UmlnaWRCb2R5T3B0aW9ucyIsInVwZGF0ZVRyYW5zbGF0aW9ucyIsInVzZVVwZGF0ZVJpZ2lkQm9keU9wdGlvbnMiLCJ1c2VSaWdpZEJvZHlFdmVudHMiLCJldmVudEhhbmRsZXJzIiwiX2V4Y2x1ZGVkJDEiLCJSaWdpZEJvZHlDb250ZXh0IiwidHJhbnNmb3JtU3RhdGUiLCJvYmplY3RQcm9wcyIsInJpZ2lkQm9keVJlZiIsIm1lcmdlZE9wdGlvbnMiLCJjcmVhdGVSaWdpZEJvZHkiLCJyZW1vdmVSaWdpZEJvZHkiLCJjb250ZXh0VmFsdWUiLCJNZXNoQ29sbGlkZXIiLCJfZXhjbHVkZWQiLCJJbnN0YW5jZWRSaWdpZEJvZGllcyIsInJpZ2lkQm9kaWVzUmVmIiwiaW5zdGFuY2VXcmFwcGVyUmVmIiwiaW5zdGFuY2VzIiwiY29sbGlkZXJOb2RlcyIsInJpZ2lkQm9keVByb3BzIiwiZ2V0SW5zdGFuY2VkTWVzaCIsImZpcnN0Q2hpbGQiLCJpbnN0YW5jZWRNZXNoIiwiaW5zdGFuY2VNYXRyaXgiLCJzZXRVc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwiYXBwbHlJbnN0YW5jZWRTdGF0ZSIsImdldE1hdHJpeEF0Iiwic2V0TWF0cml4QXQiLCJuZWVkc1VwZGF0ZSIsIm5vZGUiLCJjb2xsaWRlckluZGV4IiwidXNlSW1wdWxzZUpvaW50IiwiYm9keTEiLCJib2R5MiIsInBhcmFtcyIsImpvaW50UmVmIiwibmV3Sm9pbnQiLCJjcmVhdGVJbXB1bHNlSm9pbnQiLCJqb2ludCIsImdldEltcHVsc2VKb2ludCIsInJlbW92ZUltcHVsc2VKb2ludCIsInVzZUZpeGVkSm9pbnQiLCJib2R5MUFuY2hvciIsImJvZHkxTG9jYWxGcmFtZSIsImJvZHkyQW5jaG9yIiwiYm9keTJMb2NhbEZyYW1lIiwiSm9pbnREYXRhIiwidXNlU3BoZXJpY2FsSm9pbnQiLCJzcGhlcmljYWwiLCJ1c2VSZXZvbHV0ZUpvaW50IiwiYXhpcyIsImxpbWl0cyIsInJldm9sdXRlIiwibGltaXRzRW5hYmxlZCIsInVzZVByaXNtYXRpY0pvaW50IiwicHJpc21hdGljIiwidXNlUm9wZUpvaW50IiwidkJvZHkxQW5jaG9yIiwidkJvZHkyQW5jaG9yIiwicm9wZSIsInVzZVNwcmluZ0pvaW50IiwicmVzdExlbmd0aCIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJzcHJpbmciLCJpbnRlcmFjdGlvbkdyb3VwcyIsIm1lbWJlcnNoaXBzIiwiZmlsdGVycyIsImJpdG1hc2siLCJncm91cHMiLCJmbGF0IiwicmVkdWNlIiwiYWNjIiwibGF5ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/rapier/dist/react-three-rapier.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9fcG9seWZpbGwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlDO0FBQ2pDLE1BQU1DLFVBQVVDLFNBQVNGLDJDQUFRQSxDQUFDRyxPQUFPLENBQUMsUUFBUTtBQUdoRCxDQUNGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL2NvbnN0YW50cy5qcz8xOWRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSk7XG5leHBvcnQge1xuICB2ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJFVklTSU9OIiwidmVyc2lvbiIsInBhcnNlSW50IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"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\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9saWJzL01lc2hvcHREZWNvZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQTtBQUNKLE1BQU1DLGlCQUFpQjtJQUNyQixJQUFJRCxXQUNGLE9BQU9BO0lBQ1QsTUFBTUUsWUFBWTtJQUNsQixNQUFNQyxZQUFZO0lBQ2xCLE1BQU1DLFdBQVcsSUFBSUMsV0FBVztRQUM5QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUNELE1BQU1DLFdBQVcsSUFBSUQsV0FBVztRQUM5QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUNELElBQUksT0FBT0UsZ0JBQWdCLFVBQVU7UUFDbkMsT0FBTztZQUNMQyxXQUFXO1FBQ2I7SUFDRjtJQUNBLElB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Q0FBQ1gsT0FBTyxDQUFDO1FBRXJDO1FBQ0F1QixtQkFBa0IzQixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzNDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDd0MseUJBQXlCLEVBQUU1QixRQUFRQyxPQUFPQyxNQUFNQztRQUMxRTtRQUNBMEIscUJBQW9CN0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTTtZQUM3Q0wsT0FBT2hCLFNBQVNNLE9BQU8sQ0FBQzBDLDJCQUEyQixFQUFFOUIsUUFBUUMsT0FBT0MsTUFBTUM7UUFDNUU7UUFDQTRCLGtCQUFpQi9CLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTZCLElBQUksRUFBRTVCLE1BQU07WUFDeEROLE9BQ0VoQixTQUFTTSxPQUFPLENBQUNnQyxRQUFRLENBQUNZLEtBQUssQ0FBQyxFQUNoQ2hDLFFBQ0FDLE9BQ0FDLE1BQ0FDLFFBQ0FyQixTQUFTTSxPQUFPLENBQUMyQixPQUFPLENBQUNYLE9BQU8sQ0FBQztRQUVyQztJQUNGO0lBQ0EsT0FBT2pDO0FBQ1Q7QUFHRSxDQUNGLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbGlicy9NZXNob3B0RGVjb2Rlci5qcz84ZDY5Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBnZW5lcmF0ZWQ7XG5jb25zdCBNZXNob3B0RGVjb2RlciA9ICgpID0+IHtcbiAgaWYgKGdlbmVyYXRlZClcbiAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICBjb25zdCB3YXNtX2Jhc2UgPSBcIkI5aDl6OXRGQkJCRjhmTDlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYTlnRWFhYUZhRU1jQkZGRkdHR0VJSUlMRjl3RkZGTEVGQkZLTkZhRkN4L0lGTU8vTEZWSzl0djl0OXZxOTVHQnQ5ZjlmOTM5aDl6OXQ5ZjlqOWg5czlzOWY5alc5dnE5ekJCcDl0djl6OW85djl3VzlmOWt2OWo5djlrdjlXdnFXdjk0aDkxOW05bXZxQkY4Wjl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NGg5MTltOW12cUJHeTl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NDlUdlo5MXY5dTlqdkJFbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVA5aldCSWk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlSOTE5aFdCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlGOTQ5d0JLSTl6OWlxbEJPYyt4OHljR0JNL3FRRlRhOGpVVVVVQkNVL0VCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUdUa1VVVUJSTkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJWQUVDRkpSSUNCUmNHWEVYQWNBRjlQUUZBVkFGQWNsQWNBVkpBRjlKeVJNR1hHWEFHOUZRQkFNQ2JKSEtDOXdaUlNBS0NJckNFSkNHclJRQU5DVUdKUmZDQlJiQUlSVEVYR1hBT0FUbEFROVBRQkNCUklTRU1BVEFRSlJJR1hBUzlGUUJDQlJ0Q0JSRUVYR1hBT0FJbENpOVBRQkNCUklTTE1BTkNVL0NCSkFFSlJLR1hHWEdYR1hHWEFUQUVDS3JKMkJCQXRDS1pyQ0VaZklCRkdFQk1BS2hCODNFQkFLQ05KaEI4M0VCU0VNQUtBSTJCSUFJMkJCSG1DS3JIWUFZQ0U2SFl5ODZCQkFLQ0ZKQUlDSUpBWUpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NHSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDRUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ0lKQVlBbUpIWTJCQkFJMkJGSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ0xKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NLSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDT0pBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ05KQVlBbUpIWTJCQkFJMkJHSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ1ZKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NjSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDTUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ1NKQVlBbUpIbTJCQkFJMkJFSElDS3JIWUFZQ0U2SFl5ODZCQkFLQ1FKQW1BWUpIbTJCQkFJQ0lyQ0VaSFlBWUNFNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSUNHckNFWkhZQVlDRTZIWXk4NkJCQUtDYkpBbUFZSkhLMkJCQUlDRVpISUFJQ0U2SEl5ODZCQkFLQUlKUklTR01BS0FJMkJOQUkyQkJIbUNJckhZQVlDYjZIWXk4NkJCQUtDRkpBSUNOSkFZSkhZMkJCQW1DYlpIbUFtQ2I2SG15ODZCQkFLQ0dKQVlBbUpIbTJCQkFJMkJGSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ0VKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NJSkFtQVlKSG0yQkJBSTJCR0hZQ0lySFBBUENiNkhQeTg2QkJBS0NMSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDS0pBbUFZSkhtMkJCQUkyQkVIWUNJckhQQVBDYjZIUHk4NkJCQUtDT0pBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ05KQW1BWUpIbTJCQkFJMkJJSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1ZKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NjSkFtQVlKSG0yQkJBSTJCTEhZQ0lySFBBUENiNkhQeTg2QkJBS0NNSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDU0pBbUFZSkhtMkJCQUkyQktIWUNJckhQQVBDYjZIUHk4NkJCQUtDUUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ2ZKQW1BWUpIbTJCQkFJMkJPSElDSXJIWUFZQ2I2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ2JaSElBSUNiNkhJeTg2QkJBS0FJSlJJU0ZNQUtBSThwQkI4M0JCQUtDTkpBSUNOSjhwQkI4M0JCQUlDVEpSSU1BdENHSlJ0QUVDVEpIRUFTOUpRQk1NR1hBSVFCQ0JSSVNFTUdYQU05RlFCQU5BYkoyQkJSdENCUktBZlJFRVhBRUFOQ1UvQ0JKQUtKMkJCSFRDRnJDQkFUQ0ZabDl6QXRKSHQ4NkJCQUVBR0pSRUFLQ0ZKSEtBTTlIUUJNTUFmQ0ZKUmZBSVJUQWJDRkpIYkFHOUhRQk1NQUJBY0FHOXNKQU5DVUdKQU1BRzlzVGtVVVVCcEFOQU5DVUdKQU1DYUpBRzlzSkFHVGtVVVVCcE1BTUNCQUl5QWNKUmNBSVFCTUM5K1JLU0ZNQ0JDOTlBT0FJbEFHQ0FBR0NBOUx5NnlSS01BTENVL0VCSjhrVVVVVUJBS00rT21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUZUK0pVVVVCcEFMQzg0SmhhODNFQkFMQzh3SmhhODNFQkFMQzhvSmhhODNFQkFMQ0FKaGE4M0VCQUxDaUpoYTgzRUJBTENUSmhhODNFQkFMaGE4M0VOQUxoYTgzRUJBRUFJSkM5d0pSY0FFQ0ZKSE5BT0pSTUdYQUY5RlFCQ1FDYkFWQ0Y2eVJTQUJSRUNCUlZDQlJRQ0JSZkNCUklDQlJLRVhHWEFNQWN1UUJDOStSS1NFTUdYR1hBTjJCQkhPQy92RjlMUUJBTENvQkpBT0NJckNhOXpBS0pDYlpDRVdKSGI4b0dJUlRBYjhvR0JSdEdYQU9DYlpIYkFTOVBRQkFMQU9DYTl6QUlKQ2JaQ0dXSjhvR0JBVkFieVJPQWI5RlJiR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFPODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQU9qR0JBRUNJSkFUakdCTUFWQWJKUlZBTENvQkpBS0NFV0pIbUFPakdCQW1BVGpHSUFMQUlDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhUQXRqR0JBVEFPakdJQUlBYkpSSUFLQ0ZKUktTR01HWEdYQWJDYjZRQkFRQWJKQWJDOTg5ekpDRkpSUVNGTUFNMUJCSGJDZ0ZaUk9HWEdYQWJDYTlNUUJBTUNGSlJNU0ZNQU0xQkZIYkNnQlpDT1dBT0NnQlpxUk9HWEFiQ2E5TVFCQU1DR0pSTVNGTUFNMUJHSGJDZ0JaQ2ZXQU9xUk9HWEFiQ2E5TVFCQU1DRUpSTVNGTUFNMUJFSGJDZ0JaQ2RXQU9xUk9HWEFiQ2E5TVFCQU1DSUpSTVNGTUFNMkJJQzhjV0FPcVJPQU1DTEpSTU1BT0NGckNCQU9DRlpsOXpBUUpSUU1HWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQVE4N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBUWpHQkFFQ0lKQVRqR0JNQUxDb0JKQUtDRVdKSE9BUWpHQkFPQVRqR0lBTEFJQ0dXSkFRakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIT0F0akdCQU9BUWpHSUFJQ0ZKUklBS0NGSlJLU0ZNR1hBT0NERjlMUUJBTEFJQWNBT0NiWkoyQkJIYkNJckhUbENiWkNHV0o4b0dCQVZDRkpIdEFUeVJPQUxBSUFibENiWkNHV0o4b0dCQXRBVDlGSG1KSHRBYkNiWkhUeVJiQVQ5RlJUR1hHWEFHQ0c5SFFCQUJBVjg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVmpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQUlDR1dKQVZqR0JBTENvQkpBS0NFV0pIWUFPakdCQVlBVmpHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUFtSkNiWkhJQ0dXSkFiakdCQUxDb0JKQUtDR0pDYlpIS0NFV0pIT0FWakdCQU9BYmpHSUFLQ0ZKUktBSUFUSlJJQXRBVEpSVlNGTUFWQ0JBTTJCQkhZeUhUQU9DLytGNkhQSlJPQVlDYlpSdEdYR1hBWUNJckhtUUJBT0NGSlJiU0ZNQU9SYkFMQUlBbWxDYlpDR1dKOG9HQlJPTUdYR1hBdFFCQWJDRkpSVlNGTUFiUlZBTEFJQVlsQ2JaQ0dXSjhvR0JSYk1HWEdYQVA5RlFCQU1DRkpSWVNGTUFNMUJGSFlDZ0ZaUlRHWEdYQVlDYTlNUUJBTUNHSlJZU0ZNQU0xQkdIWUNnQlpDT1dBVENnQlpxUlRHWEFZQ2E5TVFCQU1DRUpSWVNGTUFNMUJFSFlDZ0JaQ2ZXQVRxUlRHWEFZQ2E5TVFCQU1DSUpSWVNGTUFNMUJJSFlDZ0JaQ2RXQVRxUlRHWEFZQ2E5TVFCQU1DTEpSWVNGTUFNQ0tKUllBTTJCTEM4Y1dBVHFSVE1BVENGckNCQVRDRlpsOXpBUUpIUVJUTUdYR1hBbUNiNlFCQVlSUFNGTUFZMUJCSE1DZ0ZaUk9HWEdYQU1DYTlNUUJBWUNGSlJQU0ZNQVkxQkZITUNnQlpDT1dBT0NnQlpxUk9HWEFNQ2E5TVFCQVlDR0pSUFNGTUFZMUJHSE1DZ0JaQ2ZXQU9xUk9HWEFNQ2E5TVFCQVlDRUpSUFNGTUFZMUJFSE1DZ0JaQ2RXQU9xUk9HWEFNQ2E5TVFCQVlDSUpSUFNGTUFZQ0xKUlBBWTJCSUM4Y1dBT3FST01BT0NGckNCQU9DRlpsOXpBUUpIUVJPTUdYR1hBdENiNlFCQVBSTVNGTUFQMUJCSE1DZ0ZaUmJHWEdYQU1DYTlNUUJBUENGSlJNU0ZNQVAxQkZITUNnQlpDT1dBYkNnQlpxUmJHWEFNQ2E5TVFCQVBDR0pSTVNGTUFQMUJHSE1DZ0JaQ2ZXQWJxUmJHWEFNQ2E5TVFCQVBDRUpSTVNGTUFQMUJFSE1DZ0JaQ2RXQWJxUmJHWEFNQ2E5TVFCQVBDSUpSTVNGTUFQQ0xKUk1BUDJCSUM4Y1dBYnFSYk1BYkNGckNCQWJDRlpsOXpBUUpIUVJiTUdYR1hBR0NHOUhRQkFCQVQ4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVRqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTENvQkpBS0NFV0pIWUFPakdCQVlBVGpHSUFMQUlDR1dKQVRqR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0dKQ2JaQ0VXSkhPQVRqR0JBT0FiakdJQUxBSUFtOUZBbUNiNnFKSElDYlpDR1dKQWJqR0JBSUF0OUZBdENiNnFKUklBS0NFSlJLTUFOQ0ZKUk5BQkNLSlJCQUVDU0pSRUFLQ2JaUktBSUNiWlJJQWZDRUpIZkFGOUpRQk1NQ0JDOTlBTUFjNnlSS01BTENvRko4a1VVVVVCQUtNL3RJRkdhOGpVVVVVQkNUbFJMQzkrUktHWEFGQ0xKQUk5TFFCQ2FSS0FFMkJCQy8rRlpDL1FGOUhRQkFMaEI4M0VOQUVDRkpSS0FFQUlKQzk4SlJFR1hBRjlGUUJHWEFHQ0c2UUJFWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BTENOSkFJQ0ZaQ0dXcUhHQUlDR3JDQkFJQ0ZyQ0ZabDl6QUc4b0dCSkhJakdCQUJBSWpHQkFCQ0lKUkJBRkNhSkhGUUJTR01NRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUJBSUNHckNCQUlDRnJDRlpsOXpBTENOSkFJQ0ZaQ0dXcUhJOG9HQkpIRzg3RkJBSUFHakdCQUJDR0pSQkFGQ2FKSEZRQk1NQ0JDOTlBS0FFNnlSS01BS00rbExLRmFGOTlHYUc5OUZhRzk5R1hHWEFHQ0k5SFFCQUY5RlFGRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNHSkhHMUJCK3lBQjFCQkhFK3lISStMK1RBQkNGSkhMMUJCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQkIvK2hBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODZCQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODZCQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODZCQkFCQ0lKUkJBRkNhSkhGUUJTR01NQUY5RlFCRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNJSkhHOHVGQit5QUI4dUZCSEUreUhJK0wrVEFCQ0dKSEw4dUZCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQi8rZzZBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODdGQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODdGQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODdGQkFCQ05KUkJBRkNhSkhGUUJNTU0vU0VJRWFFOTlFYUY5OUdYQUY5RlFCQ0JSRUFCUklFWEdYR1g5RC96STgxOC9BSUNLSjh1RkJITENFcSt5K1ZIS0FJOHVGQit5K1VITzlEQi8rZzYrVTlEQkJCOC85REJCQisvQU85REJCQkI5Z3krU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JWU0ZNQ1VVVVU5NFJWTUFJQ0lKOHVGQlJjQUlDR0o4dUZCUk1BQkFMQ0ZKQ0VaQUVxQ0ZXSkFWODdGQkdYR1hBS0FNK3krVUhOOURCLytnNitVOURCQkI4LzlEQkJCKy9BTjlEQkJCQjlneStTSFMrTDlEQkJCOVA5ZDlGUUJBUytvUk1TRk1DVVVVVTk0Uk1NQUJBTENHSkNFWkFFcUNGV0pBTTg3RkJHWEdYQUtBYyt5K1VISzlEQi8rZzYrVTlEQkJCOC85REJCQisvQUs5REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JjU0ZNQ1VVVVU5NFJjTUFCQUxDYUpDRVpBRXFDRldKQWM4N0ZCR1hHWDlEQkJVOC9BT0FPK1UrVEFOQU4rVStUQUtBSytVK1RITzlEQkJCQkFPOURCQkJCOWd5K1I5REIvK2c2K1U5REJCQjgvK1NITytMOURCQkI5UDlkOUZRQkFPK29SY1NGTUNVVVVVOTRSY01BQkFMQ0VaQUVxQ0ZXSkFjODdGQkFJQ05KUklBRUNJSlJFQUZDYUpIRlFCTU1NOUpCR1hBR0NHckFGOXNIRjlGUUJFWEFCQUI4b0dCSEdDTldDTjkxK3lBR0NpOTFDbldDVVVVLzhFSisrK1U4NEdCQUJDSUpSQkFGQ2FKSEZRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU0vbEZGRmFHWEdYQUZBQnFDRVo5RlFCQUJSRVNGTUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFGOG9HQmpHQkFFQ0lKQUZDSUo4b0dCakdCQUVDTkpBRkNOSjhvR0JqR0JBRUNTSkFGQ1NKOG9HQmpHQkFFQ1RKUkVBRkNUSlJGQUdDOXdKSEdDYjlMUUJNTUFHQ0k5SlFCRVhBRUFGOG9HQmpHQkFGQ0lKUkZBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGMkJCODZCQkFFQ0ZKUkVBRkNGSlJGQUdDYUpIR1FCTU1BQk1vRkZHYUdYR1hBQkNFWjlGUUJBQlJFU0ZNQUZDZ0ZaQytCd3NOOXNSSUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFJakdCQUVDU0pBSWpHQkFFQ05KQUlqR0JBRUNJSkFJakdCQUVDVEpSRUFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBSWpHQkFFQ0lKUkVBR0M5OEpIR0NFOUxRQk1NR1hBRzlGUUJFWEFFQUY4NkJCQUVDRkpSRUFHQ2FKSEdRQk1NQUJNTU1GQkNVTk1JVDlrQkJcIjtcbiAgY29uc3Qgd2FzbV9zaW1kID0gXCJCOWg5ejl0RkJCQkZpSTlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYUVNY0JCRkJGRkdHR0VJTEY5d0ZGRkxFRkJGS05GYUZDeC9hRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJHOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCSXk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQktpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQk9uOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCTkk5ejlpcWxCVmMrTjlJY0lCVEVNOStGTGE4alVVVVVCQ1RsUkJDQlJGRVhDQlJHQ0JSRUVYQUJDTkpBR0pBRUNVYUFGQUdyQ0ZaSEl5ODZCQkFFQUlKUkVBR0NGSkhHQ045SFFCTUFGQ3grWVVVQkpBRTg2QkJBRkNFV0N4a1VVQkpBQjhwRU44M0VCQUZDRkpIRkNVRzlIUUJNTWs4bExiYUU5N0Y5K0ZhTDk3OGpVVVVVQkNVL0tCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUcvOGNCQkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJOQUVDRkpSS0NCUlZHWEVYQVZBRjlQUUZBTkFGQVZsQVZBTkpBRjlKeVJjR1hHWEFHOUZRQkFjQ2JKSElDOXdaSE1DRTlzUlNBTUNGV1JRQUlDSXJDRUpDR3JSZkNCUmJFWEFLUlRDQlJ0R1hFWEdYQU9BVGxBZjlQUUJDQlJLU0xNQUxDVS9DQkpBdEFNOXNKUm1BVEFmSlJLQ0JSRUdYQU1Db0I5SlFCQU9BS2xDL2dCOUpRQkNCUklFWEFtQUlKUkVHWEdYR1hHWEdYQVRBSUNLckoyQkJIWUNFWmZJQkZHRUJNQUVDQkR0RE1JQlNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUJBS0NUSlJLTUdYR1hHWEdYR1hBWUNHckNFWmZJQkZHRUJNQUVDQkR0RE1JVFNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSVRBS0NUSlJLTUdYR1hHWEdYR1hBWUNJckNFWmZJQkZHRUJNQUVDQkR0RE1JQVNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUFBS0NUSlJLTUdYR1hHWEdYR1hBWUNLcmZJQkZHRUJNQUVDQkR0RE1JOHdTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIWUNFV0N4a1VVQkpEQkVCQVlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUk4d0FLQ0lKQWVEZUJKQVlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NOSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSTh3QUtDVEpSS01BSUNvQkpSRUFJQ1VGSkFNOUxRRkFFUklBT0FLbEMvZkI5TFFCTU1HWEFFQU05UFFCQUVDRXJSSUVYR1hBT0FLbENpOVBRQkNCUktTT01BbUFFSlJZR1hHWEdYR1hHWEFUQUVDS3JKMkJCQUlDS1pyQ0VaZklCRkdFQk1BWUNCRHRETUlCU0VNQVlBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFZQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFZQUtEQkJCRE1JQkFLQ1RKUktNQUlDR0pSSUFFQ1RKSEVBTTlKUUJNTUdYQUs5RlFCQUtSVEF0Q0ZKSHRDSTZRR1NGTU1DQlJLU0VNR1hBTTlGUUJBTENVR0pBYkpSRUFMQWJKREJHQlJlQ0JSWUVYQUVBTENVL0NCSkFZSkhJREJJQkhkQ0ZEOXRBZENGRGJIUEQ5T0Q5aEQ5UkhkQUlBTUpEQklCSDhaQ0ZEOXRBOFpBUEQ5T0Q5aEQ5Ukg4WkRRQlRGdEdtRVlJUExkS2VPbkhwQUlBUUpEQklCSHlDRkQ5dEF5QVBEOU9EOWhEOVJIeUFJQVNKREJJQkg4Y0NGRDl0QThjQVBEOU9EOWhEOVJIOGNEUUJURnRHbUVZSVBMZEtlT25IOGREUUJGVHRHRW1ZSUxQZEtPZW5IUEFQRFFCRkdFQkZHRUJGR0VCRkdFQWVEOXVIZUR5QmpHQkFFQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFwQThkRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBZEE4WkRRTmlWOFpjcE15UzhjUThkZjhlYjhmSGRBeUE4Y0RRTmlWOFpjcE15UzhjUThkZjhlYjhmSDhaRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5WaThaY01weVNROGM4ZGZiOGU4ZkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKUkVBWUNUSkhZQU05SlFCTU1BYkNJSkhiQUc5SlFCTU1BQkFWQUc5c0pBTENVR0pBY0FHOXMvOGNCQkFMQUxDVUdKQWNDYUpBRzlzSkFHLzhjQkJNQWNDQkFLeUFWSlJWQUtRQk1DOStSS1NGTUNCQzk5QU9BS2xBR0NBQUdDQTlMeTZ5UktNQUxDVS9LQko4a1VVVVVCQUtNTkJUK0JVVVVCTStLbUZUYThqVVVVVUJDb0ZsSEw4a1VVVVVCQzkrUktHWEFGQ0U5dUhPQ3RKQUk5TFFCQ2FSS0FFMkJCSE5DL3dGWkMvZ0Y5SFFCQU5DYlpIVkNGOUxRQkFMQ29CSkNnRkNVRi84TUJBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNL2RMRUs5N0ZhRjk3R1hHWEFHQ0k5SFFCQUY5RlFGQ0JSR0VYQUJBQkRCQkJIRUNpRCtyRkNpRCtzRkQvNkZISUFFQ05EK3JGQ2lEK3NGRC82RkFJRC9nRkFFQ1REK3JGQ2lEK3NGRC82RkhMRC9nRkQva0ZEL2xGSEtDQkR0RCsyRkhPQUlDVVVVVTk0RHRITkQ5T0Q5UkQva0ZISTlEQkIvK2hEWUFJQUlEL21GQUtBS0QvbUZBTEFPQUxBTkQ5T0Q5UkQva0ZISUFJRC9tRkQva0ZEL2tGRC9qRkQvbkZITEQvbUY5REJCWDlMRFlIT0Qva0ZDZ0ZEdEQ5T0FFQ1VVVTk0RHREOU9EOVFBSUFMRC9tRkFPRC9rRkNORCtyRkNVLytFRHREOU9EOVFBS0FMRC9tRkFPRC9rRkNURCtyRkNVVS84T0R0RDlPRDlRRE1CQkFCQ1RKUkJBR0NJSkhHQUY5SlFCU0dNTUFGOUZRQkNCUkdFWEFCQ1RKSFZBVkRCQkJIRUNCRHRIT0NVVTk4RDhjRkNVVTk4RDhjRUhORDlPQUJEQkJCSEtBRURRSUxLT1NRZmJQZGVuOGM4ZDhlOGZDZ2dGRHREOU9ELzZGQUtBRURRQkZHRU5WY01UdG1ZaThacHlIRUNURCtzRkQvNkZISUQvZ0ZBRUNURCtyRkNURCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhFOURCLytnNkRZQUxBRUFPRCsyRkhPQUxDVVVVVTk0RHRIY0Q5T0Q5UkQva0ZITEFMRC9tRkFFQUVEL21GQUlBT0FJQWNEOU9EOVJEL2tGSEVBRUQvbUZEL2tGRC9rRkQvakZEL25GSElEL21GOURCQlg5TERZSE9EL2tGQ1REK3JGQUxBSUQvbUZBT0Qva0ZDZ2dFRHREOU9EOVFITEFFQUlEL21GQU9EL2tGQ2FEYkNCRG5HQ0JEbkVDQkRuS0NCRG5PQ0JEbmNDQkRuTUNCRG5mQ0JEbmJEOU9IRURRTlZpOFpjTXB5U1E4YzhkZmI4ZThmRDlRRE1CQkFCQUtBTkQ5T0FMQUVEUUJGVHRHRW1ZSUxQZEtPZW5EOVFETUJCQUJDQUpSQkFHQ0lKSEdBRjlKUUJNTU0vaEVJR2FGOTdGYUw5NzhqVVVVVUJDVGxSRUdYQUY5RlFCQ0JSSUVYQUVBQkRCQkJITEFCQ1RKSEtEQkJCSE9EUUlMS09TUWZiUGRlbjhjOGQ4ZThmSE5DVEQrc0ZIVkNJRCtyRkRNSUJBQjlEQkJVOC9EWTlEL3pJODE4L0RZQVZDRUR0RDlRRC82RkQvbkZIVkFMQU9EUUJGR0VOVmNNVHRtWWk4WnB5SExDVEQrckZDVEQrc0ZELzZGRC9tRkhPQU9EL21GQVZBTENURCtzRkQvNkZEL21GSGNBY0QvbUZBVkFOQ1REK3JGQ1REK3NGRC82RkQvbUZITkFORC9tRkQva0ZEL2tGRC9sRkNCRHREKzRGRC9qRjlEQi8rZzZEWUhWRC9tRjlEQkJYOUxEWUhMRC9rRkNnZ0VEdEhNRDlPQWNBVkQvbUZBTEQva0ZDVEQrckZEOVFIY0FOQVZEL21GQUxEL2tGQ1REK3JGQU9BVkQvbUZBTEQva0ZBTUQ5T0Q5UUhWRFFCRlR0R0VtWUlMUGRLT2VuSExEOGRCQUVEQklCRHlCK3QrSjgzRUJBQkNOSkFMRDhkRkFFREJJQkR5Rit0K0o4M0VCQUtBY0FWRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIVkQ4ZEJBRURCSUJEeUcrdCtKODNFQkFCQ2lKQVZEOGRGQUVEQklCRHlFK3QrSjgzRUJBQkNBSlJCQUlDSUpISUFGOUpRQk1NTTlqRkY5N0dYQUdDR3JBRjlzSEc5RlFCQ0JSRkVYQUJBQkRCQkJIRUNORCtyRkNORCtzRkQvNkZBRUNpRCtzRkNuRCtyRkNVVVUvOEVEdEQrdUZEL21GRE1CQkFCQ1RKUkJBRkNJSkhGQUc5SlFCTU1NOVRGRWFDQkNCOG9HVWtVVUJIRkFCQ0VKQzk4WkpIQmpHVWtVVUJHWEdYQUI4L0JDVFdIR3VRQkNhUkVBQkFHbENnZ0VKQ1RyWEJDYTZRRk1BRlJFTUFFTU1NRkJDVU5NSVQ5dEJCXCI7XG4gIGNvbnN0IGRldGVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsXG4gICAgOTcsXG4gICAgMTE1LFxuICAgIDEwOSxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDEsXG4gICAgNCxcbiAgICAxLFxuICAgIDk2LFxuICAgIDAsXG4gICAgMCxcbiAgICAzLFxuICAgIDMsXG4gICAgMixcbiAgICAwLFxuICAgIDAsXG4gICAgNSxcbiAgICAzLFxuICAgIDEsXG4gICAgMCxcbiAgICAxLFxuICAgIDEyLFxuICAgIDEsXG4gICAgMCxcbiAgICAxMCxcbiAgICAyMixcbiAgICAyLFxuICAgIDEyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUyLFxuICAgIDEwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxMSxcbiAgICA3LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICAyNTMsXG4gICAgMTUsXG4gICAgMjYsXG4gICAgMTFcbiAgXSk7XG4gIGNvbnN0IHdhc21wYWNrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDMyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMjUzLFxuICAgIDMsXG4gICAgMSxcbiAgICAyLFxuICAgIDM0LFxuICAgIDQsXG4gICAgMTA2LFxuICAgIDYsXG4gICAgNSxcbiAgICAxMSxcbiAgICA4LFxuICAgIDcsXG4gICAgMjAsXG4gICAgMTMsXG4gICAgMzMsXG4gICAgMTIsXG4gICAgMTYsXG4gICAgMTI4LFxuICAgIDksXG4gICAgMTE2LFxuICAgIDY0LFxuICAgIDE5LFxuICAgIDExMyxcbiAgICAxMjcsXG4gICAgMTUsXG4gICAgMTAsXG4gICAgMjEsXG4gICAgMjIsXG4gICAgMTQsXG4gICAgMjU1LFxuICAgIDY2LFxuICAgIDI0LFxuICAgIDU0LFxuICAgIDEzNixcbiAgICAxMDcsXG4gICAgMTgsXG4gICAgMjMsXG4gICAgMTkyLFxuICAgIDI2LFxuICAgIDExNCxcbiAgICAxMTgsXG4gICAgMTMyLFxuICAgIDE3LFxuICAgIDc3LFxuICAgIDEwMSxcbiAgICAxMzAsXG4gICAgMTQ0LFxuICAgIDI3LFxuICAgIDg3LFxuICAgIDEzMSxcbiAgICA0NCxcbiAgICA0NSxcbiAgICA3NCxcbiAgICAxNTYsXG4gICAgMTU0LFxuICAgIDcwLFxuICAgIDE2N1xuICBdKTtcbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB7XG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBsZXQgd2FzbSA9IHdhc21fYmFzZTtcbiAgaWYgKFdlYkFzc2VtYmx5LnZhbGlkYXRlKGRldGVjdG9yKSkge1xuICAgIHdhc20gPSB3YXNtX3NpbWQ7XG4gIH1cbiAgbGV0IGluc3RhbmNlO1xuICBjb25zdCBwcm9taXNlID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodW5wYWNrKHdhc20pLCB7fSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgaW5zdGFuY2UgPSByZXN1bHQuaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZXhwb3J0cy5fX3dhc21fY2FsbF9jdG9ycygpO1xuICB9KTtcbiAgZnVuY3Rpb24gdW5wYWNrKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjaCA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHJlc3VsdFtpXSA9IGNoID4gOTYgPyBjaCAtIDcxIDogY2ggPiA2NCA/IGNoIC0gNjUgOiBjaCA+IDQ3ID8gY2ggKyA0IDogY2ggPiA0NiA/IDYzIDogNjI7XG4gICAgfVxuICAgIGxldCB3cml0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRbd3JpdGUrK10gPSByZXN1bHRbaV0gPCA2MCA/IHdhc21wYWNrW3Jlc3VsdFtpXV0gOiAocmVzdWx0W2ldIC0gNjApICogNjQgKyByZXN1bHRbKytpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXIuc2xpY2UoMCwgd3JpdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShmdW4sIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc2JyayA9IGluc3RhbmNlLmV4cG9ydHMuc2JyaztcbiAgICBjb25zdCBjb3VudDQgPSBjb3VudCArIDMgJiB+MztcbiAgICBjb25zdCB0cCA9IHNicmsoY291bnQ0ICogc2l6ZSk7XG4gICAgY29uc3Qgc3AgPSBzYnJrKHNvdXJjZS5sZW5ndGgpO1xuICAgIGNvbnN0IGhlYXAgPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgIGhlYXAuc2V0KHNvdXJjZSwgc3ApO1xuICAgIGNvbnN0IHJlcyA9IGZ1bih0cCwgY291bnQsIHNpemUsIHNwLCBzb3VyY2UubGVuZ3RoKTtcbiAgICBpZiAocmVzID09PSAwICYmIGZpbHRlcikge1xuICAgICAgZmlsdGVyKHRwLCBjb3VudDQsIHNpemUpO1xuICAgIH1cbiAgICB0YXJnZXQuc2V0KGhlYXAuc3ViYXJyYXkodHAsIHRwICsgY291bnQgKiBzaXplKSk7XG4gICAgc2Jyayh0cCAtIHNicmsoMCkpO1xuICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGJ1ZmZlciBkYXRhOiAke3Jlc31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmlsdGVycyA9IHtcbiAgICAvLyBsZWdhY3kgaW5kZXgtYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICAwOiBcIlwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIDM6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHBcIixcbiAgICAvLyBzdHJpbmctYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICBOT05FOiBcIlwiLFxuICAgIE9DVEFIRURSQUw6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICBRVUFURVJOSU9OOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIEVYUE9ORU5USUFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCJcbiAgfTtcbiAgY29uc3QgZGVjb2RlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIDI6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgQVRUUklCVVRFUzogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIFRSSUFOR0xFUzogXCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyXCIsXG4gICAgSU5ESUNFUzogXCJtZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2VcIlxuICB9O1xuICBnZW5lcmF0ZWQgPSB7XG4gICAgcmVhZHk6IHByb21pc2UsXG4gICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgIGRlY29kZVZlcnRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4QnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlciwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4U2VxdWVuY2UodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKSB7XG4gICAgICBkZWNvZGUoaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2UsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVHbHRmQnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgbW9kZSwgZmlsdGVyKSB7XG4gICAgICBkZWNvZGUoXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZGVjb2RlcnNbbW9kZV1dLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBnZW5lcmF0ZWQ7XG59O1xuZXhwb3J0IHtcbiAgTWVzaG9wdERlY29kZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNob3B0RGVjb2Rlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZWQiLCJNZXNob3B0RGVjb2RlciIsIndhc21fYmFzZSIsIndhc21fc2ltZCIsImRldGVjdG9yIiwiVWludDhBcnJheSIsIndhc21wYWNrIiwiV2ViQXNzZW1ibHkiLCJzdXBwb3J0ZWQiLCJ3YXNtIiwidmFsaWRhdGUiLCJpbnN0YW5jZSIsInByb21pc2UiLCJpbnN0YW50aWF0ZSIsInVucGFjayIsInRoZW4iLCJyZXN1bHQiLCJleHBvcnRzIiwiX193YXNtX2NhbGxfY3RvcnMiLCJkYXRhIiwibGVuZ3RoIiwiaSIsImNoIiwiY2hhckNvZGVBdCIsIndyaXRlIiwiYnVmZmVyIiwic2xpY2UiLCJkZWNvZGUiLCJmdW4iLCJ0YXJnZXQiLCJjb3VudCIsInNpemUiLCJzb3VyY2UiLCJmaWx0ZXIiLCJzYnJrIiwiY291bnQ0IiwidHAiLCJzcCIsImhlYXAiLCJtZW1vcnkiLCJzZXQiLCJyZXMiLCJzdWJhcnJheSIsIkVycm9yIiwiZmlsdGVycyIsIk5PTkUiLCJPQ1RBSEVEUkFMIiwiUVVBVEVSTklPTiIsIkVYUE9ORU5USUFMIiwiZGVjb2RlcnMiLCJBVFRSSUJVVEVTIiwiVFJJQU5HTEVTIiwiSU5ESUNFUyIsInJlYWR5IiwiZGVjb2RlVmVydGV4QnVmZmVyIiwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXIiLCJkZWNvZGVJbmRleEJ1ZmZlciIsIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIiLCJkZWNvZGVJbmRleFNlcXVlbmNlIiwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlIiwiZGVjb2RlR2x0ZkJ1ZmZlciIsIm1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRFO0FBQzVFLE1BQU1JLGFBQWEsYUFBYSxHQUFHLElBQUlDO0FBQ3ZDLE1BQU1DLG9CQUFvQk4seUNBQU1BO0lBQzlCTyxZQUFZQyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7WUFDekJDLFVBQVU7WUFDVkMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLElBQUk7UUFDTjtRQUNBLElBQUksQ0FBQ0MscUJBQXFCLEdBQUc7WUFDM0JKLFVBQVU7WUFDVkMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLElBQUk7UUFDTjtJQUNGO0lBQ0FFLGVBQWVDLElBQUksRUFBRTtRQUNuQixJQUFJLENBQUNmLFdBQVcsR0FBR2U7UUFDbkIsT0FBTyxJQUFJO0lBQ2I7SUFDQUMsaUJBQWlCQyxNQUFNLEVBQUU7UUFDdkIsSUFBSSxDQUFDaEIsYUFBYSxHQUFHZ0I7UUFDckIsT0FBTyxJQUFJO0lBQ2I7SUFDQUMsZUFBZWQsV0FBVyxFQUFFO1FBQzFCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBZSxLQUFLQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUU7UUFDckMs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QUNILE9BQU90RCxNQUFNdUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPeEQsTUFBTXlELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzFELE1BQU0yRCxRQUFRO1lBQ3ZCLEtBQUtDO2dCQUNILE9BQU81RCxNQUFNNkQsU0FBUztZQUN4QixLQUFLdEI7Z0JBQ0gsT0FBT3ZDLE1BQU04RCxTQUFTO1FBQzFCO0lBQ0Y7QUFDRjtBQUdFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzPzYzZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBfdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBEUkFDT0xvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gXCJcIjtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcbiAgICB0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuICAgIHRoaXMud29ya2VyTGltaXQgPSA0O1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG4gICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBcIlwiO1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIlBPU0lUSU9OXCIsXG4gICAgICBub3JtYWw6IFwiTk9STUFMXCIsXG4gICAgICBjb2xvcjogXCJDT0xPUlwiLFxuICAgICAgdXY6IFwiVEVYX0NPT1JEXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuICAgICAgcG9zaXRpb246IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBub3JtYWw6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBjb2xvcjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIHV2OiBcIkZsb2F0MzJBcnJheVwiXG4gICAgfTtcbiAgfVxuICBzZXREZWNvZGVyUGF0aChwYXRoKSB7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RGVjb2RlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2VyTGltaXQod29ya2VyTGltaXQpIHtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVJRHM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICAgICAgdXNlVW5pcXVlSURzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihvbkxvYWQpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuICBkZWNvZGVEcmFjb0ZpbGUoYnVmZmVyLCBjYWxsYmFjaywgYXR0cmlidXRlSURzLCBhdHRyaWJ1dGVUeXBlcykge1xuICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICBhdHRyaWJ1dGVJRHM6IGF0dHJpYnV0ZUlEcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICBhdHRyaWJ1dGVUeXBlczogYXR0cmlidXRlVHlwZXMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICB1c2VVbmlxdWVJRHM6ICEhYXR0cmlidXRlSURzXG4gICAgfTtcbiAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmICh0eXBlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXNrS2V5ID0gSlNPTi5zdHJpbmdpZnkodGFza0NvbmZpZyk7XG4gICAgaWYgKF90YXNrQ2FjaGUuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldChidWZmZXIpO1xuICAgICAgaWYgKGNhY2hlZFRhc2sua2V5ID09PSB0YXNrS2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUYXNrLnByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd29ya2VyO1xuICAgIGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCsrO1xuICAgIGNvbnN0IHRhc2tDb3N0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpLnRoZW4oKF93b3JrZXIpID0+IHtcbiAgICAgIHdvcmtlciA9IF93b3JrZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG1lc3NhZ2UuZ2VvbWV0cnkpKTtcbiAgICBnZW9tZXRyeVBlbmRpbmcuY2F0Y2goKCkgPT4gdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAod29ya2VyICYmIHRhc2tJRCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3Rhc2tDYWNoZS5zZXQoYnVmZmVyLCB7XG4gICAgICBrZXk6IHRhc2tLZXksXG4gICAgICBwcm9taXNlOiBnZW9tZXRyeVBlbmRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuICB9XG4gIF9jcmVhdGVHZW9tZXRyeShnZW9tZXRyeURhdGEpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeURhdGEuaW5kZXgpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnlEYXRhLmluZGV4LmFycmF5LCAxKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgY29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgX2xvYWRMaWJyYXJ5KHVybCwgcmVzcG9uc2VUeXBlKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKHJlc3BvbnNlVHlwZSk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgcmVzb2x2ZSwgdm9pZCAwLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgdGhpcy5faW5pdERlY29kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdERlY29kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpXG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgICBjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiB8fCB0aGlzLmRlY29kZXJDb25maWcudHlwZSA9PT0gXCJqc1wiO1xuICAgIGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcbiAgICBpZiAodXNlSlMpIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fd2FzbV93cmFwcGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLndhc21cIiwgXCJhcnJheWJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBQcm9taXNlLmFsbChsaWJyYXJpZXNQZW5kaW5nKS50aGVuKChsaWJyYXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1swXTtcbiAgICAgIGlmICghdXNlSlMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnLndhc21CaW5hcnkgPSBsaWJyYXJpZXNbMV07XG4gICAgICB9XG4gICAgICBjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICBcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixcbiAgICAgICAganNDb250ZW50LFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIi8qIHdvcmtlciAqL1wiLFxuICAgICAgICBmbi5zdWJzdHJpbmcoZm4uaW5kZXhPZihcIntcIikgKyAxLCBmbi5sYXN0SW5kZXhPZihcIn1cIikpXG4gICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2JvZHldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gIH1cbiAgX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMud29ya2VyTGltaXQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyMiA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpO1xuICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0Nvc3RzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tMb2FkID0gMDtcbiAgICAgICAgd29ya2VyMi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiaW5pdFwiLCBkZWNvZGVyQ29uZmlnOiB0aGlzLmRlY29kZXJDb25maWcgfSk7XG4gICAgICAgIHdvcmtlcjIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdO1xuICAgICAgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXSA9IHRhc2tDb3N0O1xuICAgICAgd29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSk7XG4gIH1cbiAgX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKSB7XG4gICAgd29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICB9XG4gIGRlYnVnKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJUYXNrIGxvYWQ6IFwiLFxuICAgICAgdGhpcy53b3JrZXJQb29sLm1hcCgod29ya2VyKSA9PiB3b3JrZXIuX3Rhc2tMb2FkKVxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud29ya2VyUG9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy53b3JrZXJQb29sW2ldLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG4gIGxldCBkZWNvZGVyQ29uZmlnO1xuICBsZXQgZGVjb2RlclBlbmRpbmc7XG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICBkZWNvZGVyQ29uZmlnID0gbWVzc2FnZS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBkZWNvZGVyQ29uZmlnLm9uTW9kdWxlTG9hZGVkID0gZnVuY3Rpb24oZHJhY28pIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkcmFjbyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIERyYWNvRGVjb2Rlck1vZHVsZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZXNzYWdlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IG1lc3NhZ2UudGFza0NvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG4gICAgICAgICAgZGVjb2RlckJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gYXR0ci5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4KVxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXJCdWZmZXIpO1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuICAgIGxldCBkcmFjb0dlb21ldHJ5O1xuICAgIGxldCBkZWNvZGluZ1N0YXR1cztcbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBkZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoZGVjb2RlckJ1ZmZlcik7XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6IFwiICsgZGVjb2RpbmdTdGF0dXMuZXJyb3JfbXNnKCkpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdHRyaWJ1dGVJRDtcbiAgICAgIGlmICh0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcykge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVJZChkcmFjb0dlb21ldHJ5LCBkcmFjb1thdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV1dKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZUlEID09PSAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSk7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZ2VvbWV0cnkuaW5kZXggPSBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfVxuICAgIGRyYWNvLmRlc3Ryb3koZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KSB7XG4gICAgY29uc3QgbnVtRmFjZXMgPSBkcmFjb0dlb21ldHJ5Lm51bV9mYWNlcygpO1xuICAgIGNvbnN0IG51bUluZGljZXMgPSBudW1GYWNlcyAqIDM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bUluZGljZXMgKiA0O1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4geyBhcnJheTogaW5kZXgsIGl0ZW1TaXplOiAxIH07XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpO1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlLCBkYXRhVHlwZSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgYXJyYXksXG4gICAgICBpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQ4O1xuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBEUkFDT0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURSQUNPTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkxvYWRlciIsIkZpbGVMb2FkZXIiLCJCdWZmZXJHZW9tZXRyeSIsIkJ1ZmZlckF0dHJpYnV0ZSIsIl90YXNrQ2FjaGUiLCJXZWFrTWFwIiwiRFJBQ09Mb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJkZWNvZGVyUGF0aCIsImRlY29kZXJDb25maWciLCJkZWNvZGVyQmluYXJ5IiwiZGVjb2RlclBlbmRpbmciLCJ3b3JrZXJMaW1pdCIsIndvcmtlclBvb2wiLCJ3b3JrZXJOZXh0VGFza0lEIiwid29ya2VyU291cmNlVVJMIiwiZGVmYXVsdEF0dHJpYnV0ZUlEcyIsInBvc2l0aW9uIiwibm9ybWFsIiwiY29sb3IiLCJ1diIsImRlZmF1bHRBdHRyaWJ1dGVUeXBlcyIsInNldERlY29kZXJQYXRoIiwicGF0aCIsInNldERlY29kZXJDb25maWciLCJjb25maWciLCJzZXRXb3JrZXJMaW1pdCIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsImxvYWRlciIsInNldFBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFdpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImJ1ZmZlciIsInRhc2tDb25maWciLCJhdHRyaWJ1dGVJRHMiLCJhdHRyaWJ1dGVUeXBlcyIsInVzZVVuaXF1ZUlEcyIsImRlY29kZUdlb21ldHJ5IiwidGhlbiIsImNhdGNoIiwiZGVjb2RlRHJhY29GaWxlIiwiY2FsbGJhY2siLCJhdHRyaWJ1dGUiLCJ0eXBlIiwiQllURVNfUEVSX0VMRU1FTlQiLCJuYW1lIiwidGFza0tleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXMiLCJjYWNoZWRUYXNrIiwiZ2V0Iiwia2V5IiwicHJvbWlzZSIsImJ5dGVMZW5ndGgiLCJFcnJvciIsIndvcmtlciIsInRhc2tJRCIsInRhc2tDb3N0IiwiZ2VvbWV0cnlQZW5kaW5nIiwiX2dldFdvcmtlciIsIl93b3JrZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIl9jYWxsYmFja3MiLCJwb3N0TWVzc2FnZSIsImlkIiwibWVzc2FnZSIsIl9jcmVhdGVHZW9tZXRyeSIsImdlb21ldHJ5IiwiX3JlbGVhc2VUYXNrIiwic2V0IiwiZ2VvbWV0cnlEYXRhIiwiaW5kZXgiLCJzZXRJbmRleCIsImFycmF5IiwiaSIsImF0dHJpYnV0ZXMiLCJsZW5ndGgiLCJpdGVtU2l6ZSIsInNldEF0dHJpYnV0ZSIsIl9sb2FkTGlicmFyeSIsInJlc3BvbnNlVHlwZSIsInByZWxvYWQiLCJfaW5pdERlY29kZXIiLCJ1c2VKUyIsIldlYkFzc2VtYmx5IiwibGlicmFyaWVzUGVuZGluZyIsInB1c2giLCJhbGwiLCJsaWJyYXJpZXMiLCJqc0NvbnRlbnQiLCJ3YXNtQmluYXJ5IiwiZm4iLCJEUkFDT1dvcmtlciIsInRvU3RyaW5nIiwiYm9keSIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImpvaW4iLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwid29ya2VyMiIsIldvcmtlciIsIl90YXNrQ29zdHMiLCJfdGFza0xvYWQiLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsImNvbnNvbGUiLCJlcnJvciIsInNvcnQiLCJhIiwiYiIsImRlYnVnIiwibG9nIiwibWFwIiwiZGlzcG9zZSIsInRlcm1pbmF0ZSIsIm9uTW9kdWxlTG9hZGVkIiwiZHJhY28iLCJEcmFjb0RlY29kZXJNb2R1bGUiLCJtb2R1bGUiLCJkZWNvZGVyIiwiRGVjb2RlciIsImRlY29kZXJCdWZmZXIiLCJEZWNvZGVyQnVmZmVyIiwiSW5pdCIsIkludDhBcnJheSIsImJ1ZmZlcnMiLCJhdHRyIiwic2VsZiIsImRlc3Ryb3kiLCJkcmFjb0dlb21ldHJ5IiwiZGVjb2RpbmdTdGF0dXMiLCJnZW9tZXRyeVR5cGUiLCJHZXRFbmNvZGVkR2VvbWV0cnlUeXBlIiwiVFJJQU5HVUxBUl9NRVNIIiwiTWVzaCIsIkRlY29kZUJ1ZmZlclRvTWVzaCIsIlBPSU5UX0NMT1VEIiwiUG9pbnRDbG91ZCIsIkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZCIsIm9rIiwicHRyIiwiZXJyb3JfbXNnIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVJRCIsIkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQiLCJHZXRBdHRyaWJ1dGVJZCIsIkdldEF0dHJpYnV0ZSIsImRlY29kZUF0dHJpYnV0ZSIsImRlY29kZUluZGV4IiwibnVtRmFjZXMiLCJudW1fZmFjZXMiLCJudW1JbmRpY2VzIiwiX21hbGxvYyIsIkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJIRUFQRjMyIiwic2xpY2UiLCJfZnJlZSIsIm51bUNvbXBvbmVudHMiLCJudW1fY29tcG9uZW50cyIsIm51bVBvaW50cyIsIm51bV9wb2ludHMiLCJudW1WYWx1ZXMiLCJkYXRhVHlwZSIsImdldERyYWNvRGF0YVR5cGUiLCJHZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMiLCJGbG9hdDMyQXJyYXkiLCJEVF9GTE9BVDMyIiwiRFRfSU5UOCIsIkludDE2QXJyYXkiLCJEVF9JTlQxNiIsIkludDMyQXJyYXkiLCJEVF9JTlQzMiIsIlVpbnQ4QXJyYXkiLCJEVF9VSU5UOCIsIlVpbnQxNkFycmF5IiwiRFRfVUlOVDE2IiwiRFRfVUlOVDMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/fflate/esm/index.mjs\");\n\n\nconst hasColorSpace = \"colorSpace\" in new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0VYUkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNkg7QUFDekY7QUFDcEMsTUFBTVMsZ0JBQWdCLGdCQUFnQixJQUFJVCwwQ0FBT0E7QUFDakQsTUFBTVUsa0JBQWtCVCxvREFBaUJBO0lBQ3ZDVSxZQUFZQyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxnREFBYUE7SUFDM0I7SUFDQVksTUFBTUMsTUFBTSxFQUFFO1FBQ1osTUFBTUMsZUFBZSxLQUFLO1FBQzFCLE1BQU1DLGNBQWNELGdCQUFnQjtRQUNwQyxNQUFNRSxjQUFjO1FBQ3BCLE1BQU1DLGNBQWM7UUFDcEIsTUFBTUMsY0FBYyxDQUFDLEtBQUtGLFdBQVUsSUFBSztRQUN6QyxNQUFNRyxjQUFjLEtBQUtGO1FBQ3pCLE1BQU1HLGNBQWNELGNBQWM7UUFDbEMsTUFBTUUsUUFBUTtRQUNkLE1BQU1DLFdBQVcsS0FBS0QsUUFBUTtRQUM5QixNQUFNRSxXQUFXLENBQUMsS0FBS0YsS0FBSSxJQUFLO1FBQ2hDLE1BQU1HLHFCQUFxQjtRQUMzQixNQUFNQyxvQkFBb0I7UUFDMUIsTUFBTUMsb0JBQW9CLElBQUlELG9CQUFvQkQ7UUFDbEQsTUFBTUcsYUFBYTtRQUNuQixNQUFNQyxlQUFlO1FBQ3JCLE1BQU1DLGFBQWE7UUFDbkIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLGlCQUFpQjtRQUN2QixNQUFNQyxVQUFVO1FBQ2hCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsWUFBWTtRQUNsQixNQUFNQyxNQUFNO1FBQ1osTUFBTUMsVUFBVUMsS0FBS0MsR0FBRyxDQUFDLFdBQVc7UUFDcEMsU0FBU0MscUJBQXFCQyxNQUFNLEVBQUVDLEdBQUc7WUFDdkMsSUFBSUMsSUFBSTtZQUNSLElBQUssSUFB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QUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdI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QVMsR0FBR25hLCtDQUFZQTtZQUNoQ2lhLFFBQVFHLFNBQVMsR0FBR3BhLCtDQUFZQTtZQUNoQ2lhLFFBQVFJLGVBQWUsR0FBRztZQUMxQkosUUFBUUssS0FBSyxHQUFHO1lBQ2hCLElBQUlULFFBQ0ZBLE9BQU9JLFNBQVNDO1FBQ3BCO1FBQ0EsT0FBTyxLQUFLLENBQUNQLEtBQUtDLEtBQUtJLGdCQUFnQkYsWUFBWUM7SUFDckQ7QUFDRjtBQUdFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0VYUkxvYWRlci5qcz81MzdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHR1cmUsIERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIFJHQkFGb3JtYXQsIFJlZEZvcm1hdCwgTGluZWFyRmlsdGVyLCBEYXRhVXRpbHMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHVuemxpYlN5bmMgfSBmcm9tIFwiZmZsYXRlXCI7XG5jb25zdCBoYXNDb2xvclNwYWNlID0gXCJjb2xvclNwYWNlXCIgaW4gbmV3IFRleHR1cmUoKTtcbmNsYXNzIEVYUkxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgVVNIT1JUX1JBTkdFID0gMSA8PCAxNjtcbiAgICBjb25zdCBCSVRNQVBfU0laRSA9IFVTSE9SVF9SQU5HRSA+PiAzO1xuICAgIGNvbnN0IEhVRl9FTkNCSVRTID0gMTY7XG4gICAgY29uc3QgSFVGX0RFQ0JJVFMgPSAxNDtcbiAgICBjb25zdCBIVUZfRU5DU0laRSA9ICgxIDw8IEhVRl9FTkNCSVRTKSArIDE7XG4gICAgY29uc3QgSFVGX0RFQ1NJWkUgPSAxIDw8IEhVRl9ERUNCSVRTO1xuICAgIGNvbnN0IEhVRl9ERUNNQVNLID0gSFVGX0RFQ1NJWkUgLSAxO1xuICAgIGNvbnN0IE5CSVRTID0gMTY7XG4gICAgY29uc3QgQV9PRkZTRVQgPSAxIDw8IE5CSVRTIC0gMTtcbiAgICBjb25zdCBNT0RfTUFTSyA9ICgxIDw8IE5CSVRTKSAtIDE7XG4gICAgY29uc3QgU0hPUlRfWkVST0NPREVfUlVOID0gNTk7XG4gICAgY29uc3QgTE9OR19aRVJPQ09ERV9SVU4gPSA2MztcbiAgICBjb25zdCBTSE9SVEVTVF9MT05HX1JVTiA9IDIgKyBMT05HX1pFUk9DT0RFX1JVTiAtIFNIT1JUX1pFUk9DT0RFX1JVTjtcbiAgICBjb25zdCBVTE9OR19TSVpFID0gODtcbiAgICBjb25zdCBGTE9BVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDE2X1NJWkUgPSAyO1xuICAgIGNvbnN0IElOVDhfU0laRSA9IDE7XG4gICAgY29uc3QgU1RBVElDX0hVRkZNQU4gPSAwO1xuICAgIGNvbnN0IERFRkxBVEUgPSAxO1xuICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgIGNvbnN0IExPU1NZX0RDVCA9IDE7XG4gICAgY29uc3QgUkxFID0gMjtcbiAgICBjb25zdCBsb2dCYXNlID0gTWF0aC5wb3coMi43MTgyODE4LCAyLjIpO1xuICAgIGZ1bmN0aW9uIHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KSB7XG4gICAgICB2YXIgayA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFVTSE9SVF9SQU5HRTsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDAgfHwgYml0bWFwW2kgPj4gM10gJiAxIDw8IChpICYgNykpIHtcbiAgICAgICAgICBsdXRbaysrXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuID0gayAtIDE7XG4gICAgICB3aGlsZSAoayA8IFVTSE9SVF9SQU5HRSlcbiAgICAgICAgbHV0W2srK10gPSAwO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkNsZWFyRGVjVGFibGUoaGRlYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfREVDU0laRTsgaSsrKSB7XG4gICAgICAgIGhkZWNbaV0gPSB7fTtcbiAgICAgICAgaGRlY1tpXS5sZW4gPSAwO1xuICAgICAgICBoZGVjW2ldLmxpdCA9IDA7XG4gICAgICAgIGhkZWNbaV0ucCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdldEJpdHNSZXR1cm4gPSB7IGw6IDAsIGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Qml0cyhuQml0cywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCkge1xuICAgICAgd2hpbGUgKGxjIDwgbkJpdHMpIHtcbiAgICAgICAgYyA9IGMgPDwgOCB8IHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBsYyArPSA4O1xuICAgICAgfVxuICAgICAgbGMgLT0gbkJpdHM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmwgPSBjID4+IGxjICYgKDEgPDwgbkJpdHMpIC0gMTtcbiAgICAgIGdldEJpdHNSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGNvbnN0IGh1ZlRhYmxlQnVmZmVyID0gbmV3IEFycmF5KDU5KTtcbiAgICBmdW5jdGlvbiBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDU4OyArK2kpXG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSlcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaGNvZGVbaV1dICs9IDE7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gNTg7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG5jID0gYyArIGh1ZlRhYmxlQnVmZmVyW2ldID4+IDE7XG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gYztcbiAgICAgICAgYyA9IG5jO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfRU5DU0laRTsgKytpKSB7XG4gICAgICAgIHZhciBsID0gaGNvZGVbaV07XG4gICAgICAgIGlmIChsID4gMClcbiAgICAgICAgICBoY29kZVtpXSA9IGwgfCBodWZUYWJsZUJ1ZmZlcltsXSsrIDw8IDY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZlVucGFja0VuY1RhYmxlKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUpIHtcbiAgICAgIHZhciBwID0gaW5PZmZzZXQ7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIGlmIChwLnZhbHVlIC0gaW5PZmZzZXQudmFsdWUgPiBuaSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGdldEJpdHMoNiwgYywgbGMsIHVJbnQ4QXJyYXkyLCBwKTtcbiAgICAgICAgdmFyIGwgPSBnZXRCaXRzUmV0dXJuLmw7XG4gICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sYztcbiAgICAgICAgaGNvZGVbaW1dID0gbDtcbiAgICAgICAgaWYgKGwgPT0gTE9OR19aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICBpZiAocC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0Qml0cyg4LCBjLCBsYywgdUludDhBcnJheTIsIHApO1xuICAgICAgICAgIHZhciB6ZXJ1biA9IGdldEJpdHNSZXR1cm4ubCArIFNIT1JURVNUX0xPTkdfUlVOO1xuICAgICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKVxuICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgIGltLS07XG4gICAgICAgIH0gZWxzZSBpZiAobCA+PSBTSE9SVF9aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICB2YXIgemVydW4gPSBsIC0gU0hPUlRfWkVST0NPREVfUlVOICsgMjtcbiAgICAgICAgICBpZiAoaW0gKyB6ZXJ1biA+IGlNICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSlcbiAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICBpbS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZMZW5ndGgoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgJiA2MztcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQ29kZShjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PiA2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZCdWlsZERlY1RhYmxlKGhjb2RlLCBpbSwgaU0sIGhkZWNvZCkge1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIHZhciBjID0gaHVmQ29kZShoY29kZVtpbV0pO1xuICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChoY29kZVtpbV0pO1xuICAgICAgICBpZiAoYyA+PiBsKSB7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgPiBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFtjID4+IGwgLSBIVUZfREVDQklUU107XG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsLmxpdCsrO1xuICAgICAgICAgIGlmIChwbC5wKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBsLnA7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KHBsLmxpdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsLmxpdCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICBwbC5wW2ldID0gcFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGwucCA9IG5ldyBBcnJheSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGwucFtwbC5saXQgLSAxXSA9IGltO1xuICAgICAgICB9IGVsc2UgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgcGxPZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxIDw8IEhVRl9ERUNCSVRTIC0gbDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHBsID0gaGRlY29kWyhjIDw8IEhVRl9ERUNCSVRTIC0gbCkgKyBwbE9mZnNldF07XG4gICAgICAgICAgICBpZiAocGwubGVuIHx8IHBsLnApIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbC5sZW4gPSBsO1xuICAgICAgICAgICAgcGwubGl0ID0gaW07XG4gICAgICAgICAgICBwbE9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGdldENoYXJSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KSB7XG4gICAgICBjID0gYyA8PCA4IHwgcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICBsYyArPSA4O1xuICAgICAgZ2V0Q2hhclJldHVybi5jID0gYztcbiAgICAgIGdldENoYXJSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgY29uc3QgZ2V0Q29kZVJldHVybiA9IHsgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRDb2RlKHBvLCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyT2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgIGlmIChwbyA9PSBybGMpIHtcbiAgICAgICAgaWYgKGxjIDwgOCkge1xuICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIH1cbiAgICAgICAgbGMgLT0gODtcbiAgICAgICAgdmFyIGNzID0gYyA+PiBsYztcbiAgICAgICAgdmFyIGNzID0gbmV3IFVpbnQ4QXJyYXkoW2NzXSlbMF07XG4gICAgICAgIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgKyBjcyA+IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUgLSAxXTtcbiAgICAgICAgd2hpbGUgKGNzLS0gPiAwKSB7XG4gICAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlIDwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBwbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGdldENvZGVSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRDb2RlUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVJbnQxNih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYgNjU1MzU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludDE2KHZhbHVlKSB7XG4gICAgICB2YXIgcmVmID0gVUludDE2KHZhbHVlKTtcbiAgICAgIHJldHVybiByZWYgPiAzMjc2NyA/IHJlZiAtIDY1NTM2IDogcmVmO1xuICAgIH1cbiAgICBjb25zdCB3ZGVjMTRSZXR1cm4gPSB7IGE6IDAsIGI6IDAgfTtcbiAgICBmdW5jdGlvbiB3ZGVjMTQobCwgaCkge1xuICAgICAgdmFyIGxzID0gSW50MTYobCk7XG4gICAgICB2YXIgaHMgPSBJbnQxNihoKTtcbiAgICAgIHZhciBoaSA9IGhzO1xuICAgICAgdmFyIGFpID0gbHMgKyAoaGkgJiAxKSArIChoaSA+PiAxKTtcbiAgICAgIHZhciBhcyA9IGFpO1xuICAgICAgdmFyIGJzID0gYWkgLSBoaTtcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYXM7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZGVjMTYobCwgaCkge1xuICAgICAgdmFyIG0gPSBVSW50MTYobCk7XG4gICAgICB2YXIgZCA9IFVJbnQxNihoKTtcbiAgICAgIHZhciBiYiA9IG0gLSAoZCA+PiAxKSAmIE1PRF9NQVNLO1xuICAgICAgdmFyIGFhID0gZCArIGJiIC0gQV9PRkZTRVQgJiBNT0RfTUFTSztcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYWE7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXYyRGVjb2RlKGJ1ZmZlcjIsIGosIG54LCBveCwgbnksIG95LCBteCkge1xuICAgICAgdmFyIHcxNCA9IG14IDwgMSA8PCAxNDtcbiAgICAgIHZhciBuID0gbnggPiBueSA/IG55IDogbng7XG4gICAgICB2YXIgcCA9IDE7XG4gICAgICB2YXIgcDI7XG4gICAgICB3aGlsZSAocCA8PSBuKVxuICAgICAgICBwIDw8PSAxO1xuICAgICAgcCA+Pj0gMTtcbiAgICAgIHAyID0gcDtcbiAgICAgIHAgPj49IDE7XG4gICAgICB3aGlsZSAocCA+PSAxKSB7XG4gICAgICAgIHZhciBweSA9IDA7XG4gICAgICAgIHZhciBleSA9IHB5ICsgb3kgKiAobnkgLSBwMik7XG4gICAgICAgIHZhciBveTEgPSBveSAqIHA7XG4gICAgICAgIHZhciBveTIgPSBveSAqIHAyO1xuICAgICAgICB2YXIgb3gxID0gb3ggKiBwO1xuICAgICAgICB2YXIgb3gyID0gb3ggKiBwMjtcbiAgICAgICAgdmFyIGkwMCwgaTAxLCBpMTAsIGkxMTtcbiAgICAgICAgZm9yICg7IHB5IDw9IGV5OyBweSArPSBveTIpIHtcbiAgICAgICAgICB2YXIgcHggPSBweTtcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDE7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTE7XG4gICAgICAgICAgICB2YXIgcDExID0gcDEwICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNCkge1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChueCAmIHApIHtcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MTtcbiAgICAgICAgICAgIGlmICh3MTQpXG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gaTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnkgJiBwKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHk7XG4gICAgICAgICAgdmFyIGV4ID0gcHkgKyBveCAqIChueCAtIHAyKTtcbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNClcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMDEgKyBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDAxICsgal0pO1xuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSBpMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAyID0gcDtcbiAgICAgICAgcCA+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBweTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmRGVjb2RlKGVuY29kaW5nVGFibGUsIGRlY29kaW5nVGFibGUsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIHJsYywgbm8sIG91dEJ1ZmZlciwgb3V0T2Zmc2V0KSB7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgdmFyIG91dEJ1ZmZlckVuZE9mZnNldCA9IG5vO1xuICAgICAgdmFyIGluT2Zmc2V0RW5kID0gTWF0aC50cnVuYyhpbk9mZnNldC52YWx1ZSArIChuaSArIDcpIC8gOCk7XG4gICAgICB3aGlsZSAoaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIHdoaWxlIChsYyA+PSBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBpbmRleCA9IGMgPj4gbGMgLSBIVUZfREVDQklUUyAmIEhVRl9ERUNNQVNLO1xuICAgICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbaW5kZXhdO1xuICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGwubGl0OyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSk7XG4gICAgICAgICAgICAgIHdoaWxlIChsYyA8IGwgJiYgaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxjID49IGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHVmQ29kZShlbmNvZGluZ1RhYmxlW3BsLnBbal1dKSA9PSAoYyA+PiBsYyAtIGwgJiAoMSA8PCBsKSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICBsYyAtPSBsO1xuICAgICAgICAgICAgICAgICAgZ2V0Q29kZShcbiAgICAgICAgICAgICAgICAgICAgcGwucFtqXSxcbiAgICAgICAgICAgICAgICAgICAgcmxjLFxuICAgICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgICBsYyxcbiAgICAgICAgICAgICAgICAgICAgdUludDhBcnJheTIsXG4gICAgICAgICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvdXRCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIG91dE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyRW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT0gcGwubGl0KSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSA4IC0gbmkgJiA3O1xuICAgICAgYyA+Pj0gaTtcbiAgICAgIGxjIC09IGk7XG4gICAgICB3aGlsZSAobGMgPiAwKSB7XG4gICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbYyA8PCBIVUZfREVDQklUUyAtIGxjICYgSFVGX0RFQ01BU0tdO1xuICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmVW5jb21wcmVzcyh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5Db21wcmVzc2VkLCBvdXRCdWZmZXIsIG5SYXcpIHtcbiAgICAgIHZhciBvdXRPZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgICB2YXIgaW5pdGlhbEluT2Zmc2V0ID0gaW5PZmZzZXQudmFsdWU7XG4gICAgICB2YXIgaW0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICB2YXIgaU0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0O1xuICAgICAgdmFyIG5CaXRzID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaW5PZmZzZXQudmFsdWUgKz0gNDtcbiAgICAgIGlmIChpbSA8IDAgfHwgaW0gPj0gSFVGX0VOQ1NJWkUgfHwgaU0gPCAwIHx8IGlNID49IEhVRl9FTkNTSVpFKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggSFVGX0VOQ1NJWkVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmVxID0gbmV3IEFycmF5KEhVRl9FTkNTSVpFKTtcbiAgICAgIHZhciBoZGVjID0gbmV3IEFycmF5KEhVRl9ERUNTSVpFKTtcbiAgICAgIGh1ZkNsZWFyRGVjVGFibGUoaGRlYyk7XG4gICAgICB2YXIgbmkgPSBuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCk7XG4gICAgICBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGZyZXEpO1xuICAgICAgaWYgKG5CaXRzID4gOCAqIChuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCkpKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5jb21wcmVzc1wiO1xuICAgICAgfVxuICAgICAgaHVmQnVpbGREZWNUYWJsZShmcmVxLCBpbSwgaU0sIGhkZWMpO1xuICAgICAgaHVmRGVjb2RlKGZyZXEsIGhkZWMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkJpdHMsIGlNLCBuUmF3LCBvdXRCdWZmZXIsIG91dE9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5THV0KGx1dCwgZGF0YSwgbkRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkRhdGE7ICsraSkge1xuICAgICAgICBkYXRhW2ldID0gbHV0W2RhdGFbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVkaWN0b3Ioc291cmNlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IHNvdXJjZS5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgZCA9IHNvdXJjZVt0IC0gMV0gKyBzb3VyY2VbdF0gLSAxMjg7XG4gICAgICAgIHNvdXJjZVt0XSA9IGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVybGVhdmVTY2FsYXIoc291cmNlLCBvdXQpIHtcbiAgICAgIHZhciB0MSA9IDA7XG4gICAgICB2YXIgdDIgPSBNYXRoLmZsb29yKChzb3VyY2UubGVuZ3RoICsgMSkgLyAyKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBzdG9wID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QxKytdO1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QyKytdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVSdW5MZW5ndGgoc291cmNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIG91dCA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBEYXRhVmlldyhzb3VyY2UpO1xuICAgICAgd2hpbGUgKHNpemUgPiAwKSB7XG4gICAgICAgIHZhciBsID0gcmVhZGVyLmdldEludDgocCsrKTtcbiAgICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gLWw7XG4gICAgICAgICAgc2l6ZSAtPSBjb3VudCArIDE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaChyZWFkZXIuZ2V0VWludDgocCsrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb3VudCA9IGw7XG4gICAgICAgICAgc2l6ZSAtPSAyO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRlci5nZXRVaW50OChwKyspO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvc3N5RGN0RGVjb2RlKGNzY1NldCwgcm93UHRycywgY2hhbm5lbERhdGEsIGFjQnVmZmVyLCBkY0J1ZmZlciwgb3V0QnVmZmVyKSB7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICB2YXIgd2lkdGggPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS5oZWlnaHQ7XG4gICAgICB2YXIgbnVtQ29tcCA9IDM7XG4gICAgICB2YXIgbnVtRnVsbEJsb2Nrc1ggPSBNYXRoLmZsb29yKHdpZHRoIC8gOCk7XG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IE1hdGguY2VpbCh3aWR0aCAvIDgpO1xuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gOCk7XG4gICAgICB2YXIgbGVmdG92ZXJYID0gd2lkdGggLSAobnVtQmxvY2tzWCAtIDEpICogODtcbiAgICAgIHZhciBsZWZ0b3ZlclkgPSBoZWlnaHQgLSAobnVtQmxvY2tzWSAtIDEpICogODtcbiAgICAgIHZhciBjdXJyQWNDb21wID0geyB2YWx1ZTogMCB9O1xuICAgICAgdmFyIGN1cnJEY0NvbXAgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgZGN0RGF0YSA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciBoYWxmWmlnQmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93QmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93T2Zmc2V0cyA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgIHJvd09mZnNldHNbY29tcDJdID0gcm93UHRyc1tjc2NTZXQuaWR4W2NvbXAyXV07XG4gICAgICAgIGN1cnJEY0NvbXBbY29tcDJdID0gY29tcDIgPCAxID8gMCA6IGN1cnJEY0NvbXBbY29tcDIgLSAxXSArIG51bUJsb2Nrc1ggKiBudW1CbG9ja3NZO1xuICAgICAgICBkY3REYXRhW2NvbXAyXSA9IG5ldyBGbG9hdDMyQXJyYXkoNjQpO1xuICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KDY0KTtcbiAgICAgICAgcm93QmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KG51bUJsb2Nrc1ggKiA2NCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBibG9ja3kgPSAwOyBibG9ja3kgPCBudW1CbG9ja3NZOyArK2Jsb2NreSkge1xuICAgICAgICB2YXIgbWF4WSA9IDg7XG4gICAgICAgIGlmIChibG9ja3kgPT0gbnVtQmxvY2tzWSAtIDEpXG4gICAgICAgICAgbWF4WSA9IGxlZnRvdmVyWTtcbiAgICAgICAgdmFyIG1heFggPSA4O1xuICAgICAgICBmb3IgKGxldCBibG9ja3ggPSAwOyBibG9ja3ggPCBudW1CbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgIGlmIChibG9ja3ggPT0gbnVtQmxvY2tzWCAtIDEpXG4gICAgICAgICAgICBtYXhYID0gbGVmdG92ZXJYO1xuICAgICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdLmZpbGwoMCk7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdWzBdID0gZGNCdWZmZXJbY3VyckRjQ29tcFtjb21wMl0rK107XG4gICAgICAgICAgICB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2tbY29tcDJdKTtcbiAgICAgICAgICAgIHVuWmlnWmFnKGhhbGZaaWdCbG9ja1tjb21wMl0sIGRjdERhdGFbY29tcDJdKTtcbiAgICAgICAgICAgIGRjdEludmVyc2UoZGN0RGF0YVtjb21wMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICBjc2M3MDlJbnZlcnNlKGRjdERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgICAgY29udmVydFRvSGFsZihkY3REYXRhW2NvbXAyXSwgcm93QmxvY2tbY29tcDJdLCBibG9ja3ggKiA2NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQyID0gMDtcbiAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICBjb25zdCB0eXBlMiA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcDJdXS50eXBlO1xuICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcDJdW3kyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUZ1bGxCbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBibG9ja3ggKiA2NCArICh5MiAmIDcpICogODtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAwICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMF0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDEgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAxXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAzICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgM10sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDQgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA0XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNSAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA2ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNl0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDcgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA3XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9mZnNldDIgKz0gOCAqIElOVDE2X1NJWkUgKiB0eXBlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bUZ1bGxCbG9ja3NYICE9IG51bUJsb2Nrc1gpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgICBjb25zdCBvZmZzZXQzID0gcm93T2Zmc2V0c1tjb21wMl1beTJdICsgOCAqIG51bUZ1bGxCbG9ja3NYICogSU5UMTZfU0laRSAqIHR5cGUyO1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBudW1GdWxsQmxvY2tzWCAqIDY0ICsgKHkyICYgNykgKiA4O1xuICAgICAgICAgICAgICBmb3IgKGxldCB4MiA9IDA7IHgyIDwgbWF4WDsgKyt4Mikge1xuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQzICsgeDIgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyB4Ml0sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaGFsZlJvdyA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCk7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICBmb3IgKHZhciBjb21wID0gMDsgY29tcCA8IG51bUNvbXA7ICsrY29tcCkge1xuICAgICAgICBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS5kZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS50eXBlO1xuICAgICAgICBpZiAoY2hhbm5lbERhdGFbY29tcF0udHlwZSAhPSAyKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcF1beV07XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBoYWxmUm93W3hdID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldDIgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEZsb2F0MzIob2Zmc2V0MiArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgZGVjb2RlRmxvYXQxNihoYWxmUm93W3hdKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9jaykge1xuICAgICAgdmFyIGFjVmFsdWU7XG4gICAgICB2YXIgZGN0Q29tcCA9IDE7XG4gICAgICB3aGlsZSAoZGN0Q29tcCA8IDY0KSB7XG4gICAgICAgIGFjVmFsdWUgPSBhY0J1ZmZlcltjdXJyQWNDb21wLnZhbHVlXTtcbiAgICAgICAgaWYgKGFjVmFsdWUgPT0gNjUyODApIHtcbiAgICAgICAgICBkY3RDb21wID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWNWYWx1ZSA+PiA4ID09IDI1NSkge1xuICAgICAgICAgIGRjdENvbXAgKz0gYWNWYWx1ZSAmIDI1NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYWxmWmlnQmxvY2tbZGN0Q29tcF0gPSBhY1ZhbHVlO1xuICAgICAgICAgIGRjdENvbXArKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyQWNDb21wLnZhbHVlKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuWmlnWmFnKHNyYywgZHN0KSB7XG4gICAgICBkc3RbMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1swXSk7XG4gICAgICBkc3RbMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxXSk7XG4gICAgICBkc3RbMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1XSk7XG4gICAgICBkc3RbM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2XSk7XG4gICAgICBkc3RbNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNF0pO1xuICAgICAgZHN0WzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTVdKTtcbiAgICAgIGRzdFs2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI3XSk7XG4gICAgICBkc3RbN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syOF0pO1xuICAgICAgZHN0WzhdID0gZGVjb2RlRmxvYXQxNihzcmNbMl0pO1xuICAgICAgZHN0WzldID0gZGVjb2RlRmxvYXQxNihzcmNbNF0pO1xuICAgICAgZHN0WzEwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzddKTtcbiAgICAgIGRzdFsxMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxM10pO1xuICAgICAgZHN0WzEyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE2XSk7XG4gICAgICBkc3RbMTNdID0gZGVjb2RlRmxvYXQxNihzcmNbMjZdKTtcbiAgICAgIGRzdFsxNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syOV0pO1xuICAgICAgZHN0WzE1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQyXSk7XG4gICAgICBkc3RbMTZdID0gZGVjb2RlRmxvYXQxNihzcmNbM10pO1xuICAgICAgZHN0WzE3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzhdKTtcbiAgICAgIGRzdFsxOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMl0pO1xuICAgICAgZHN0WzE5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE3XSk7XG4gICAgICBkc3RbMjBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjVdKTtcbiAgICAgIGRzdFsyMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMF0pO1xuICAgICAgZHN0WzIyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQxXSk7XG4gICAgICBkc3RbMjNdID0gZGVjb2RlRmxvYXQxNihzcmNbNDNdKTtcbiAgICAgIGRzdFsyNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s5XSk7XG4gICAgICBkc3RbMjVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTFdKTtcbiAgICAgIGRzdFsyNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxOF0pO1xuICAgICAgZHN0WzI3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI0XSk7XG4gICAgICBkc3RbMjhdID0gZGVjb2RlRmxvYXQxNihzcmNbMzFdKTtcbiAgICAgIGRzdFsyOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0MF0pO1xuICAgICAgZHN0WzMwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ0XSk7XG4gICAgICBkc3RbMzFdID0gZGVjb2RlRmxvYXQxNihzcmNbNTNdKTtcbiAgICAgIGRzdFszMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMF0pO1xuICAgICAgZHN0WzMzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE5XSk7XG4gICAgICBkc3RbMzRdID0gZGVjb2RlRmxvYXQxNihzcmNbMjNdKTtcbiAgICAgIGRzdFszNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMl0pO1xuICAgICAgZHN0WzM2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM5XSk7XG4gICAgICBkc3RbMzddID0gZGVjb2RlRmxvYXQxNihzcmNbNDVdKTtcbiAgICAgIGRzdFszOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Ml0pO1xuICAgICAgZHN0WzM5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU0XSk7XG4gICAgICBkc3RbNDBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjBdKTtcbiAgICAgIGRzdFs0MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMl0pO1xuICAgICAgZHN0WzQyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzMzXSk7XG4gICAgICBkc3RbNDNdID0gZGVjb2RlRmxvYXQxNihzcmNbMzhdKTtcbiAgICAgIGRzdFs0NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Nl0pO1xuICAgICAgZHN0WzQ1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzUxXSk7XG4gICAgICBkc3RbNDZdID0gZGVjb2RlRmxvYXQxNihzcmNbNTVdKTtcbiAgICAgIGRzdFs0N10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MF0pO1xuICAgICAgZHN0WzQ4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzIxXSk7XG4gICAgICBkc3RbNDldID0gZGVjb2RlRmxvYXQxNihzcmNbMzRdKTtcbiAgICAgIGRzdFs1MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1szN10pO1xuICAgICAgZHN0WzUxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ3XSk7XG4gICAgICBkc3RbNTJdID0gZGVjb2RlRmxvYXQxNihzcmNbNTBdKTtcbiAgICAgIGRzdFs1M10gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Nl0pO1xuICAgICAgZHN0WzU0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU5XSk7XG4gICAgICBkc3RbNTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNjFdKTtcbiAgICAgIGRzdFs1Nl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szNV0pO1xuICAgICAgZHN0WzU3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM2XSk7XG4gICAgICBkc3RbNThdID0gZGVjb2RlRmxvYXQxNihzcmNbNDhdKTtcbiAgICAgIGRzdFs1OV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0OV0pO1xuICAgICAgZHN0WzYwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU3XSk7XG4gICAgICBkc3RbNjFdID0gZGVjb2RlRmxvYXQxNihzcmNbNThdKTtcbiAgICAgIGRzdFs2Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1s2Ml0pO1xuICAgICAgZHN0WzYzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYzXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRjdEludmVyc2UoZGF0YSkge1xuICAgICAgY29uc3QgYSA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA0KTtcbiAgICAgIGNvbnN0IGIgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgYyA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA4KTtcbiAgICAgIGNvbnN0IGQgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGUgPSAwLjUgKiBNYXRoLmNvcyg1ICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGYgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDgpO1xuICAgICAgY29uc3QgZyA9IDAuNSAqIE1hdGguY29zKDcgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgdmFyIGFscGhhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIGJldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgdGhldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgZ2FtbWEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyArK3Jvdykge1xuICAgICAgICB2YXIgcm93UHRyID0gcm93ICogODtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMl0gPSBjICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhW3Jvd1B0ciArIDFdICsgZCAqIGRhdGFbcm93UHRyICsgM10gKyBlICogZGF0YVtyb3dQdHIgKyA1XSArIGcgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzFdID0gZCAqIGRhdGFbcm93UHRyICsgMV0gLSBnICogZGF0YVtyb3dQdHIgKyAzXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDVdIC0gZSAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVtyb3dQdHIgKyAxXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDNdICsgZyAqIGRhdGFbcm93UHRyICsgNV0gKyBkICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZSAqIGRhdGFbcm93UHRyICsgM10gKyBkICogZGF0YVtyb3dQdHIgKyA1XSAtIGIgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSArIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSAtIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVsxXSA9IGFscGhhWzBdICsgYWxwaGFbM107XG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXTtcbiAgICAgICAgZ2FtbWFbMF0gPSB0aGV0YVswXSArIHRoZXRhWzFdO1xuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzJdID0gdGhldGFbM10gLSB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbM10gPSB0aGV0YVswXSAtIHRoZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDBdID0gZ2FtbWFbMF0gKyBiZXRhWzBdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDFdID0gZ2FtbWFbMV0gKyBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDJdID0gZ2FtbWFbMl0gKyBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDNdID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDRdID0gZ2FtbWFbM10gLSBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDVdID0gZ2FtbWFbMl0gLSBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDZdID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDddID0gZ2FtbWFbMF0gLSBiZXRhWzBdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgODsgKytjb2x1bW4pIHtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVsxNiArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbMTYgKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhWzQ4ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVs0OCArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMF0gPSBiICogZGF0YVs4ICsgY29sdW1uXSArIGQgKiBkYXRhWzI0ICsgY29sdW1uXSArIGUgKiBkYXRhWzQwICsgY29sdW1uXSArIGcgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhWzggKyBjb2x1bW5dIC0gZyAqIGRhdGFbMjQgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gZSAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbOCArIGNvbHVtbl0gLSBiICogZGF0YVsyNCArIGNvbHVtbl0gKyBnICogZGF0YVs0MCArIGNvbHVtbl0gKyBkICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbM10gPSBnICogZGF0YVs4ICsgY29sdW1uXSAtIGUgKiBkYXRhWzI0ICsgY29sdW1uXSArIGQgKiBkYXRhWzQwICsgY29sdW1uXSAtIGIgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbY29sdW1uXSArIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbM10gPSBhICogKGRhdGFbY29sdW1uXSAtIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdO1xuICAgICAgICB0aGV0YVsyXSA9IGFscGhhWzFdIC0gYWxwaGFbMl07XG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXTtcbiAgICAgICAgZ2FtbWFbMV0gPSB0aGV0YVszXSArIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVsyXSA9IHRoZXRhWzNdIC0gdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXTtcbiAgICAgICAgZGF0YVswICsgY29sdW1uXSA9IGdhbW1hWzBdICsgYmV0YVswXTtcbiAgICAgICAgZGF0YVs4ICsgY29sdW1uXSA9IGdhbW1hWzFdICsgYmV0YVsxXTtcbiAgICAgICAgZGF0YVsxNiArIGNvbHVtbl0gPSBnYW1tYVsyXSArIGJldGFbMl07XG4gICAgICAgIGRhdGFbMjQgKyBjb2x1bW5dID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhWzMyICsgY29sdW1uXSA9IGdhbW1hWzNdIC0gYmV0YVszXTtcbiAgICAgICAgZGF0YVs0MCArIGNvbHVtbl0gPSBnYW1tYVsyXSAtIGJldGFbMl07XG4gICAgICAgIGRhdGFbNDggKyBjb2x1bW5dID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhWzU2ICsgY29sdW1uXSA9IGdhbW1hWzBdIC0gYmV0YVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3NjNzA5SW52ZXJzZShkYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSBkYXRhWzBdW2ldO1xuICAgICAgICB2YXIgY2IgPSBkYXRhWzFdW2ldO1xuICAgICAgICB2YXIgY3IgPSBkYXRhWzJdW2ldO1xuICAgICAgICBkYXRhWzBdW2ldID0geSArIDEuNTc0NyAqIGNyO1xuICAgICAgICBkYXRhWzFdW2ldID0geSAtIDAuMTg3MyAqIGNiIC0gMC40NjgyICogY3I7XG4gICAgICAgIGRhdGFbMl1baV0gPSB5ICsgMS44NTU2ICogY2I7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0hhbGYoc3JjLCBkc3QsIGlkeCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIGRzdFtpZHggKyBpXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdCh0b0xpbmVhcihzcmNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9MaW5lYXIoZmxvYXQpIHtcbiAgICAgIGlmIChmbG9hdCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3coTWF0aC5hYnMoZmxvYXQpLCAyLjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhsb2dCYXNlLCBNYXRoLmFicyhmbG9hdCkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JBVyhpbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGluZm8uYXJyYXkuYnVmZmVyLCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5zaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JMRShpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8udmlld2VyLmJ1ZmZlci5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRlY29kZVJ1bkxlbmd0aChjb21wcmVzc2VkKSk7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyLmxlbmd0aCk7XG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1pJUChpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgICAgcHJlZGljdG9yKHJhd0J1ZmZlcik7XG4gICAgICBpbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQSVooaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlcjtcbiAgICAgIHZhciBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGluZm8ud2lkdGggKiBpbmZvLnNjYW5saW5lQmxvY2tTaXplICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUpKTtcbiAgICAgIHZhciBiaXRtYXAgPSBuZXcgVWludDhBcnJheShCSVRNQVBfU0laRSk7XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kID0gMDtcbiAgICAgIHZhciBwaXpDaGFubmVsRGF0YSA9IG5ldyBBcnJheShpbmZvLmNoYW5uZWxzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgaSsrKSB7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldID0ge307XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic3RhcnRcIl0gPSBvdXRCdWZmZXJFbmQ7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wiZW5kXCJdID0gcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueFwiXSA9IGluZm8ud2lkdGg7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wibnlcIl0gPSBpbmZvLmxpbmVzO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcInNpemVcIl0gPSBpbmZvLnR5cGU7XG4gICAgICAgIG91dEJ1ZmZlckVuZCArPSBwaXpDaGFubmVsRGF0YVtpXS5ueCAqIHBpekNoYW5uZWxEYXRhW2ldLm55ICogcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5Ob25aZXJvID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgdmFyIG1heE5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpZiAobWF4Tm9uWmVybyA+PSBCSVRNQVBfU0laRSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIFBJWl9DT01QUkVTU0lPTiBCSVRNQVBfU0laRVwiO1xuICAgICAgfVxuICAgICAgaWYgKG1pbk5vblplcm8gPD0gbWF4Tm9uWmVybykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE5vblplcm8gLSBtaW5Ob25aZXJvICsgMTsgaSsrKSB7XG4gICAgICAgICAgYml0bWFwW2kgKyBtaW5Ob25aZXJvXSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbHV0ID0gbmV3IFVpbnQxNkFycmF5KFVTSE9SVF9SQU5HRSk7XG4gICAgICB2YXIgbWF4VmFsdWUgPSByZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaHVmVW5jb21wcmVzcyhpbmZvLmFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbGVuZ3RoLCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwaXpDaGFubmVsRGF0YVtpXS5zaXplOyArK2opIHtcbiAgICAgICAgICB3YXYyRGVjb2RlKG91dEJ1ZmZlciwgY2Quc3RhcnQgKyBqLCBjZC5ueCwgY2Quc2l6ZSwgY2QubnksIGNkLm54ICogY2Quc2l6ZSwgbWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseUx1dChsdXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kKTtcbiAgICAgIHZhciB0bXBPZmZzZXQyID0gMDtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtjXTtcbiAgICAgICAgICB2YXIgbiA9IGNkLm54ICogY2Quc2l6ZTtcbiAgICAgICAgICB2YXIgY3AgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLCBjZC5lbmQgKiBJTlQxNl9TSVpFLCBuICogSU5UMTZfU0laRSk7XG4gICAgICAgICAgdG1wQnVmZmVyLnNldChjcCwgdG1wT2Zmc2V0Mik7XG4gICAgICAgICAgdG1wT2Zmc2V0MiArPSBuICogSU5UMTZfU0laRTtcbiAgICAgICAgICBjZC5lbmQgKz0gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1BYUihpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgY29uc3Qgc3ogPSBpbmZvLmxpbmVzICogaW5mby5jaGFubmVscyAqIGluZm8ud2lkdGg7XG4gICAgICBjb25zdCB0bXBCdWZmZXIgPSBpbmZvLnR5cGUgPT0gMSA/IG5ldyBVaW50MTZBcnJheShzeikgOiBuZXcgVWludDMyQXJyYXkoc3opO1xuICAgICAgbGV0IHRtcEJ1ZmZlckVuZCA9IDA7XG4gICAgICBsZXQgd3JpdGVQdHIgPSAwO1xuICAgICAgY29uc3QgcHRyID0gbmV3IEFycmF5KDQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICBsZXQgcGl4ZWwgPSAwO1xuICAgICAgICAgIHN3aXRjaCAoaW5mby50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHB0clswXSA9IHRtcEJ1ZmZlckVuZDtcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzFdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLndpZHRoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gcmF3QnVmZmVyW3B0clswXSsrXSA8PCA4IHwgcmF3QnVmZmVyW3B0clsxXSsrXTtcbiAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICB3cml0ZVB0cisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHB0clsyXSA9IHB0clsxXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsyXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgMjQgfCByYXdCdWZmZXJbcHRyWzFdKytdIDw8IDE2IHwgcmF3QnVmZmVyW3B0clsyXSsrXSA8PCA4O1xuICAgICAgICAgICAgICAgIHBpeGVsICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzRFdBKGluZm8pIHtcbiAgICAgIHZhciBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG4gICAgICB2YXIgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluZm8ud2lkdGggKiBpbmZvLmxpbmVzICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFKSk7XG4gICAgICB2YXIgZHdhSGVhZGVyID0ge1xuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdW5rbm93blVuY29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgZGNDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZUNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZVJhd1NpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbEFjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbERjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuICAgICAgfTtcbiAgICAgIGlmIChkd2FIZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyLmNvbXByZXNzaW9uICsgXCIgdmVyc2lvbiBcIiArIGR3YUhlYWRlci52ZXJzaW9uICsgXCIgaXMgdW5zdXBwb3J0ZWRcIjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVsUnVsZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBydWxlU2l6ZSA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KSAtIElOVDE2X1NJWkU7XG4gICAgICB3aGlsZSAocnVsZVNpemUgPiAwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhpbkRhdGFWaWV3LmJ1ZmZlciwgaW5PZmZzZXQpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gdmFsdWUgPj4gMiAmIDM7XG4gICAgICAgIHZhciBjc2MgPSAodmFsdWUgPj4gNCkgLSAxO1xuICAgICAgICB2YXIgaW5kZXggPSBuZXcgSW50OEFycmF5KFtjc2NdKVswXTtcbiAgICAgICAgdmFyIHR5cGUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgY2hhbm5lbFJ1bGVzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjb21wcmVzc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgcnVsZVNpemUgLT0gbmFtZS5sZW5ndGggKyAzO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxzID0gRVhSSGVhZGVyLmNoYW5uZWxzO1xuICAgICAgdmFyIGNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgY2QubmFtZSA9IGNoYW5uZWwubmFtZTtcbiAgICAgICAgY2QuY29tcHJlc3Npb24gPSBVTktOT1dOO1xuICAgICAgICBjZC5kZWNvZGVkID0gZmFsc2U7XG4gICAgICAgIGNkLnR5cGUgPSBjaGFubmVsLnBpeGVsVHlwZTtcbiAgICAgICAgY2QucExpbmVhciA9IGNoYW5uZWwucExpbmVhcjtcbiAgICAgICAgY2Qud2lkdGggPSBpbmZvLndpZHRoO1xuICAgICAgICBjZC5oZWlnaHQgPSBpbmZvLmxpbmVzO1xuICAgICAgfVxuICAgICAgdmFyIGNzY1NldCA9IHtcbiAgICAgICAgaWR4OiBuZXcgQXJyYXkoMylcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBvZmZzZXQyID0gMDsgb2Zmc2V0MiA8IGluZm8uY2hhbm5lbHM7ICsrb2Zmc2V0Mikge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtvZmZzZXQyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsUnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IGNoYW5uZWxSdWxlc1tpXTtcbiAgICAgICAgICBpZiAoY2QubmFtZSA9PSBydWxlLm5hbWUpIHtcbiAgICAgICAgICAgIGNkLmNvbXByZXNzaW9uID0gcnVsZS5jb21wcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChydWxlLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgY3NjU2V0LmlkeFtydWxlLmluZGV4XSA9IG9mZnNldDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZC5vZmZzZXQgPSBvZmZzZXQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplID4gMCkge1xuICAgICAgICBzd2l0Y2ggKGR3YUhlYWRlci5hY0NvbXByZXNzaW9uKSB7XG4gICAgICAgICAgY2FzZSBTVEFUSUNfSFVGRk1BTjpcbiAgICAgICAgICAgIHZhciBhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KTtcbiAgICAgICAgICAgIGh1ZlVuY29tcHJlc3MoXG4gICAgICAgICAgICAgIGluZm8uYXJyYXksXG4gICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICBkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSxcbiAgICAgICAgICAgICAgYWNCdWZmZXIsXG4gICAgICAgICAgICAgIGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERFRkxBVEU6XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5PZmZzZXQudmFsdWUsIGluT2Zmc2V0LnZhbHVlICsgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZGF0YS5idWZmZXIpO1xuICAgICAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHZhciB6bGliSW5mbyA9IHtcbiAgICAgICAgICBhcnJheTogaW5mby5hcnJheSxcbiAgICAgICAgICBvZmZzZXQ6IGluT2Zmc2V0LFxuICAgICAgICAgIHNpemU6IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheSh1bmNvbXByZXNzWklQKHpsaWJJbmZvKS5idWZmZXIpO1xuICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIucmxlUmF3U2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgICAgdmFyIHJsZUJ1ZmZlciA9IGRlY29kZVJ1bkxlbmd0aChkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwO1xuICAgICAgdmFyIHJvd09mZnNldHMgPSBuZXcgQXJyYXkoY2hhbm5lbERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93T2Zmc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICByb3dPZmZzZXRzW2ldID0gbmV3IEFycmF5KCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICBmb3IgKHZhciBjaGFuID0gMDsgY2hhbiA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytjaGFuKSB7XG4gICAgICAgICAgcm93T2Zmc2V0c1tjaGFuXS5wdXNoKG91dEJ1ZmZlckVuZCk7XG4gICAgICAgICAgb3V0QnVmZmVyRW5kICs9IGNoYW5uZWxEYXRhW2NoYW5dLndpZHRoICogaW5mby50eXBlICogSU5UMTZfU0laRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dPZmZzZXRzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtpXTtcbiAgICAgICAgaWYgKGNkLmRlY29kZWQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN3aXRjaCAoY2QuY29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFJMRTpcbiAgICAgICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICAgICAgdmFyIHJsZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICAgICAgICB2YXIgcm93T2Zmc2V0Qnl0ZXMgPSByb3dPZmZzZXRzW2ldW3Jvd107XG4gICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2Qud2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ5dGUgPSAwOyBieXRlIDwgSU5UMTZfU0laRSAqIGNkLnR5cGU7ICsrYnl0ZSkge1xuICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyW3Jvd09mZnNldEJ5dGVzKytdID0gcmxlQnVmZmVyW3JsZU9mZnNldCArIGJ5dGUgKiBjZC53aWR0aCAqIGNkLmhlaWdodF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJsZU9mZnNldCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBMT1NTWV9EQ1Q6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBjaGFubmVsIGNvbXByZXNzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgdmFyIHVpbnRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIyKTtcbiAgICAgIHZhciBlbmRPZmZzZXQgPSAwO1xuICAgICAgd2hpbGUgKHVpbnRCdWZmZXJbb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldF0gIT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50QnVmZmVyLnNsaWNlKG9mZnNldDIudmFsdWUsIG9mZnNldDIudmFsdWUgKyBlbmRPZmZzZXQpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0ICsgMTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGaXhlZExlbmd0aFN0cmluZyhidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMikuc2xpY2Uob2Zmc2V0Mi52YWx1ZSwgb2Zmc2V0Mi52YWx1ZSArIHNpemUpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgc2l6ZTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBJbnQzMiA9IGRhdGFWaWV3LmdldEludDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQzMl9TSVpFO1xuICAgICAgcmV0dXJuIEludDMyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQzMiA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UMzJfU0laRTtcbiAgICAgIHJldHVybiBVaW50MzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5Miwgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gdUludDhBcnJheTJbb2Zmc2V0Mi52YWx1ZV07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0Mi52YWx1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VJbnQ2NCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICBsZXQgaW50O1xuICAgICAgaWYgKFwiZ2V0QmlnSW50NjRcIiBpbiBEYXRhVmlldy5wcm90b3R5cGUpIHtcbiAgICAgICAgaW50ID0gTnVtYmVyKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldDIudmFsdWUsIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludCA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlICsgNCwgdHJ1ZSkgKyBOdW1iZXIoZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUsIHRydWUpIDw8IDMyKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gVUxPTkdfU0laRTtcbiAgICAgIHJldHVybiBpbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBmbG9hdCA9IGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IEZMT0FUMzJfU0laRTtcbiAgICAgIHJldHVybiBmbG9hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgcmV0dXJuIERhdGFVdGlscy50b0hhbGZGbG9hdChwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQxNihiaW5hcnkpIHtcbiAgICAgIHZhciBleHBvbmVudCA9IChiaW5hcnkgJiAzMTc0NCkgPj4gMTAsIGZyYWN0aW9uID0gYmluYXJ5ICYgMTAyMztcbiAgICAgIHJldHVybiAoYmluYXJ5ID4+IDE1ID8gLTEgOiAxKSAqIChleHBvbmVudCA/IGV4cG9uZW50ID09PSAzMSA/IGZyYWN0aW9uID8gTmFOIDogSW5maW5pdHkgOiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1KSAqICgxICsgZnJhY3Rpb24gLyAxMDI0KSA6IDYxMDM1MTU2MjVlLTE0ICogKGZyYWN0aW9uIC8gMTAyNCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQxNihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQxNiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgKz0gSU5UMTZfU0laRTtcbiAgICAgIHJldHVybiBVaW50MTY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXQxNihidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICByZXR1cm4gZGVjb2RlRmxvYXQxNihwYXJzZVVpbnQxNihidWZmZXIyLCBvZmZzZXQyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQyLnZhbHVlO1xuICAgICAgdmFyIGNoYW5uZWxzID0gW107XG4gICAgICB3aGlsZSAob2Zmc2V0Mi52YWx1ZSA8IHN0YXJ0T2Zmc2V0ICsgc2l6ZSAtIDEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICB2YXIgcGl4ZWxUeXBlID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIHZhciBwTGluZWFyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gMztcbiAgICAgICAgdmFyIHhTYW1wbGluZyA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICB2YXIgeVNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIGNoYW5uZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGl4ZWxUeXBlLFxuICAgICAgICAgIHBMaW5lYXIsXG4gICAgICAgICAgeFNhbXBsaW5nLFxuICAgICAgICAgIHlTYW1wbGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gMTtcbiAgICAgIHJldHVybiBjaGFubmVscztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHJlZFggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHJlZFkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGdyZWVuWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgZ3JlZW5ZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBibHVlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgYmx1ZVkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHdoaXRlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgd2hpdGVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZFgsXG4gICAgICAgIHJlZFksXG4gICAgICAgIGdyZWVuWCxcbiAgICAgICAgZ3JlZW5ZLFxuICAgICAgICBibHVlWCxcbiAgICAgICAgYmx1ZVksXG4gICAgICAgIHdoaXRlWCxcbiAgICAgICAgd2hpdGVZXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgY29tcHJlc3Npb25Db2RlcyA9IFtcbiAgICAgICAgXCJOT19DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlJMRV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlpJUFNfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJaSVBfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQSVpfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQWFIyNF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NEFfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJEV0FBX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiRFdBQl9DT01QUkVTU0lPTlwiXG4gICAgICBdO1xuICAgICAgdmFyIGNvbXByZXNzaW9uID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gY29tcHJlc3Npb25Db2Rlc1tjb21wcmVzc2lvbl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4TWluID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHlNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeE1heCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5TWF4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIHsgeE1pbiwgeU1pbiwgeE1heCwgeU1heCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGxpbmVPcmRlcnMgPSBbXCJJTkNSRUFTSU5HX1lcIl07XG4gICAgICB2YXIgbGluZU9yZGVyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gbGluZU9yZGVyc1tsaW5lT3JkZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB6ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHR5cGUsIHNpemUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3RyaW5ndmVjdG9yXCIgfHwgdHlwZSA9PT0gXCJpY2NQcm9maWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2hsaXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaHJvbWF0aWNpdGllc1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNocm9tYXRpY2l0aWVzKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21wcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib3gyaVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lT3JkZXJcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VMaW5lT3JkZXIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImZsb2F0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidjJmXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2M2ZcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYXRpb25hbFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0aW1lY29kZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJwcmV2aWV3XCIpIHtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBzaXplO1xuICAgICAgICByZXR1cm4gXCJza2lwcGVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IHNpemU7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICBjb25zdCBFWFJIZWFkZXIyID0ge307XG4gICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKDAsIHRydWUpICE9IDIwMDAwNjMwKSB7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGluIE9wZW5FWFIgZm9ybWF0LlwiO1xuICAgICAgfVxuICAgICAgRVhSSGVhZGVyMi52ZXJzaW9uID0gZGF0YVZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBjb25zdCBzcGVjID0gZGF0YVZpZXcuZ2V0VWludDgoNSk7XG4gICAgICBFWFJIZWFkZXIyLnNwZWMgPSB7XG4gICAgICAgIHNpbmdsZVRpbGU6ICEhKHNwZWMgJiAyKSxcbiAgICAgICAgbG9uZ05hbWU6ICEhKHNwZWMgJiA0KSxcbiAgICAgICAgZGVlcEZvcm1hdDogISEoc3BlYyAmIDgpLFxuICAgICAgICBtdWx0aVBhcnQ6ICEhKHNwZWMgJiAxNilcbiAgICAgIH07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gODtcbiAgICAgIHZhciBrZWVwUmVhZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoa2VlcFJlYWRpbmcpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSAwKSB7XG4gICAgICAgICAga2VlcFJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVNpemUgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0MiwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlU2l6ZSk7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRVhSTG9hZGVyLnBhcnNlOiBza2lwcGVkIHVua25vd24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlICcke2F0dHJpYnV0ZVR5cGV9Jy5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRVhSSGVhZGVyMlthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChzcGVjICYgfjQpICE9IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVYUkhlYWRlcjpcIiwgRVhSSGVhZGVyMik7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFWFJIZWFkZXIyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR1cERlY29kZXIoRVhSSGVhZGVyMiwgZGF0YVZpZXcsIHVJbnQ4QXJyYXkyLCBvZmZzZXQyLCBvdXRwdXRUeXBlKSB7XG4gICAgICBjb25zdCBFWFJEZWNvZGVyMiA9IHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdmlld2VyOiBkYXRhVmlldyxcbiAgICAgICAgYXJyYXk6IHVJbnQ4QXJyYXkyLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldDIsXG4gICAgICAgIHdpZHRoOiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueE1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy54TWluICsgMSxcbiAgICAgICAgaGVpZ2h0OiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWluICsgMSxcbiAgICAgICAgY2hhbm5lbHM6IEVYUkhlYWRlcjIuY2hhbm5lbHMubGVuZ3RoLFxuICAgICAgICBieXRlc1BlckxpbmU6IG51bGwsXG4gICAgICAgIGxpbmVzOiBudWxsLFxuICAgICAgICBpbnB1dFNpemU6IG51bGwsXG4gICAgICAgIHR5cGU6IEVYUkhlYWRlcjIuY2hhbm5lbHNbMF0ucGl4ZWxUeXBlLFxuICAgICAgICB1bmNvbXByZXNzOiBudWxsLFxuICAgICAgICBnZXR0ZXI6IG51bGwsXG4gICAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IG51bGxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKEVYUkhlYWRlcjIuY29tcHJlc3Npb24pIHtcbiAgICAgICAgY2FzZSBcIk5PX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkFXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUkxFX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWklQU19DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpJUF9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQSVpfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDMyO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUElaO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUFhSMjRfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUFhSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFdBQV9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMzI7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEV0FCX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAyNTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyMi5jb21wcmVzc2lvbiArIFwiIGlzIHVuc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5zY2FubGluZUJsb2NrU2l6ZSA9IEVYUkRlY29kZXIyLmxpbmVzO1xuICAgICAgaWYgKEVYUkRlY29kZXIyLnR5cGUgPT0gMSkge1xuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlRmxvYXQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZVVpbnQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChFWFJEZWNvZGVyMi50eXBlID09IDIpIHtcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZUZsb2F0MzI7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBkZWNvZGVGbG9hdDMyO1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgcGl4ZWxUeXBlIFwiICsgRVhSRGVjb2RlcjIudHlwZSArIFwiIGZvciBcIiArIEVYUkhlYWRlcjIuY29tcHJlc3Npb24gKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJsb2NrQ291bnQgPSAoRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNYXggKyAxKSAvIEVYUkRlY29kZXIyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFWFJEZWNvZGVyMi5ibG9ja0NvdW50OyBpKyspXG4gICAgICAgIHBhcnNlSW50NjQoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPSBFWFJEZWNvZGVyMi5jaGFubmVscyA9PSAzID8gNCA6IEVYUkRlY29kZXIyLmNoYW5uZWxzO1xuICAgICAgY29uc3Qgc2l6ZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaGVpZ2h0ICogRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHM7XG4gICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgICBpZiAoRVhSRGVjb2RlcjIuY2hhbm5lbHMgPCBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheS5maWxsKDEsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICAgICAgICAgIGlmIChFWFJEZWNvZGVyMi5jaGFubmVscyA8IEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5LmZpbGwoMTUzNjAsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5FWFJMb2FkZXI6IHVuc3VwcG9ydGVkIHR5cGU6IFwiLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJ5dGVzUGVyTGluZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaW5wdXRTaXplICogRVhSRGVjb2RlcjIuY2hhbm5lbHM7XG4gICAgICBpZiAoRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPT0gNClcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUkdCQUZvcm1hdDtcbiAgICAgIGVsc2VcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUmVkRm9ybWF0O1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIEVYUkRlY29kZXIyLmNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG4gICAgICBlbHNlXG4gICAgICAgIEVYUkRlY29kZXIyLmVuY29kaW5nID0gM2UzO1xuICAgICAgcmV0dXJuIEVYUkRlY29kZXIyO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGNvbnN0IHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBFWFJIZWFkZXIgPSBwYXJzZUhlYWRlcihidWZmZXJEYXRhVmlldywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIGNvbnN0IEVYUkRlY29kZXIgPSBzZXR1cERlY29kZXIoRVhSSGVhZGVyLCBidWZmZXJEYXRhVmlldywgdUludDhBcnJheSwgb2Zmc2V0LCB0aGlzLnR5cGUpO1xuICAgIGNvbnN0IHRtcE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBjaGFubmVsT2Zmc2V0cyA9IHsgUjogMCwgRzogMSwgQjogMiwgQTogMywgWTogMCB9O1xuICAgIGZvciAobGV0IHNjYW5saW5lQmxvY2tJZHggPSAwOyBzY2FubGluZUJsb2NrSWR4IDwgRVhSRGVjb2Rlci5oZWlnaHQgLyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBzY2FubGluZUJsb2NrSWR4KyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBwYXJzZVVpbnQzMihidWZmZXJEYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgIEVYUkRlY29kZXIuc2l6ZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IGxpbmUgKyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID4gRVhSRGVjb2Rlci5oZWlnaHQgPyBFWFJEZWNvZGVyLmhlaWdodCAtIGxpbmUgOiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gRVhSRGVjb2Rlci5zaXplIDwgRVhSRGVjb2Rlci5saW5lcyAqIEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lO1xuICAgICAgY29uc3Qgdmlld2VyID0gaXNDb21wcmVzc2VkID8gRVhSRGVjb2Rlci51bmNvbXByZXNzKEVYUkRlY29kZXIpIDogdW5jb21wcmVzc1JBVyhFWFJEZWNvZGVyKTtcbiAgICAgIG9mZnNldC52YWx1ZSArPSBFWFJEZWNvZGVyLnNpemU7XG4gICAgICBmb3IgKGxldCBsaW5lX3kgPSAwOyBsaW5lX3kgPCBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBsaW5lX3krKykge1xuICAgICAgICBjb25zdCB0cnVlX3kgPSBsaW5lX3kgKyBzY2FubGluZUJsb2NrSWR4ICogRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgICAgaWYgKHRydWVfeSA+PSBFWFJEZWNvZGVyLmhlaWdodClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yIChsZXQgY2hhbm5lbElEID0gMDsgY2hhbm5lbElEIDwgRVhSRGVjb2Rlci5jaGFubmVsczsgY2hhbm5lbElEKyspIHtcbiAgICAgICAgICBjb25zdCBjT2ZmID0gY2hhbm5lbE9mZnNldHNbRVhSSGVhZGVyLmNoYW5uZWxzW2NoYW5uZWxJRF0ubmFtZV07XG4gICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBFWFJEZWNvZGVyLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHRtcE9mZnNldC52YWx1ZSA9IChsaW5lX3kgKiAoRVhSRGVjb2Rlci5jaGFubmVscyAqIEVYUkRlY29kZXIud2lkdGgpICsgY2hhbm5lbElEICogRVhSRGVjb2Rlci53aWR0aCArIHgpICogRVhSRGVjb2Rlci5pbnB1dFNpemU7XG4gICAgICAgICAgICBjb25zdCBvdXRJbmRleCA9IChFWFJEZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlX3kpICogKEVYUkRlY29kZXIud2lkdGggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzKSArIHggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzICsgY09mZjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIuYnl0ZUFycmF5W291dEluZGV4XSA9IEVYUkRlY29kZXIuZ2V0dGVyKHZpZXdlciwgdG1wT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogRVhSSGVhZGVyLFxuICAgICAgd2lkdGg6IEVYUkRlY29kZXIud2lkdGgsXG4gICAgICBoZWlnaHQ6IEVYUkRlY29kZXIuaGVpZ2h0LFxuICAgICAgZGF0YTogRVhSRGVjb2Rlci5ieXRlQXJyYXksXG4gICAgICBmb3JtYXQ6IEVYUkRlY29kZXIuZm9ybWF0LFxuICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IEVYUkRlY29kZXJbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH07XG4gIH1cbiAgc2V0RGF0YVR5cGUodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2sodGV4dHVyZSwgdGV4RGF0YSkge1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IHRleERhdGEuZW5jb2Rpbmc7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEVYUkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVYUkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJUZXh0dXJlIiwiRGF0YVRleHR1cmVMb2FkZXIiLCJIYWxmRmxvYXRUeXBlIiwiRmxvYXRUeXBlIiwiUkdCQUZvcm1hdCIsIlJlZEZvcm1hdCIsIkxpbmVhckZpbHRlciIsIkRhdGFVdGlscyIsInVuemxpYlN5bmMiLCJoYXNDb2xvclNwYWNlIiwiRVhSTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwidHlwZSIsInBhcnNlIiwiYnVmZmVyIiwiVVNIT1JUX1JBTkdFIiwiQklUTUFQX1NJWkUiLCJIVUZfRU5DQklUUyIsIkhVRl9ERUNCSVRTIiwiSFVGX0VOQ1NJWkUiLCJIVUZfREVDU0laRSIsIkhVRl9ERUNNQVNLIiwiTkJJVFMiLCJBX09GRlNFVCIsIk1PRF9NQVNLIiwiU0hPUlRfWkVST0NPREVfUlVOIiwiTE9OR19aRVJPQ09ERV9SVU4iLCJTSE9SVEVTVF9MT05HX1JVTiIsIlVMT05HX1NJWkUiLCJGTE9BVDMyX1NJWkUiLCJJTlQzMl9TSVpFIiwiSU5UMTZfU0laRSIsIklOVDhfU0laRSIsIlNUQVRJQ19IVUZGTUFOIiwiREVGTEFURSIsIlVOS05PV04iLCJMT1NTWV9EQ1QiLCJSTEUiLCJsb2dCYXNlIiwiTWF0aCIsInBvdyIsInJldmVyc2VMdXRGcm9tQml0bWFwIiwiYml0bWFwIiwibHV0IiwiayIsImkiLCJuIiwiaHVmQ2xlYXJEZWNUYWJsZSIsImhkZWMiLCJsZW4iLCJsaXQiLCJwIiwiZ2V0Qml0c1JldHVybiIsImwiLCJjIiwibGMiLCJnZXRCaXRzIiwibkJpdHMiLCJ1SW50OEFycmF5MiIsImluT2Zmc2V0IiwicGFyc2VVaW50OEFycmF5IiwiaHVmVGFibGVCdWZmZXIiLCJBcnJheSIsImh1ZkNhbm9uaWNhbENvZGVUYWJsZSIsImhjb2RlIiwibmMiLCJodWZVbnBhY2tFbmNUYWJsZSIsImluRGF0YVZpZXciLCJuaSIsImltIiwiaU0iLCJ2YWx1ZSIsInplcnVuIiwiaHVmTGVuZ3RoIiwiY29kZSIsImh1ZkNvZGUiLCJodWZCdWlsZERlY1RhYmxlIiwiaGRlY29kIiwicGwiLCJwbE9mZnNldCIsImdldENoYXJSZXR1cm4iLCJnZXRDaGFyIiwiZ2V0Q29kZVJldHVybiIsImdldENvZGUiLCJwbyIsInJsYyIsIm91dEJ1ZmZlciIsIm91dEJ1ZmZlck9mZnNldCIsIm91dEJ1ZmZlckVuZE9mZnNldCIsImNzIiwiVWludDhBcnJheSIsInMiLCJVSW50MTYiLCJJbnQxNiIsInJlZiIsIndkZWMxNFJldHVybiIsImEiLCJiIiwid2RlYzE0IiwiaCIsImxzIiwiaHMiLCJoaSIsImFpIiwiYXMiLCJicyIsIndkZWMxNiIsIm0iLCJkIiwiYmIiLCJhYSIsIndhdjJEZWNvZGUiLCJidWZmZXIyIiwiaiIsIm54Iiwib3giLCJueSIsIm95IiwibXgiLCJ3MTQiLCJwMiIsInB5IiwiZXkiLCJveTEiLCJveTIiLCJveDEiLCJveDIiLCJpMDAiLCJpMDEiLCJpMTAiLCJpMTEiLCJweCIsImV4IiwicDAxIiwicDEwIiwicDExIiwiaHVmRGVjb2RlIiwiZW5jb2RpbmdUYWJsZSIsImRlY29kaW5nVGFibGUiLCJubyIsIm91dE9mZnNldCIsImluT2Zmc2V0RW5kIiwidHJ1bmMiLCJpbmRleCIsImh1ZlVuY29tcHJlc3MiLCJuQ29tcHJlc3NlZCIsIm5SYXciLCJpbml0aWFsSW5PZmZzZXQiLCJwYXJzZVVpbnQzMiIsImZyZXEiLCJhcHBseUx1dCIsImRhdGEiLCJuRGF0YSIsInByZWRpY3RvciIsInNvdXJjZSIsInQiLCJsZW5ndGgiLCJpbnRlcmxlYXZlU2NhbGFyIiwib3V0IiwidDEiLCJ0MiIsImZsb29yIiwic3RvcCIsImRlY29kZVJ1bkxlbmd0aCIsInNpemUiLCJieXRlTGVuZ3RoIiwicmVhZGVyIiwiRGF0YVZpZXciLCJnZXRJbnQ4IiwiY291bnQiLCJwdXNoIiwiZ2V0VWludDgiLCJsb3NzeURjdERlY29kZSIsImNzY1NldCIsInJvd1B0cnMiLCJjaGFubmVsRGF0YSIsImFjQnVmZmVyIiwiZGNCdWZmZXIiLCJkYXRhVmlldyIsIndpZHRoIiwiaWR4IiwiaGVpZ2h0IiwibnVtQ29tcCIsIm51bUZ1bGxCbG9ja3NYIiwibnVtQmxvY2tzWCIsImNlaWwiLCJudW1CbG9ja3NZIiwibGVmdG92ZXJYIiwibGVmdG92ZXJZIiwiY3VyckFjQ29tcCIsImN1cnJEY0NvbXAiLCJkY3REYXRhIiwiaGFsZlppZ0Jsb2NrIiwicm93QmxvY2siLCJyb3dPZmZzZXRzIiwiY29tcDIiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImJsb2NreSIsIm1heFkiLCJtYXhYIiwiYmxvY2t4IiwiZmlsbCIsInVuUmxlQUMiLCJ1blppZ1phZyIsImRjdEludmVyc2UiLCJjc2M3MDlJbnZlcnNlIiwiY29udmVydFRvSGFsZiIsIm9mZnNldDIiLCJ0eXBlMiIsInkyIiwic3JjIiwic2V0VWludDE2Iiwib2Zmc2V0MyIsIngyIiwiaGFsZlJvdyIsImNvbXAiLCJkZWNvZGVkIiwieSIsIngiLCJnZXRVaW50MTYiLCJzZXRGbG9hdDMyIiwiZGVjb2RlRmxvYXQxNiIsImFjVmFsdWUiLCJkY3RDb21wIiwiZHN0IiwiY29zIiwiZSIsImYiLCJnIiwiYWxwaGEiLCJiZXRhIiwidGhldGEiLCJnYW1tYSIsInJvdyIsInJvd1B0ciIsImNvbHVtbiIsImNiIiwiY3IiLCJ0b0hhbGZGbG9hdCIsInRvTGluZWFyIiwiZmxvYXQiLCJzaWduIiwiYWJzIiwidW5jb21wcmVzc1JBVyIsImluZm8iLCJhcnJheSIsIm9mZnNldCIsInVuY29tcHJlc3NSTEUiLCJjb21wcmVzc2VkIiwidmlld2VyIiwic2xpY2UiLCJyYXdCdWZmZXIiLCJ0bXBCdWZmZXIiLCJ1bmNvbXByZXNzWklQIiwidW5jb21wcmVzc1BJWiIsInNjYW5saW5lQmxvY2tTaXplIiwiY2hhbm5lbHMiLCJvdXRCdWZmZXJFbmQiLCJwaXpDaGFubmVsRGF0YSIsImxpbmVzIiwibWluTm9uWmVybyIsInBhcnNlVWludDE2IiwibWF4Tm9uWmVybyIsInBhcnNlVWludDgiLCJtYXhWYWx1ZSIsImNkIiwic3RhcnQiLCJ0bXBPZmZzZXQyIiwiY3AiLCJlbmQiLCJzZXQiLCJ1bmNvbXByZXNzUFhSIiwic3oiLCJVaW50MzJBcnJheSIsInRtcEJ1ZmZlckVuZCIsIndyaXRlUHRyIiwicHRyIiwicGl4ZWwiLCJkaWZmIiwidW5jb21wcmVzc0RXQSIsImR3YUhlYWRlciIsInZlcnNpb24iLCJwYXJzZUludDY0IiwidW5rbm93blVuY29tcHJlc3NlZFNpemUiLCJ1bmtub3duQ29tcHJlc3NlZFNpemUiLCJhY0NvbXByZXNzZWRTaXplIiwiZGNDb21wcmVzc2VkU2l6ZSIsInJsZUNvbXByZXNzZWRTaXplIiwicmxlVW5jb21wcmVzc2VkU2l6ZSIsInJsZVJhd1NpemUiLCJ0b3RhbEFjVW5jb21wcmVzc2VkQ291bnQiLCJ0b3RhbERjVW5jb21wcmVzc2VkQ291bnQiLCJhY0NvbXByZXNzaW9uIiwiRVhSSGVhZGVyIiwiY29tcHJlc3Npb24iLCJjaGFubmVsUnVsZXMiLCJydWxlU2l6ZSIsIm5hbWUiLCJwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nIiwiY3NjIiwiSW50OEFycmF5IiwiY2hhbm5lbCIsInBpeGVsVHlwZSIsInBMaW5lYXIiLCJydWxlIiwiemxpYkluZm8iLCJybGVCdWZmZXIiLCJjaGFuIiwicmxlT2Zmc2V0Iiwicm93T2Zmc2V0Qnl0ZXMiLCJieXRlIiwidWludEJ1ZmZlciIsImVuZE9mZnNldCIsInN0cmluZ1ZhbHVlIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJwYXJzZUZpeGVkTGVuZ3RoU3RyaW5nIiwicGFyc2VSYXRpb25hbCIsInBhcnNlSW50MzIiLCJwYXJzZVRpbWVjb2RlIiwiSW50MzIiLCJnZXRJbnQzMiIsIlVpbnQzMiIsImdldFVpbnQzMiIsIlVpbnQ4IiwiaW50IiwicHJvdG90eXBlIiwiTnVtYmVyIiwiZ2V0QmlnSW50NjQiLCJwYXJzZUZsb2F0MzIiLCJnZXRGbG9hdDMyIiwiZGVjb2RlRmxvYXQzMiIsImJpbmFyeSIsImV4cG9uZW50IiwiZnJhY3Rpb24iLCJOYU4iLCJJbmZpbml0eSIsIlVpbnQxNiIsInBhcnNlRmxvYXQxNiIsInBhcnNlQ2hsaXN0Iiwic3RhcnRPZmZzZXQiLCJ4U2FtcGxpbmciLCJ5U2FtcGxpbmciLCJwYXJzZUNocm9tYXRpY2l0aWVzIiwicmVkWCIsInJlZFkiLCJncmVlblgiLCJncmVlblkiLCJibHVlWCIsImJsdWVZIiwid2hpdGVYIiwid2hpdGVZIiwicGFyc2VDb21wcmVzc2lvbiIsImNvbXByZXNzaW9uQ29kZXMiLCJwYXJzZUJveDJpIiwieE1pbiIsInlNaW4iLCJ4TWF4IiwieU1heCIsInBhcnNlTGluZU9yZGVyIiwibGluZU9yZGVycyIsImxpbmVPcmRlciIsInBhcnNlVjJmIiwicGFyc2VWM2YiLCJ6IiwicGFyc2VWYWx1ZSIsInBhcnNlSGVhZGVyIiwiRVhSSGVhZGVyMiIsInNwZWMiLCJzaW5nbGVUaWxlIiwibG9uZ05hbWUiLCJkZWVwRm9ybWF0IiwibXVsdGlQYXJ0Iiwia2VlcFJlYWRpbmciLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlVHlwZSIsImF0dHJpYnV0ZVNpemUiLCJhdHRyaWJ1dGVWYWx1ZSIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyb3IiLCJzZXR1cERlY29kZXIiLCJvdXRwdXRUeXBlIiwiRVhSRGVjb2RlcjIiLCJkYXRhV2luZG93IiwiYnl0ZXNQZXJMaW5lIiwiaW5wdXRTaXplIiwidW5jb21wcmVzcyIsImdldHRlciIsImZvcm1hdCIsImJsb2NrQ291bnQiLCJvdXRwdXRDaGFubmVscyIsImJ5dGVBcnJheSIsImNvbG9yU3BhY2UiLCJlbmNvZGluZyIsImJ1ZmZlckRhdGFWaWV3IiwidUludDhBcnJheSIsIkVYUkRlY29kZXIiLCJ0bXBPZmZzZXQiLCJjaGFubmVsT2Zmc2V0cyIsIlIiLCJHIiwiQiIsIkEiLCJZIiwic2NhbmxpbmVCbG9ja0lkeCIsImxpbmUiLCJpc0NvbXByZXNzZWQiLCJsaW5lX3kiLCJ0cnVlX3kiLCJjaGFubmVsSUQiLCJjT2ZmIiwib3V0SW5kZXgiLCJoZWFkZXIiLCJzZXREYXRhVHlwZSIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsIm9uTG9hZENhbGxiYWNrIiwidGV4dHVyZSIsInRleERhdGEiLCJtaW5GaWx0ZXIiLCJtYWdGaWx0ZXIiLCJnZW5lcmF0ZU1pcG1hcHMiLCJmbGlwWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            resourcePath = this.path;\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.fromArray(lightDef.color);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, 3001));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, 3001));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, encoding) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (encoding !== void 0) {\n                if (\"colorSpace\" in texture) texture.colorSpace = encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n                else texture.encoding = encoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(materialDef.emissiveFactor);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, 3001));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                node.updateMatrix();\n                let TypedKeyframeTrack;\n                switch(PATH_PROPERTIES[target.path]){\n                    case PATH_PROPERTIES.weights:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.rotation:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.position:\n                    case PATH_PROPERTIES.scale:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                const targetName = node.name ? node.name : node.uuid;\n                const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n                const targetNames = [];\n                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n                    node.traverse(function(object) {\n                        if (object.morphTargetInfluences) {\n                            targetNames.push(object.name ? object.name : object.uuid);\n                        }\n                    });\n                } else {\n                    targetNames.push(targetName);\n                }\n                let outputArray = outputAccessor.array;\n                if (outputAccessor.normalized) {\n                    const scale = getNormalizedComponentScale(outputArray.constructor);\n                    const scaled = new Float32Array(outputArray.length);\n                    for(let j = 0, jl = outputArray.length; j < jl; j++){\n                        scaled[j] = outputArray[j] * scale;\n                    }\n                    outputArray = scaled;\n                }\n                for(let j = 0, jl = targetNames.length; j < jl; j++){\n                    const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n                    if (sampler.interpolation === \"CUBICSPLINE\") {\n                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n                            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n                        };\n                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n                    }\n                    tracks.push(track);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0dMVEZMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnOEI7QUFDMTNCO0FBQ2xCO0FBQ3BELE1BQU0rRCxtQkFBbUIvRCx5Q0FBTUE7SUFDN0JnRSxZQUFZQyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLEVBQUU7UUFDekIsSUFBSSxDQUFDQyxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlDLGdDQUFnQ0Q7UUFDN0M7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUUsMkJBQTJCRjtRQUN4QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJRyx5QkFBeUJIO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlJLHlCQUF5Qko7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUssNEJBQTRCTDtRQUN6QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJTSxtQ0FBbUNOO1FBQ2hEO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlPLDZCQUE2QlA7UUFDMUM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSVEsMEJBQTBCUjtRQUN2QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFD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LGFBQWEsQ0FBQyxZQUFZc1ksZUFBZWxZLElBQUksQ0FBQyxTQUFTeUgsUUFBUTtZQUMzRVksU0FBU1MsWUFBWSxDQUFDRCxlQUFlcEI7UUFDdkM7SUFDRjtJQUNBLElBQUssTUFBTXNjLHFCQUFxQnZjLFdBQVk7UUFDMUMsTUFBTWlELHFCQUFxQkMsVUFBVSxDQUFDcVosa0JBQWtCLElBQUlBLGtCQUFrQnBaLFdBQVc7UUFDekYsSUFBSUYsc0JBQXNCcEMsU0FBU2IsVUFBVSxFQUMzQztRQUNGbEgsUUFBUWxILElBQUksQ0FBQzBxQix3QkFBd0J0YyxVQUFVLENBQUN1YyxrQkFBa0IsRUFBRXRaO0lBQ3RFO0lBQ0EsSUFBSTJJLGFBQWFHLE9BQU8sS0FBSyxLQUFLLEtBQUssQ0FBQ2xMLFNBQVN4SSxLQUFLLEVBQUU7UUFDdEQsTUFBTTRILFdBQVd0UixPQUFPeUosYUFBYSxDQUFDLFlBQVl3VCxhQUFhRyxPQUFPLEVBQUV2VCxJQUFJLENBQUMsU0FBU2drQixTQUFTO1lBQzdGM2IsU0FBUzRiLFFBQVEsQ0FBQ0Q7UUFDcEI7UUFDQTFqQixRQUFRbEgsSUFBSSxDQUFDcU87SUFDZjtJQUNBaEksdUJBQXVCNEksVUFBVStLO0lBQ2pDeVAsY0FBY3hhLFVBQVUrSyxjQUFjamQ7SUFDdEMsT0FBT3lGLFFBQVFvRixHQUFHLENBQUNWLFNBQVNOLElBQUksQ0FBQztRQUMvQixPQUFPb1QsYUFBYXBCLE9BQU8sS0FBSyxLQUFLLElBQUlELGdCQUFnQjFKLFVBQVUrSyxhQUFhcEIsT0FBTyxFQUFFN2IsVUFBVWtTO0lBQ3JHO0FBQ0Y7QUFHRSxDQUNGLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9HTFRGTG9hZGVyLmpzPzI1ZGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBMb2FkZXJVdGlscywgRmlsZUxvYWRlciwgQ29sb3IsIFNwb3RMaWdodCwgUG9pbnRMaWdodCwgRGlyZWN0aW9uYWxMaWdodCwgTWVzaEJhc2ljTWF0ZXJpYWwsIE1lc2hQaHlzaWNhbE1hdGVyaWFsLCBWZWN0b3IyLCBNYXRyaXg0LCBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBJbnN0YW5jZWRNZXNoLCBPYmplY3QzRCwgVGV4dHVyZUxvYWRlciwgSW1hZ2VCaXRtYXBMb2FkZXIsIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgUmVwZWF0V3JhcHBpbmcsIFBvaW50c01hdGVyaWFsLCBNYXRlcmlhbCwgTGluZUJhc2ljTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlLCBQcm9wZXJ0eUJpbmRpbmcsIEJ1ZmZlckdlb21ldHJ5LCBTa2lubmVkTWVzaCwgTWVzaCwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBMaW5lU2VnbWVudHMsIExpbmUsIExpbmVMb29wLCBQb2ludHMsIEdyb3VwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgTWF0aFV0aWxzLCBPcnRob2dyYXBoaWNDYW1lcmEsIFNrZWxldG9uLCBJbnRlcnBvbGF0ZUxpbmVhciwgQW5pbWF0aW9uQ2xpcCwgQm9uZSwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIENsYW1wVG9FZGdlV3JhcHBpbmcsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIEludGVycG9sYXRlRGlzY3JldGUsIEZyb250U2lkZSwgVGV4dHVyZSwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIEJveDMsIFNwaGVyZSwgSW50ZXJwb2xhbnQgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHRvVHJpYW5nbGVzRHJhd01vZGUgfSBmcm9tIFwiLi4vdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fcG9seWZpbGwvY29uc3RhbnRzLmpzXCI7XG5jbGFzcyBHTFRGTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBudWxsO1xuICAgIHRoaXMua3R4MkxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5wbHVnaW5DYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaEdwdUluc3RhbmNpbmcocGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGxldCByZXNvdXJjZVBhdGg7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VQYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGF0aCAhPT0gXCJcIikge1xuICAgICAgcmVzb3VyY2VQYXRoID0gdGhpcy5wYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgIH1cbiAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgY29uc3QgX29uRXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzY29wZS5wYXJzZShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXNvdXJjZVBhdGgsXG4gICAgICAgICAgICBmdW5jdGlvbihnbHRmKSB7XG4gICAgICAgICAgICAgIG9uTG9hZChnbHRmKTtcbiAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX29uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgX29uRXJyb3JcbiAgICApO1xuICB9XG4gIHNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKSB7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEREU0xvYWRlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nKTtcbiAgfVxuICBzZXRLVFgyTG9hZGVyKGt0eDJMb2FkZXIpIHtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBrdHgyTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE1lc2hvcHREZWNvZGVyKG1lc2hvcHREZWNvZGVyKSB7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG1lc2hvcHREZWNvZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVucmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgIT09IC0xKSB7XG4gICAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcy5zcGxpY2UodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwYXJzZShkYXRhLCBwYXRoLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBsZXQganNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG4gICAgY29uc3QgcGx1Z2lucyA9IHt9O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICBpZiAobWFnaWMgPT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5jb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKExvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAganNvbiA9IGRhdGE7XG4gICAgfVxuICAgIGlmIChqc29uLmFzc2V0ID09PSB2b2lkIDAgfHwganNvbi5hc3NldC52ZXJzaW9uWzBdIDwgMikge1xuICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgIG9uRXJyb3IobmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcihqc29uLCB7XG4gICAgICBwYXRoOiBwYXRoIHx8IHRoaXMucmVzb3VyY2VQYXRoIHx8IFwiXCIsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgIHJlcXVlc3RIZWFkZXI6IHRoaXMucmVxdWVzdEhlYWRlcixcbiAgICAgIG1hbmFnZXI6IHRoaXMubWFuYWdlcixcbiAgICAgIGt0eDJMb2FkZXI6IHRoaXMua3R4MkxvYWRlcixcbiAgICAgIG1lc2hvcHREZWNvZGVyOiB0aGlzLm1lc2hvcHREZWNvZGVyXG4gICAgfSk7XG4gICAgcGFyc2VyLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luQ2FsbGJhY2tzW2ldKHBhcnNlcik7XG4gICAgICBwbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgIGV4dGVuc2lvbnNbcGx1Z2luLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFtpXTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKGpzb24sIHRoaXMuZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKGV4dGVuc2lvbk5hbWUpID49IDAgJiYgcGx1Z2luc1tleHRlbnNpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBwYXJzZXIuc2V0UGx1Z2lucyhwbHVnaW5zKTtcbiAgICBwYXJzZXIucGFyc2Uob25Mb2FkLCBvbkVycm9yKTtcbiAgfVxuICBwYXJzZUFzeW5jKGRhdGEsIHBhdGgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2NvcGUucGFyc2UoZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuICBsZXQgb2JqZWN0cyA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXksIG9iamVjdCkge1xuICAgICAgb2JqZWN0c1trZXldID0gb2JqZWN0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgb2JqZWN0cyA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gIEtIUl9CSU5BUllfR0xURjogXCJLSFJfYmluYXJ5X2dsVEZcIixcbiAgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046IFwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixcbiAgS0hSX0xJR0hUU19QVU5DVFVBTDogXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCIsXG4gIEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiBcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsXG4gIEtIUl9NQVRFUklBTFNfSU9SOiBcIktIUl9tYXRlcmlhbHNfaW9yXCIsXG4gIEtIUl9NQVRFUklBTFNfU0hFRU46IFwiS0hSX21hdGVyaWFsc19zaGVlblwiLFxuICBLSFJfTUFURVJJQUxTX1NQRUNVTEFSOiBcIktIUl9tYXRlcmlhbHNfc3BlY3VsYXJcIixcbiAgS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT046IFwiS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cIixcbiAgS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTogXCJLSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlXCIsXG4gIEtIUl9NQVRFUklBTFNfQU5JU09UUk9QWTogXCJLSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHlcIixcbiAgS0hSX01BVEVSSUFMU19VTkxJVDogXCJLSFJfbWF0ZXJpYWxzX3VubGl0XCIsXG4gIEtIUl9NQVRFUklBTFNfVk9MVU1FOiBcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCIsXG4gIEtIUl9URVhUVVJFX0JBU0lTVTogXCJLSFJfdGV4dHVyZV9iYXNpc3VcIixcbiAgS0hSX1RFWFRVUkVfVFJBTlNGT1JNOiBcIktIUl90ZXh0dXJlX3RyYW5zZm9ybVwiLFxuICBLSFJfTUVTSF9RVUFOVElaQVRJT046IFwiS0hSX21lc2hfcXVhbnRpemF0aW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg6IFwiS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aFwiLFxuICBFWFRfVEVYVFVSRV9XRUJQOiBcIkVYVF90ZXh0dXJlX3dlYnBcIixcbiAgRVhUX1RFWFRVUkVfQVZJRjogXCJFWFRfdGV4dHVyZV9hdmlmXCIsXG4gIEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OOiBcIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uXCIsXG4gIEVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HOiBcIkVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nXCJcbn07XG5jbGFzcyBHTFRGTGlnaHRzRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTElHSFRTX1BVTkNUVUFMO1xuICAgIHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICB9XG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlci5fYWRkTm9kZVJlZih0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9sb2FkTGlnaHQobGlnaHRJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJsaWdodDpcIiArIGxpZ2h0SW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSBwYXJzZXIuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoZGVwZW5kZW5jeSlcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0RGVmcyA9IGV4dGVuc2lvbnMubGlnaHRzIHx8IFtdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbGlnaHREZWZzW2xpZ2h0SW5kZXhdO1xuICAgIGxldCBsaWdodE5vZGU7XG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMTY3NzcyMTUpO1xuICAgIGlmIChsaWdodERlZi5jb2xvciAhPT0gdm9pZCAwKVxuICAgICAgY29sb3IuZnJvbUFycmF5KGxpZ2h0RGVmLmNvbG9yKTtcbiAgICBjb25zdCByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB2b2lkIDAgPyBsaWdodERlZi5yYW5nZSA6IDA7XG4gICAgc3dpdGNoIChsaWdodERlZi50eXBlKSB7XG4gICAgICBjYXNlIFwiZGlyZWN0aW9uYWxcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBQb2ludExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNwb3RcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IFNwb3RMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBsaWdodERlZi5zcG90ID0gbGlnaHREZWYuc3BvdCB8fCB7fTtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgOiAwO1xuICAgICAgICBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSAhPT0gdm9pZCAwID8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA6IE1hdGguUEkgLyA0O1xuICAgICAgICBsaWdodE5vZGUuYW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUucGVudW1icmEgPSAxIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG4gICAgICAgIGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgbGlnaHROb2RlLmFkZChsaWdodE5vZGUudGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbmV4cGVjdGVkIGxpZ2h0IHR5cGU6IFwiICsgbGlnaHREZWYudHlwZSk7XG4gICAgfVxuICAgIGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgbGlnaHROb2RlLmRlY2F5ID0gMjtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGxpZ2h0Tm9kZSwgbGlnaHREZWYpO1xuICAgIGlmIChsaWdodERlZi5pbnRlbnNpdHkgIT09IHZvaWQgMClcbiAgICAgIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG4gICAgbGlnaHROb2RlLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShsaWdodERlZi5uYW1lIHx8IFwibGlnaHRfXCIgKyBsaWdodEluZGV4KTtcbiAgICBkZXBlbmRlbmN5ID0gUHJvbWlzZS5yZXNvbHZlKGxpZ2h0Tm9kZSk7XG4gICAgcGFyc2VyLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGlmICh0eXBlICE9PSBcImxpZ2h0XCIpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChpbmRleCk7XG4gIH1cbiAgY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KSB7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0SW5kZXggPSBsaWdodERlZi5saWdodDtcbiAgICBpZiAobGlnaHRJbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChsaWdodEluZGV4KS50aGVuKGZ1bmN0aW9uKGxpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHNlbGYyLmNhY2hlLCBsaWdodEluZGV4LCBsaWdodCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hCYXNpY01hdGVyaWFsO1xuICB9XG4gIGV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KGFycmF5KTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIDMwMDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGVtaXNzaXZlU3RyZW5ndGggPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0uZW1pc3NpdmVTdHJlbmd0aDtcbiAgICBpZiAoZW1pc3NpdmVTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZUludGVuc2l0eSA9IGVtaXNzaXZlU3RyZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0ID0gZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXRNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Um91Z2huZXNzID0gZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXRSb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXROb3JtYWxNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUpKTtcbiAgICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZUZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZUZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZUlvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZUlPUiA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZUlvcjtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsxMDAsIDQwMF07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMF0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzFdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfU0hFRU47XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yID0gbmV3IENvbG9yKDAsIDAsIDApO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gMDtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbiA9IDE7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvckZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLmZyb21BcnJheShleHRlbnNpb24uc2hlZW5Db2xvckZhY3Rvcik7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCAzMDAxKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlblJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNtaXNzaW9uID0gZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0cmFuc21pc3Npb25NYXBcIiwgZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1ZPTFVNRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy50aGlja25lc3MgPSBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yIDogMDtcbiAgICBpZiAoZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gZXh0ZW5zaW9uLmF0dGVudWF0aW9uRGlzdGFuY2UgfHwgSW5maW5pdHk7XG4gICAgY29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yIHx8IFsxLCAxLCAxXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKGNvbG9yQXJyYXlbMF0sIGNvbG9yQXJyYXlbMV0sIGNvbG9yQXJyYXlbMl0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JT1I7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5pb3IgPSBleHRlbnNpb24uaW9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uaW9yIDogMS41O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NQRUNVTEFSO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFySW50ZW5zaXR5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgOiAxO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckludGVuc2l0eU1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uc3BlY3VsYXJDb2xvckZhY3RvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJDb2xvciA9IG5ldyBDb2xvcihjb2xvckFycmF5WzBdLCBjb2xvckFycmF5WzFdLCBjb2xvckFycmF5WzJdKTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJDb2xvck1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUsIDMwMDEpXG4gICAgICAgIC8vIHNSR0JFbmNvZGluZ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19BTklTT1RST1BZO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHkgPSBleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5Um90YXRpb24gPSBleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhbmlzb3Ryb3B5TWFwXCIsIGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9CQVNJU1U7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgbG9hZGVyID0gcGFyc2VyLm9wdGlvbnMua3R4MkxvYWRlcjtcbiAgICBpZiAoIWxvYWRlcikge1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IHNldEtUWDJMb2FkZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgS1RYMiB0ZXh0dXJlc1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzW2V4dGVuc2lvbi5zb3VyY2VdO1xuICAgIGxldCBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2UudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbihpc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBXZWJQIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZGV0ZWN0U3VwcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmlJQUFBQlhSVUpRVmxBNElCWUFBQUF3QVFDZEFTb0JBQUVBRHNEK0phUUFBM0FBQUFBQVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX0FWSUY7XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzW2V4dGVuc2lvbi5zb3VyY2VdO1xuICAgIGxldCBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2UudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbihpc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBBVklGIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZGV0ZWN0U3VwcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS9hdmlmO2Jhc2U2NCxBQUFBSUdaMGVYQmhkbWxtQUFBQUFHRjJhV1p0YVdZeGJXbGhaazFCTVVJQUFBRHliV1YwWVFBQUFBQUFBQUFvYUdSc2NnQUFBQUFBQUFBQWNHbGpkQUFBQUFBQUFBQUFBQUFBQUd4cFltRjJhV1lBQUFBQURuQnBkRzBBQUFBQUFBRUFBQUFlYVd4dll3QUFBQUJFQUFBQkFBRUFBQUFCQUFBQkdnQUFBQmNBQUFBb2FXbHVaZ0FBQUFBQUFRQUFBQnBwYm1abEFnQUFBQUFCQUFCaGRqQXhRMjlzYjNJQUFBQUFhbWx3Y25BQUFBQkxhWEJqYndBQUFCUnBjM0JsQUFBQUFBQUFBQUVBQUFBQkFBQUFFSEJwZUdrQUFBQUFBd2dJQ0FBQUFBeGhkakZEZ1FBTUFBQUFBQk5qYjJ4eWJtTnNlQUFDQUFJQUJvQUFBQUFYYVhCdFlRQUFBQUFBQUFBQkFBRUVBUUtEQkFBQUFCOXRaR0YwRWdBS0NCZ0FCb2dRRURRZ01na1FBQUFBQjhkU0xmST1cIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hvcHRDb21wcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hPUFRfQ09NUFJFU1NJT047XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgbG9hZEJ1ZmZlclZpZXcoaW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBidWZmZXJWaWV3ID0ganNvbi5idWZmZXJWaWV3c1tpbmRleF07XG4gICAgaWYgKGJ1ZmZlclZpZXcuZXh0ZW5zaW9ucyAmJiBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyXCIsIGV4dGVuc2lvbkRlZi5idWZmZXIpO1xuICAgICAgY29uc3QgZGVjb2RlciA9IHRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7XG4gICAgICBpZiAoIWRlY29kZXIgfHwgIWRlY29kZXIuc3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IHNldE1lc2hvcHREZWNvZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIGNvbXByZXNzZWQgZmlsZXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGV4dGVuc2lvbkRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBleHRlbnNpb25EZWYuYnl0ZUxlbmd0aCB8fCAwO1xuICAgICAgICBjb25zdCBjb3VudCA9IGV4dGVuc2lvbkRlZi5jb3VudDtcbiAgICAgICAgY29uc3Qgc3RyaWRlID0gZXh0ZW5zaW9uRGVmLmJ5dGVTdHJpZGU7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHJlcywgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIGlmIChkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXJBc3luYykge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXJBc3luYyhjb3VudCwgc3RyaWRlLCBzb3VyY2UsIGV4dGVuc2lvbkRlZi5tb2RlLCBleHRlbnNpb25EZWYuZmlsdGVyKS50aGVuKGZ1bmN0aW9uKHJlczIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMyLmJ1ZmZlcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5yZWFkeS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGNvdW50ICogc3RyaWRlKTtcbiAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlcihcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KSxcbiAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYubW9kZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLmZpbHRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNoR3B1SW5zdGFuY2luZyB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hfR1BVX0lOU1RBTkNJTkc7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAoIW5vZGVEZWYuZXh0ZW5zaW9ucyB8fCAhbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwgbm9kZURlZi5tZXNoID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbm9kZURlZi5tZXNoXTtcbiAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBtZXNoRGVmLnByaW1pdGl2ZXMpIHtcbiAgICAgIGlmIChwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOICYmIHByaW1pdGl2ZS5tb2RlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNEZWYgPSBleHRlbnNpb25EZWYuYXR0cmlidXRlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXNEZWYpIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGF0dHJpYnV0ZXNEZWZba2V5XSkudGhlbigoYWNjZXNzb3IpID0+IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBhY2Nlc3NvcjtcbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaCh0aGlzLnBhcnNlci5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgY29uc3Qgbm9kZU9iamVjdCA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBtZXNoZXMgPSBub2RlT2JqZWN0LmlzR3JvdXAgPyBub2RlT2JqZWN0LmNoaWxkcmVuIDogW25vZGVPYmplY3RdO1xuICAgICAgY29uc3QgY291bnQgPSByZXN1bHRzWzBdLmNvdW50O1xuICAgICAgY29uc3QgaW5zdGFuY2VkTWVzaGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBjb25zdCBwID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IG5ldyBJbnN0YW5jZWRNZXNoKG1lc2guZ2VvbWV0cnksIG1lc2gubWF0ZXJpYWwsIGNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04pIHtcbiAgICAgICAgICAgIHAuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuUk9UQVRJT04pIHtcbiAgICAgICAgICAgIHEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlJPVEFUSU9OLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuU0NBTEUpIHtcbiAgICAgICAgICAgIHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlNDQUxFLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2VkTWVzaC5zZXRNYXRyaXhBdChpLCBtLmNvbXBvc2UocCwgcSwgcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgIT09IFwiVFJBTlNMQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlJPVEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJTQ0FMRVwiKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbChpbnN0YW5jZWRNZXNoLCBtZXNoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChpbnN0YW5jZWRNZXNoKTtcbiAgICAgICAgaW5zdGFuY2VkTWVzaGVzLnB1c2goaW5zdGFuY2VkTWVzaCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZU9iamVjdC5pc0dyb3VwKSB7XG4gICAgICAgIG5vZGVPYmplY3QuY2xlYXIoKTtcbiAgICAgICAgbm9kZU9iamVjdC5hZGQoLi4uaW5zdGFuY2VkTWVzaGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VkTWVzaGVzWzBdO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9IFwiZ2xURlwiO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAxMzEzODIxNTE0LCBCSU46IDUxMzA1NjIgfTtcbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIGNvbnN0IGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICB0aGlzLmhlYWRlciA9IHtcbiAgICAgIG1hZ2ljOiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKSxcbiAgICAgIHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKDQsIHRydWUpLFxuICAgICAgbGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMig4LCB0cnVlKVxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuICAgIGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICB3aGlsZSAoY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04pIHtcbiAgICAgICAgY29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KGNvbnRlbnRBcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4pIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG4gICAgICAgIHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoanNvbiwgZHJhY29Mb2FkZXIpIHtcbiAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgdGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG4gIH1cbiAgZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG4gICAgY29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3O1xuICAgIGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRocmVlQXR0cmlidXRlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgYXR0cmlidXRlVHlwZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gY29tcG9uZW50VHlwZS5uYW1lO1xuICAgICAgICBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGJ1ZmZlclZpZXdJbmRleCkudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBkcmFjb0xvYWRlci5kZWNvZGVEcmFjb0ZpbGUoXG4gICAgICAgICAgYnVmZmVyVmlldyxcbiAgICAgICAgICBmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGlmIChub3JtYWxpemVkICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShnZW9tZXRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJlZUF0dHJpYnV0ZU1hcCxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlTWFwXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcbiAgfVxuICBleHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgIGlmICgodHJhbnNmb3JtLnRleENvb3JkID09PSB2b2lkIDAgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwpICYmIHRyYW5zZm9ybS5vZmZzZXQgPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgaWYgKHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLmNoYW5uZWwgPSB0cmFuc2Zvcm0udGV4Q29vcmQ7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSh0cmFuc2Zvcm0ub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSh0cmFuc2Zvcm0uc2NhbGUpO1xuICAgIH1cbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcbiAgfVxufVxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuICBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLCB2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSwgb2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG4gICAgY29uc3QgdGQgPSB0MSAtIHQwO1xuICAgIGNvbnN0IHAgPSAodCAtIHQwKSAvIHRkO1xuICAgIGNvbnN0IHBwID0gcCAqIHA7XG4gICAgY29uc3QgcHBwID0gcHAgKiBwO1xuICAgIGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuICAgIGNvbnN0IHMyID0gLTIgKiBwcHAgKyAzICogcHA7XG4gICAgY29uc3QgczMgPSBwcHAgLSBwcDtcbiAgICBjb25zdCBzMCA9IDEgLSBzMjtcbiAgICBjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkrKykge1xuICAgICAgY29uc3QgcDAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGUyXSAqIHRkO1xuICAgICAgY29uc3QgcDEgPSB2YWx1ZXNbb2Zmc2V0MSArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTEgPSB2YWx1ZXNbb2Zmc2V0MSArIGldICogdGQ7XG4gICAgICByZXN1bHRbaV0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBfcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuICAgIF9xLmZyb21BcnJheShyZXN1bHQpLm5vcm1hbGl6ZSgpLnRvQXJyYXkocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG4gIEZMT0FUOiA1MTI2LFxuICAvL0ZMT0FUX01BVDI6IDM1Njc0LFxuICBGTE9BVF9NQVQzOiAzNTY3NSxcbiAgRkxPQVRfTUFUNDogMzU2NzYsXG4gIEZMT0FUX1ZFQzI6IDM1NjY0LFxuICBGTE9BVF9WRUMzOiAzNTY2NSxcbiAgRkxPQVRfVkVDNDogMzU2NjYsXG4gIExJTkVBUjogOTcyOSxcbiAgUkVQRUFUOiAxMDQ5NyxcbiAgU0FNUExFUl8yRDogMzU2NzgsXG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2LFxuICBVTlNJR05FRF9CWVRFOiA1MTIxLFxuICBVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG4gIDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG4gIDk3Mjk6IExpbmVhckZpbHRlcixcbiAgOTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gIDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcbiAgMzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuICAxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046IFwicG9zaXRpb25cIixcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUQU5HRU5UOiBcInRhbmdlbnRcIixcbiAgLy8gdXYgPT4gdXYxLCA0IHV2IGNoYW5uZWxzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU3ODhcbiAgLi4udmVyc2lvbiA+PSAxNTIgPyB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYxXCIsXG4gICAgVEVYQ09PUkRfMjogXCJ1djJcIixcbiAgICBURVhDT09SRF8zOiBcInV2M1wiXG4gIH0gOiB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYyXCJcbiAgfSxcbiAgQ09MT1JfMDogXCJjb2xvclwiLFxuICBXRUlHSFRTXzA6IFwic2tpbldlaWdodFwiLFxuICBKT0lOVFNfMDogXCJza2luSW5kZXhcIlxufTtcbmNvbnN0IFBBVEhfUFJPUEVSVElFUyA9IHtcbiAgc2NhbGU6IFwic2NhbGVcIixcbiAgdHJhbnNsYXRpb246IFwicG9zaXRpb25cIixcbiAgcm90YXRpb246IFwicXVhdGVybmlvblwiLFxuICB3ZWlnaHRzOiBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IHtcbiAgQ1VCSUNTUExJTkU6IHZvaWQgMCxcbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG4gIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuICBMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuICBTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG4gIE9QQVFVRTogXCJPUEFRVUVcIixcbiAgTUFTSzogXCJNQVNLXCIsXG4gIEJMRU5EOiBcIkJMRU5EXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoY2FjaGUpIHtcbiAgaWYgKGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID09PSB2b2lkIDApIHtcbiAgICBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBlbWlzc2l2ZTogMCxcbiAgICAgIG1ldGFsbmVzczogMSxcbiAgICAgIHJvdWdobmVzczogMSxcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIHNpZGU6IEZyb250U2lkZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXTtcbn1cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucykge1xuICAgIGlmIChrbm93bkV4dGVuc2lvbnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zW25hbWVdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG9iamVjdCwgZ2x0ZkRlZikge1xuICBpZiAoZ2x0ZkRlZi5leHRyYXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsIFwiICsgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIpIHtcbiAgbGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaENvbG9yID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoQ29sb3IgPSB0cnVlO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICYmIGhhc01vcnBoQ29sb3IpXG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWhhc01vcnBoUG9zaXRpb24gJiYgIWhhc01vcnBoTm9ybWFsICYmICFoYXNNb3JwaENvbG9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2VvbWV0cnkpO1xuICBjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5QT1NJVElPTikgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5OT1JNQUwpIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5DT0xPUl8wKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UuYWxsKHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ05vcm1hbEFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ0NvbG9yQWNjZXNzb3JzKVxuICBdKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29ycykge1xuICAgIGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWzBdO1xuICAgIGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sxXTtcbiAgICBjb25zdCBtb3JwaENvbG9ycyA9IGFjY2Vzc29yc1syXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuICAgIGlmIChoYXNNb3JwaE5vcm1hbClcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgPSBtb3JwaENvbG9ycztcbiAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKSB7XG4gIG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG4gIGlmIChtZXNoRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG1lc2hEZWYud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkobWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMpKSB7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcbiAgICBpZiAobWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RhcmdldE5hbWVzW2ldXSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZURlZikge1xuICBsZXQgZ2VvbWV0cnlLZXk7XG4gIGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07XG4gIGlmIChkcmFjb0V4dGVuc2lvbikge1xuICAgIGdlb21ldHJ5S2V5ID0gXCJkcmFjbzpcIiArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYuYXR0cmlidXRlcykgKyBcIjpcIiArIHByaW1pdGl2ZURlZi5tb2RlO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlRGVmLnRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgZ2VvbWV0cnlLZXkgKz0gXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi50YXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5S2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleShhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyaWJ1dGVzS2V5ID0gXCJcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgYXR0cmlidXRlc0tleSArPSBrZXlzW2ldICsgXCI6XCIgKyBhdHRyaWJ1dGVzW2tleXNbaV1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoY29uc3RydWN0b3IpIHtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAxMjc7XG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAyNTU7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAzMjc2NztcbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyA2NTUzNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlVVJJTWltZVR5cGUodXJpKSB7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC5qcGU/ZygkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC9qcGVnLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAodXJpLnNlYXJjaCgvXFwud2VicCgkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC93ZWJwLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbn1cbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5jbGFzcyBHTFRGUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoanNvbiA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5tZXNoQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuY2FtZXJhQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMubGlnaHRDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5zb3VyY2VDYWNoZSA9IHt9O1xuICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlTmFtZXNVc2VkID0ge307XG4gICAgbGV0IGlzU2FmYXJpID0gZmFsc2U7XG4gICAgbGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuICAgIGxldCBmaXJlZm94VmVyc2lvbiA9IC0xO1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTE7XG4gICAgICBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pWzFdIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNTYWZhcmkgfHwgaXNGaXJlZm94ICYmIGZpcmVmb3hWZXJzaW9uIDwgOTgpIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gXCJ1c2UtY3JlZGVudGlhbHNcIikge1xuICAgICAgdGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgfVxuICBzZXRQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICB9XG4gIHBhcnNlKG9uTG9hZCwgb25FcnJvcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuICAgICAgfSlcbiAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwic2NlbmVcIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJhbmltYXRpb25cIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJjYW1lcmFcIilcbiAgICAgIF0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNjZW5lOiBkZXBlbmRlbmNpZXNbMF1banNvbi5zY2VuZSB8fCAwXSxcbiAgICAgICAgc2NlbmVzOiBkZXBlbmRlbmNpZXNbMF0sXG4gICAgICAgIGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sxXSxcbiAgICAgICAgY2FtZXJhczogZGVwZW5kZW5jaWVzWzJdLFxuICAgICAgICBhc3NldDoganNvbi5hc3NldCxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB1c2VyRGF0YToge31cbiAgICAgIH07XG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uKTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEocmVzdWx0LCBqc29uKTtcbiAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KHJlc3VsdCk7XG4gICAgICAgIH0pXG4gICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2gob25FcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2UuXG4gICAqL1xuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG4gICAgY29uc3Qgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG4gICAgY29uc3QgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuICAgIGZvciAobGV0IHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2ludHMgPSBza2luRGVmc1tza2luSW5kZXhdLmpvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGVEZWZzW2pvaW50c1tpXV0uaXNCb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYubWVzaCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCk7XG4gICAgICAgIGlmIChub2RlRGVmLnNraW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2hEZWZzW25vZGVEZWYubWVzaF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuICAgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcbiAgICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuICAgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuICAgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cbiAgICpcbiAgICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cbiAgICovXG4gIF9hZGROb2RlUmVmKGNhY2hlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWNoZS5yZWZzW2luZGV4XSA9IGNhY2hlLnVzZXNbaW5kZXhdID0gMDtcbiAgICB9XG4gICAgY2FjaGUucmVmc1tpbmRleF0rKztcbiAgfVxuICAvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG4gIF9nZXROb2RlUmVmKGNhY2hlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdIDw9IDEpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGNvbnN0IHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuICAgIGNvbnN0IHVwZGF0ZU1hcHBpbmdzID0gKG9yaWdpbmFsLCBjbG9uZSkgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZ3MgPSB0aGlzLmFzc29jaWF0aW9ucy5nZXQob3JpZ2luYWwpO1xuICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNsb25lLCBtYXBwaW5ncyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpLCBjaGlsZF0gb2Ygb3JpZ2luYWwuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIHVwZGF0ZU1hcHBpbmdzKGNoaWxkLCBjbG9uZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVNYXBwaW5ncyhvYmplY3QsIHJlZik7XG4gICAgcmVmLm5hbWUgKz0gXCJfaW5zdGFuY2VfXCIgKyBjYWNoZS51c2VzW2luZGV4XSsrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX2ludm9rZU9uZShmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnB1c2godGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2ludm9rZUFsbChmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnVuc2hpZnQodGhpcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdHlwZSArIFwiOlwiICsgaW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNjZW5lXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNjZW5lKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTm9kZSAmJiBleHQubG9hZE5vZGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzaFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhY2Nlc3NvclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJWaWV3XCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEJ1ZmZlclZpZXcgJiYgZXh0LmxvYWRCdWZmZXJWaWV3KGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0dXJlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZFRleHR1cmUgJiYgZXh0LmxvYWRUZXh0dXJlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNraW5cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbmltYXRpb25cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQW5pbWF0aW9uICYmIGV4dC5sb2FkQW5pbWF0aW9uKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhbWVyYVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ICE9IHRoaXMgJiYgZXh0LmdldERlcGVuZGVuY3kgJiYgZXh0LmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG4gICAqL1xuICBnZXREZXBlbmRlbmNpZXModHlwZSkge1xuICAgIGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCh0eXBlKTtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICAgIGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bdHlwZSArICh0eXBlID09PSBcIm1lc2hcIiA/IFwiZXNcIiA6IFwic1wiKV0gfHwgW107XG4gICAgICBkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbChcbiAgICAgICAgZGVmcy5tYXAoZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5jYWNoZS5hZGQodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlcihidWZmZXJJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzW2J1ZmZlckluZGV4XTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG4gICAgaWYgKGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFwiICsgYnVmZmVyRGVmLnR5cGUgKyBcIiBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlckRlZi51cmkgPT09IHZvaWQgMCAmJiBidWZmZXJJbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmJvZHkpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoKSwgcmVzb2x2ZSwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJWaWV3SW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyVmlldyhidWZmZXJWaWV3SW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBidWZmZXJWaWV3RGVmLmJ1ZmZlcikudGhlbihmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3RGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FjY2Vzc29yc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYWNjZXNzb3JJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT59XG4gICAqL1xuICBsb2FkQWNjZXNzb3IoYWNjZXNzb3JJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhY2Nlc3NvckRlZiA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbYWNjZXNzb3JJbmRleF07XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHZvaWQgMCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldykpO1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdCdWZmZXJWaWV3cykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3cykge1xuICAgICAgY29uc3QgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWzBdO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwID8ganNvbi5idWZmZXJWaWV3c1thY2Nlc3NvckRlZi5idWZmZXJWaWV3XS5ieXRlU3RyaWRlIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBsZXQgYXJyYXksIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGlmIChieXRlU3RyaWRlICYmIGJ5dGVTdHJpZGUgIT09IGl0ZW1CeXRlcykge1xuICAgICAgICBjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vcihieXRlT2Zmc2V0IC8gYnl0ZVN0cmlkZSk7XG4gICAgICAgIGNvbnN0IGliQ2FjaGVLZXkgPSBcIkludGVybGVhdmVkQnVmZmVyOlwiICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArIFwiOlwiICsgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSArIFwiOlwiICsgaWJTbGljZSArIFwiOlwiICsgYWNjZXNzb3JEZWYuY291bnQ7XG4gICAgICAgIGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoaWJDYWNoZUtleSk7XG4gICAgICAgIGlmICghaWIpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGliU2xpY2UgKiBieXRlU3RyaWRlLCBhY2Nlc3NvckRlZi5jb3VudCAqIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBwYXJzZXIuY2FjaGUuYWRkKGliQ2FjaGVLZXksIGliKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgaWIsXG4gICAgICAgICAgaXRlbVNpemUsXG4gICAgICAgICAgYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMsXG4gICAgICAgICAgbm9ybWFsaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuICAgICAgICBjb25zdCBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3Qgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyhcbiAgICAgICAgICBidWZmZXJWaWV3c1sxXSxcbiAgICAgICAgICBieXRlT2Zmc2V0SW5kaWNlcyxcbiAgICAgICAgICBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3BhcnNlVmFsdWVzID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlld3NbMl0sIGJ5dGVPZmZzZXRWYWx1ZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBzcGFyc2VJbmRpY2VzW2ldO1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDIpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WShpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDFdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMylcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMl0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA0KVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFcoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAzXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBpdGVtU2l6ZSBpbiBzcGFyc2UgQnVmZmVyQXR0cmlidXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlfG51bGw+fVxuICAgKi9cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlSW5kZXggPSB0ZXh0dXJlRGVmLnNvdXJjZTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgbGV0IGxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlRGVmLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IG9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZURlZi51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKTtcbiAgfVxuICBsb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBjYWNoZUtleSA9IChzb3VyY2VEZWYudXJpIHx8IHNvdXJjZURlZi5idWZmZXJWaWV3KSArIFwiOlwiICsgdGV4dHVyZURlZi5zYW1wbGVyO1xuICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZSB8fCBzb3VyY2VEZWYubmFtZSB8fCBcIlwiO1xuICAgICAgaWYgKHRleHR1cmUubmFtZSA9PT0gXCJcIiAmJiB0eXBlb2Ygc291cmNlRGVmLnVyaSA9PT0gXCJzdHJpbmdcIiAmJiBzb3VyY2VEZWYudXJpLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGV4dHVyZS5uYW1lID0gc291cmNlRGVmLnVyaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNhbXBsZXJzID0ganNvbi5zYW1wbGVycyB8fCB7fTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1t0ZXh0dXJlRGVmLnNhbXBsZXJdIHx8IHt9O1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWFnRmlsdGVyXSB8fCBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5taW5GaWx0ZXJdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwU10gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFRdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgeyB0ZXh0dXJlczogdGV4dHVyZUluZGV4IH0pO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XS50aGVuKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLmNsb25lKCkpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkw7XG4gICAgbGV0IHNvdXJjZVVSSSA9IHNvdXJjZURlZi51cmkgfHwgXCJcIjtcbiAgICBsZXQgaXNPYmplY3RVUkwgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgc291cmNlVVJJID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIHNvdXJjZURlZi5idWZmZXJWaWV3KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgICAgaXNPYmplY3RVUkwgPSB0cnVlO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlclZpZXddLCB7IHR5cGU6IHNvdXJjZURlZi5taW1lVHlwZSB9KTtcbiAgICAgICAgc291cmNlVVJJID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVVSSTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc291cmNlRGVmLnVyaSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBJbWFnZSBcIiArIHNvdXJjZUluZGV4ICsgXCIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXdcIik7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc291cmNlVVJJKS50aGVuKGZ1bmN0aW9uKHNvdXJjZVVSSTIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG9uTG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGlmIChsb2FkZXIuaXNJbWFnZUJpdG1hcExvYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9uTG9hZCA9IGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHRleHR1cmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChzb3VyY2VVUkkyLCBvcHRpb25zLnBhdGgpLCBvbkxvYWQsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKGlzT2JqZWN0VVJMID09PSB0cnVlKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVVJJKTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmUudXNlckRhdGEubWltZVR5cGUgPSBzb3VyY2VEZWYubWltZVR5cGUgfHwgZ2V0SW1hZ2VVUklNaW1lVHlwZShzb3VyY2VEZWYudXJpKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQ291bGRuJ3QgbG9hZCB0ZXh0dXJlXCIsIHNvdXJjZVVSSSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRleHR1cmU+fVxuICAgKi9cbiAgYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgbWFwTmFtZSwgbWFwRGVmLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcInRleHR1cmVcIiwgbWFwRGVmLmluZGV4KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmICghdGV4dHVyZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobWFwRGVmLnRleENvb3JkICE9PSB2b2lkIDAgJiYgbWFwRGVmLnRleENvb3JkID4gMCkge1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgICAgICB0ZXh0dXJlLmNoYW5uZWwgPSBtYXBEZWYudGV4Q29vcmQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB2b2lkIDAgPyBtYXBEZWYuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0gOiB2b2lkIDA7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBnbHRmUmVmZXJlbmNlID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQodGV4dHVyZSk7XG4gICAgICAgICAgdGV4dHVyZSA9IHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXS5leHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IGVuY29kaW5nID09PSAzMDAxID8gXCJzcmdiXCIgOiBcInNyZ2ItbGluZWFyXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtc1ttYXBOYW1lXSA9IHRleHR1cmU7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG4gICAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG4gICAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG4gICAqIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBwcmltaXRpdmUgdHlwZXMsIGRlZmluZXMsIGV0Yy4gTmV3IG1hdGVyaWFscyB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LCBhbmQgcmV1c2VkIGZyb20gYSBjYWNoZS5cbiAgICogQHBhcmFtICB7T2JqZWN0M0R9IG1lc2ggTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLlxuICAgKi9cbiAgYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuICAgIGxldCBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XG4gICAgY29uc3QgdXNlRGVyaXZhdGl2ZVRhbmdlbnRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ID09PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlVmVydGV4Q29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZUZsYXRTaGFkaW5nID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwgPT09IHZvaWQgMDtcbiAgICBpZiAobWVzaC5pc1BvaW50cykge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIlBvaW50c01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBwb2ludHNNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghcG9pbnRzTWF0ZXJpYWwpIHtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIHBvaW50c01hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gcG9pbnRzTWF0ZXJpYWw7XG4gICAgfSBlbHNlIGlmIChtZXNoLmlzTGluZSkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIkxpbmVCYXNpY01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBsaW5lTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWxpbmVNYXRlcmlhbCkge1xuICAgICAgICBsaW5lTWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChsaW5lTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgbGluZU1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gbGluZU1hdGVyaWFsO1xuICAgIH1cbiAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzIHx8IHVzZVZlcnRleENvbG9ycyB8fCB1c2VGbGF0U2hhZGluZykge1xuICAgICAgbGV0IGNhY2hlS2V5ID0gXCJDbG9uZWRNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQgKyBcIjpcIjtcbiAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZGVyaXZhdGl2ZS10YW5nZW50czpcIjtcbiAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwidmVydGV4LWNvbG9yczpcIjtcbiAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJmbGF0LXNoYWRpbmc6XCI7XG4gICAgICBsZXQgY2FjaGVkTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWNhY2hlZE1hdGVyaWFsKSB7XG4gICAgICAgIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKSB7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBjYWNoZWRNYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG1hdGVyaWFsKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGNhY2hlZE1hdGVyaWFsO1xuICAgIH1cbiAgICBtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxNYXRlcmlhbD59XG4gICAqL1xuICBsb2FkTWF0ZXJpYWwobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgbGV0IG1hdGVyaWFsVHlwZTtcbiAgICBjb25zdCBtYXRlcmlhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1hdGVyaWFsRXh0ZW5zaW9ucyA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwge307XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGlmIChtYXRlcmlhbEV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXSkge1xuICAgICAgY29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdO1xuICAgICAgbWF0ZXJpYWxUeXBlID0ga211RXh0ZW5zaW9uLmdldE1hdGVyaWFsVHlwZSgpO1xuICAgICAgcGVuZGluZy5wdXNoKGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcyB8fCB7fTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoYXJyYXkpO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbM107XG4gICAgICB9XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSwgMzAwMSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnJvdWdobmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIDogMTtcbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWV0YWxuZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwicm91Z2huZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgIH1cbiAgICBjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB2b2lkIDAgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibm9ybWFsTWFwXCIsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUpKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFvTWFwXCIsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUpKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheShtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3Rvcik7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiZW1pc3NpdmVNYXBcIiwgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlLCAzMDAxKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxUeXBlKG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5uYW1lKVxuICAgICAgICBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1hdGVyaWFsLCB7IG1hdGVyaWFsczogbWF0ZXJpYWxJbmRleCB9KTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICAvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cbiAgY3JlYXRlVW5pcXVlTmFtZShvcmlnaW5hbE5hbWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUob3JpZ2luYWxOYW1lIHx8IFwiXCIpO1xuICAgIGlmIChzYW5pdGl6ZWROYW1lIGluIHRoaXMubm9kZU5hbWVzVXNlZCkge1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWUgKyBcIl9cIiArICsrdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV0gPSAwO1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dlb21ldHJ5XG4gICAqXG4gICAqIENyZWF0ZXMgQnVmZmVyR2VvbWV0cmllcyBmcm9tIHByaW1pdGl2ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8R0xURi5QcmltaXRpdmU+fSBwcmltaXRpdmVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8QnVmZmVyR2VvbWV0cnk+Pn1cbiAgICovXG4gIGxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0uZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKS50aGVuKGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgIHJldHVybiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZSk7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChjYWNoZWQucHJvbWlzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZ2VvbWV0cnlQcm9taXNlO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0pIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMobmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7IHByaW1pdGl2ZSwgcHJvbWlzZTogZ2VvbWV0cnlQcm9taXNlIH07XG4gICAgICAgIHBlbmRpbmcucHVzaChnZW9tZXRyeVByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cbiAgICovXG4gIGxvYWRNZXNoKG1lc2hJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1ttZXNoSW5kZXhdO1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSBtZXNoRGVmLnByaW1pdGl2ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBwcmltaXRpdmVzW2ldLm1hdGVyaWFsID09PSB2b2lkIDAgPyBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwodGhpcy5jYWNoZSkgOiB0aGlzLmdldERlcGVuZGVuY3koXCJtYXRlcmlhbFwiLCBwcmltaXRpdmVzW2ldLm1hdGVyaWFsKTtcbiAgICAgIHBlbmRpbmcucHVzaChtYXRlcmlhbCk7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaChwYXJzZXIubG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoMCwgcmVzdWx0cy5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBtZXNoZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICAgIGxldCBtZXNoO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG1hdGVyaWFsc1tpXTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHwgcHJpbWl0aXZlLm1vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2ggPSBtZXNoRGVmLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgPyBuZXcgU2tpbm5lZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKSA6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgaWYgKG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCkge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZUZhbkRyYXdNb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX1NUUklQKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX0xPT1ApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVMb29wKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5QT0lOVFMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IFBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFByaW1pdGl2ZSBtb2RlIHVuc3VwcG9ydGVkOiBcIiArIHByaW1pdGl2ZS5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZik7XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobWVzaERlZi5uYW1lIHx8IFwibWVzaF9cIiArIG1lc2hJbmRleCk7XG4gICAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWVzaCwgbWVzaERlZik7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaCwgcHJpbWl0aXZlKTtcbiAgICAgICAgcGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCk7XG4gICAgICAgIG1lc2hlcy5wdXNoKG1lc2gpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWVzaGVzW2ldLCB7XG4gICAgICAgICAgbWVzaGVzOiBtZXNoSW5kZXgsXG4gICAgICAgICAgcHJpbWl0aXZlczogaVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2hlc1swXSwgbWVzaERlZik7XG4gICAgICAgIHJldHVybiBtZXNoZXNbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIGdyb3VwLCBtZXNoRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KGdyb3VwLCB7IG1lc2hlczogbWVzaEluZGV4IH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAuYWRkKG1lc2hlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG4gICAqL1xuICBsb2FkQ2FtZXJhKGNhbWVyYUluZGV4KSB7XG4gICAgbGV0IGNhbWVyYTtcbiAgICBjb25zdCBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1tjYW1lcmFJbmRleF07XG4gICAgY29uc3QgcGFyYW1zID0gY2FtZXJhRGVmW2NhbWVyYURlZi50eXBlXTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJwZXJzcGVjdGl2ZVwiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoXG4gICAgICAgIE1hdGhVdGlscy5yYWRUb0RlZyhwYXJhbXMueWZvdiksXG4gICAgICAgIHBhcmFtcy5hc3BlY3RSYXRpbyB8fCAxLFxuICAgICAgICBwYXJhbXMuem5lYXIgfHwgMSxcbiAgICAgICAgcGFyYW1zLnpmYXIgfHwgMmU2XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwib3J0aG9ncmFwaGljXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLXBhcmFtcy54bWFnLCBwYXJhbXMueG1hZywgcGFyYW1zLnltYWcsIC1wYXJhbXMueW1hZywgcGFyYW1zLnpuZWFyLCBwYXJhbXMuemZhcik7XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYubmFtZSlcbiAgICAgIGNhbWVyYS5uYW1lID0gdGhpcy5jcmVhdGVVbmlxdWVOYW1lKGNhbWVyYURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGNhbWVyYSwgY2FtZXJhRGVmKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNza2luc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2tpbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U2tlbGV0b24+fVxuICAgKi9cbiAgbG9hZFNraW4oc2tpbkluZGV4KSB7XG4gICAgY29uc3Qgc2tpbkRlZiA9IHRoaXMuanNvbi5za2luc1tza2luSW5kZXhdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBza2luRGVmLmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5fbG9hZE5vZGVTaGFsbG93KHNraW5EZWYuam9pbnRzW2ldKSk7XG4gICAgfVxuICAgIGlmIChza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IGludmVyc2VCaW5kTWF0cmljZXMgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3Qgam9pbnROb2RlcyA9IHJlc3VsdHM7XG4gICAgICBjb25zdCBib25lcyA9IFtdO1xuICAgICAgY29uc3QgYm9uZUludmVyc2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludE5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgam9pbnROb2RlID0gam9pbnROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGpvaW50Tm9kZSkge1xuICAgICAgICAgIGJvbmVzLnB1c2goam9pbnROb2RlKTtcbiAgICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICAgIGlmIChpbnZlcnNlQmluZE1hdHJpY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXQuZnJvbUFycmF5KGludmVyc2VCaW5kTWF0cmljZXMuYXJyYXksIGkgKiAxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVJbnZlcnNlcy5wdXNoKG1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBKb2ludCBcIiVzXCIgY291bGQgbm90IGJlIGZvdW5kLicsIHNraW5EZWYuam9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTa2VsZXRvbihib25lcywgYm9uZUludmVyc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2FuaW1hdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QW5pbWF0aW9uQ2xpcD59XG4gICAqL1xuICBsb2FkQW5pbWF0aW9uKGFuaW1hdGlvbkluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbYW5pbWF0aW9uSW5kZXhdO1xuICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25EZWYubmFtZSA/IGFuaW1hdGlvbkRlZi5uYW1lIDogXCJhbmltYXRpb25fXCIgKyBhbmltYXRpb25JbmRleDtcbiAgICBjb25zdCBwZW5kaW5nTm9kZXMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1NhbXBsZXJzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1RhcmdldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVsc1tpXTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBhbmltYXRpb25EZWYuc2FtcGxlcnNbY2hhbm5lbC5zYW1wbGVyXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoYW5uZWwudGFyZ2V0O1xuICAgICAgY29uc3QgbmFtZSA9IHRhcmdldC5ub2RlO1xuICAgICAgY29uc3QgaW5wdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5pbnB1dF0gOiBzYW1wbGVyLmlucHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIub3V0cHV0XSA6IHNhbXBsZXIub3V0cHV0O1xuICAgICAgaWYgKHRhcmdldC5ub2RlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcGVuZGluZ05vZGVzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBuYW1lKSk7XG4gICAgICBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBpbnB1dCkpO1xuICAgICAgcGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIG91dHB1dCkpO1xuICAgICAgcGVuZGluZ1NhbXBsZXJzLnB1c2goc2FtcGxlcik7XG4gICAgICBwZW5kaW5nVGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nTm9kZXMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ0lucHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1NhbXBsZXJzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdUYXJnZXRzKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBub2RlcyA9IGRlcGVuZGVuY2llc1swXTtcbiAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzFdO1xuICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzJdO1xuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBkZXBlbmRlbmNpZXNbM107XG4gICAgICBjb25zdCB0YXJnZXRzID0gZGVwZW5kZW5jaWVzWzRdO1xuICAgICAgY29uc3QgdHJhY2tzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvciA9IGlucHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW2ldO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICBsZXQgVHlwZWRLZXlmcmFtZVRyYWNrO1xuICAgICAgICBzd2l0Y2ggKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0pIHtcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5zY2FsZTpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSBub2RlLm5hbWUgPyBub2RlLm5hbWUgOiBub2RlLnV1aWQ7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBzYW1wbGVyLmludGVycG9sYXRpb24gIT09IHZvaWQgMCA/IElOVEVSUE9MQVRJT05bc2FtcGxlci5pbnRlcnBvbGF0aW9uXSA6IEludGVycG9sYXRlTGluZWFyO1xuICAgICAgICBjb25zdCB0YXJnZXROYW1lcyA9IFtdO1xuICAgICAgICBpZiAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMpIHtcbiAgICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0TmFtZXMucHVzaChvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2godGFyZ2V0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dEFycmF5ID0gb3V0cHV0QWNjZXNzb3IuYXJyYXk7XG4gICAgICAgIGlmIChvdXRwdXRBY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUob3V0cHV0QXJyYXkuY29uc3RydWN0b3IpO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICBzY2FsZWRbal0gPSBvdXRwdXRBcnJheVtqXSAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRBcnJheSA9IHNjYWxlZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKFxuICAgICAgICAgICAgdGFyZ2V0TmFtZXNbal0gKyBcIi5cIiArIFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0sXG4gICAgICAgICAgICBpbnB1dEFjY2Vzc29yLmFycmF5LFxuICAgICAgICAgICAgb3V0cHV0QXJyYXksXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSBcIkNVQklDU1BMSU5FXCIpIHtcbiAgICAgICAgICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKHJlc3VsdCkge1xuICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGFudFR5cGUgPSB0aGlzIGluc3RhbmNlb2YgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgOiBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2tzLnB1c2godHJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoYW5pbWF0aW9uTmFtZSwgdm9pZCAwLCB0cmFja3MpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlRGVmLm1lc2ggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm1lc2hcIiwgbm9kZURlZi5tZXNoKS50aGVuKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoLCBtZXNoKTtcbiAgICAgIGlmIChub2RlRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIW8uaXNNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICBvLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG5vZGVEZWYud2VpZ2h0c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNub2Rlcy1hbmQtaGllcmFyY2h5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59XG4gICAqL1xuICBsb2FkTm9kZShub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlUGVuZGluZyA9IHBhcnNlci5fbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCk7XG4gICAgY29uc3QgY2hpbGRQZW5kaW5nID0gW107XG4gICAgY29uc3QgY2hpbGRyZW5EZWYgPSBub2RlRGVmLmNoaWxkcmVuIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuRGVmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNoaWxkUGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBjaGlsZHJlbkRlZltpXSkpO1xuICAgIH1cbiAgICBjb25zdCBza2VsZXRvblBlbmRpbmcgPSBub2RlRGVmLnNraW4gPT09IHZvaWQgMCA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHBhcnNlci5nZXREZXBlbmRlbmN5KFwic2tpblwiLCBub2RlRGVmLnNraW4pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbbm9kZVBlbmRpbmcsIFByb21pc2UuYWxsKGNoaWxkUGVuZGluZyksIHNrZWxldG9uUGVuZGluZ10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3Qgbm9kZSA9IHJlc3VsdHNbMF07XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHJlc3VsdHNbMV07XG4gICAgICBjb25zdCBza2VsZXRvbiA9IHJlc3VsdHNbMl07XG4gICAgICBpZiAoc2tlbGV0b24gIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihtZXNoKSB7XG4gICAgICAgICAgaWYgKCFtZXNoLmlzU2tpbm5lZE1lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgbWVzaC5iaW5kKHNrZWxldG9uLCBfaWRlbnRpdHlNYXRyaXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZS5hZGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLy8gLl9sb2FkTm9kZVNoYWxsb3coKSBwYXJzZXMgYSBzaW5nbGUgbm9kZS5cbiAgLy8gc2tpbiBhbmQgY2hpbGQgbm9kZXMgYXJlIGNyZWF0ZWQgYW5kIGFkZGVkIGluIC5sb2FkTm9kZSgpIChubyAnXycgcHJlZml4KS5cbiAgX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBpZiAodGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGVEZWYubmFtZSA/IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG5vZGVEZWYubmFtZSkgOiBcIlwiO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBtZXNoUHJvbWlzZSA9IHBhcnNlci5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlTWVzaCAmJiBleHQuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAobWVzaFByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChtZXNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiY2FtZXJhXCIsIG5vZGVEZWYuY2FtZXJhKS50aGVuKGZ1bmN0aW9uKGNhbWVyYSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSwgY2FtZXJhKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCAmJiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwcm9taXNlKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdID0gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmIChub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlID0gbmV3IEJvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgR3JvdXAoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbm9kZSA9IG9iamVjdHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IE9iamVjdDNEKCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAhPT0gb2JqZWN0c1swXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBub2RlLmFkZChvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYubmFtZSkge1xuICAgICAgICBub2RlLnVzZXJEYXRhLm5hbWUgPSBub2RlRGVmLm5hbWU7XG4gICAgICAgIG5vZGUubmFtZSA9IG5vZGVOYW1lO1xuICAgICAgfVxuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLm1hdHJpeCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIG1hdHJpeC5mcm9tQXJyYXkobm9kZURlZi5tYXRyaXgpO1xuICAgICAgICBub2RlLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGVEZWYudHJhbnNsYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucG9zaXRpb24uZnJvbUFycmF5KG5vZGVEZWYudHJhbnNsYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KG5vZGVEZWYucm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnNjYWxlLmZyb21BcnJheShub2RlRGVmLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZXIuYXNzb2NpYXRpb25zLmhhcyhub2RlKSkge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChub2RlLCB7fSk7XG4gICAgICB9XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlKS5ub2RlcyA9IG5vZGVJbmRleDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2NlbmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2VuZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXA+fVxuICAgKi9cbiAgbG9hZFNjZW5lKHNjZW5lSW5kZXgpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHNjZW5lRGVmID0gdGhpcy5qc29uLnNjZW5lc1tzY2VuZUluZGV4XTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IEdyb3VwKCk7XG4gICAgaWYgKHNjZW5lRGVmLm5hbWUpXG4gICAgICBzY2VuZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoc2NlbmVEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGlmIChzY2VuZURlZi5leHRlbnNpb25zKVxuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZik7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbm9kZUlkc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBzY2VuZS5hZGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVkdWNlQXNzb2NpYXRpb25zID0gKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVkdWNlZEFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcnNlci5hc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgTWF0ZXJpYWwgfHwga2V5IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUudHJhdmVyc2UoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlMik7XG4gICAgICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KG5vZGUyLCBtYXBwaW5ncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRBc3NvY2lhdGlvbnM7XG4gICAgICB9O1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucyA9IHJlZHVjZUFzc29jaWF0aW9ucyhzY2VuZSk7XG4gICAgICByZXR1cm4gc2NlbmU7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgYm94ID0gbmV3IEJveDMoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW2F0dHJpYnV0ZXMuUE9TSVRJT05dO1xuICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICBib3guc2V0KG5ldyBWZWN0b3IzKG1pblswXSwgbWluWzFdLCBtaW5bMl0pLCBuZXcgVmVjdG9yMyhtYXhbMF0sIG1heFsxXSwgbWF4WzJdKSk7XG4gICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICBib3gubWluLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgYm94Lm1heC5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gcHJpbWl0aXZlRGVmLnRhcmdldHM7XG4gIGlmICh0YXJnZXRzICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBtYXhEaXNwbGFjZW1lbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW3RhcmdldC5QT1NJVElPTl07XG4gICAgICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgICAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WChNYXRoLm1heChNYXRoLmFicyhtaW5bMF0pLCBNYXRoLmFicyhtYXhbMF0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFkoTWF0aC5tYXgoTWF0aC5hYnMobWluWzFdKSwgTWF0aC5hYnMobWF4WzFdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRaKE1hdGgubWF4KE1hdGguYWJzKG1pblsyXSksIE1hdGguYWJzKG1heFsyXSkpKTtcbiAgICAgICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1heERpc3BsYWNlbWVudC5tYXgodmVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJveC5leHBhbmRCeVZlY3RvcihtYXhEaXNwbGFjZW1lbnQpO1xuICB9XG4gIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gYm94O1xuICBjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gIGJveC5nZXRDZW50ZXIoc3BoZXJlLmNlbnRlcik7XG4gIHNwaGVyZS5yYWRpdXMgPSBib3gubWluLmRpc3RhbmNlVG8oYm94Lm1heCkgLyAyO1xuICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IHNwaGVyZTtcbn1cbmZ1bmN0aW9uIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgcGVuZGluZyA9IFtdO1xuICBmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhY2Nlc3NvckluZGV4LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYWNjZXNzb3JJbmRleCkudGhlbihmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGdsdGZBdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2dsdGZBdHRyaWJ1dGVOYW1lXSB8fCBnbHRmQXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aHJlZUF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcylcbiAgICAgIGNvbnRpbnVlO1xuICAgIHBlbmRpbmcucHVzaChhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhdHRyaWJ1dGVzW2dsdGZBdHRyaWJ1dGVOYW1lXSwgdGhyZWVBdHRyaWJ1dGVOYW1lKSk7XG4gIH1cbiAgaWYgKHByaW1pdGl2ZURlZi5pbmRpY2VzICE9PSB2b2lkIDAgJiYgIWdlb21ldHJ5LmluZGV4KSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHByaW1pdGl2ZURlZi5pbmRpY2VzKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yMikge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoYWNjZXNzb3IyKTtcbiAgICB9KTtcbiAgICBwZW5kaW5nLnB1c2goYWNjZXNzb3IpO1xuICB9XG4gIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoZ2VvbWV0cnksIHByaW1pdGl2ZURlZik7XG4gIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB2b2lkIDAgPyBhZGRNb3JwaFRhcmdldHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIpIDogZ2VvbWV0cnk7XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgR0xURkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMVEZMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiTG9hZGVyIiwiTG9hZGVyVXRpbHMiLCJGaWxlTG9hZGVyIiwiQ29sb3IiLCJTcG90TGlnaHQiLCJQb2ludExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJWZWN0b3IyIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiSW5zdGFuY2VkTWVzaCIsIk9iamVjdDNEIiwiVGV4dHVyZUxvYWRlciIsIkltYWdlQml0bWFwTG9hZGVyIiwiQnVmZmVyQXR0cmlidXRlIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIkxpbmVhckZpbHRlciIsIkxpbmVhck1pcG1hcExpbmVhckZpbHRlciIsIlJlcGVhdFdyYXBwaW5nIiwiUG9pbnRzTWF0ZXJpYWwiLCJNYXRlcmlhbCIsIkxpbmVCYXNpY01hdGVyaWFsIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJEb3VibGVTaWRlIiwiUHJvcGVydHlCaW5kaW5nIiwiQnVmZmVyR2VvbWV0cnkiLCJTa2lubmVkTWVzaCIsIk1lc2giLCJUcmlhbmdsZVN0cmlwRHJhd01vZGUiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiTGluZVNlZ21lbnRzIiwiTGluZSIsIkxpbmVMb29wIiwiUG9pbnRzIiwiR3JvdXAiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIk1hdGhVdGlscyIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlNrZWxldG9uIiwiSW50ZXJwb2xhdGVMaW5lYXIiLCJBbmltYXRpb25DbGlwIiwiQm9uZSIsIk5lYXJlc3RGaWx0ZXIiLCJOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciIsIkxpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIiLCJOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIiwiQ2xhbXBUb0VkZ2VXcmFwcGluZyIsIk1pcnJvcmVkUmVwZWF0V3JhcHBpbmciLCJJbnRlcnBvbGF0ZURpc2NyZXRlIiwiRnJvbnRTaWRlIiwiVGV4dHVyZSIsIlZlY3RvcktleWZyYW1lVHJhY2siLCJRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayIsIk51bWJlcktleWZyYW1lVHJhY2siLCJCb3gzIiwiU3BoZXJlIiwiSW50ZXJwb2xhbnQiLCJ0b1RyaWFuZ2xlc0RyYXdNb2RlIiwidmVyc2lvbiIsIkdMVEZMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJkcmFjb0xvYWRlciIsImt0eDJMb2FkZXIiLCJtZXNob3B0RGVjb2RlciIsInBsdWdpbkNhbGxiYWNrcyIsInJlZ2lzdGVyIiwicGFyc2VyIiwiR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIiwiR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uIiwiR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbiIsIkdMVEZMaWdodHNFeHRlbnNpb24iLCJHTFRGTWVzaG9wdENvbXByZXNzaW9uIiwiR0xURk1lc2hHcHVJbnN0YW5jaW5nIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwic2NvcGUiLCJyZXNvdXJjZVBhdGgiLCJwYXRoIiwiZXh0cmFjdFVybEJhc2UiLCJpdGVtU3RhcnQiLCJfb25FcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJpdGVtRXJyb3IiLCJpdGVtRW5kIiwibG9hZGVyIiwic2V0UGF0aCIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiZGF0YSIsInBhcnNlIiwiZ2x0ZiIsInNldERSQUNPTG9hZGVyIiwic2V0RERTTG9hZGVyIiwiRXJyb3IiLCJzZXRLVFgyTG9hZGVyIiwic2V0TWVzaG9wdERlY29kZXIiLCJjYWxsYmFjayIsImluZGV4T2YiLCJwdXNoIiwidW5yZWdpc3RlciIsInNwbGljZSIsImpzb24iLCJleHRlbnNpb25zIiwicGx1Z2lucyIsIkpTT04iLCJBcnJheUJ1ZmZlciIsIm1hZ2ljIiwiZGVjb2RlVGV4dCIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDIiwiRVhURU5TSU9OUyIsIktIUl9CSU5BUllfR0xURiIsIkdMVEZCaW5hcnlFeHRlbnNpb24iLCJjb250ZW50IiwiYXNzZXQiLCJHTFRGUGFyc2VyIiwiY3Jvc3NPcmlnaW4iLCJmaWxlTG9hZGVyIiwiaSIsImxlbmd0aCIsInBsdWdpbiIsIm5hbWUiLCJleHRlbnNpb25zVXNlZCIsImV4dGVuc2lvbk5hbWUiLCJleHRlbnNpb25zUmVxdWlyZWQiLCJLSFJfTUFURVJJQUxTX1VOTElUIiwiR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uIiwiS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04iLCJHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24iLCJLSFJfVEVYVFVSRV9UUkFOU0ZPUk0iLCJHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiIsIktIUl9NRVNIX1FVQU5USVpBVElPTiIsIkdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIiwid2FybiIsInNldEV4dGVuc2lvbnMiLCJzZXRQbHVnaW5zIiwicGFyc2VBc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiR0xURlJlZ2lzdHJ5Iiwib2JqZWN0cyIsImdldCIsImtleSIsImFkZCIsIm9iamVjdCIsInJlbW92ZSIsInJlbW92ZUFsbCIsIktIUl9MSUdIVFNfUFVOQ1RVQUwiLCJLSFJfTUFURVJJQUxTX0NMRUFSQ09BVCIsIktIUl9NQVRFUklBTFNfSU9SIiwiS0hSX01BVEVSSUFMU19TSEVFTiIsIktIUl9NQVRFUklBTFNfU1BFQ1VMQVIiLCJLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTiIsIktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0UiLCJLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFkiLCJLSFJfTUFURVJJQUxTX1ZPTFVNRSIsIktIUl9URVhUVVJFX0JBU0lTVSIsIktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEgiLCJFWFRfVEVYVFVSRV9XRUJQIiwiRVhUX1RFWFRVUkVfQVZJRiIsIkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OIiwiRVhUX01FU0hfR1BVX0lOU1RBTkNJTkciLCJjYWNoZSIsInJlZnMiLCJ1c2VzIiwiX21hcmtEZWZzIiwibm9kZURlZnMiLCJub2RlcyIsIm5vZGVJbmRleCIsIm5vZGVMZW5ndGgiLCJub2RlRGVmIiwibGlnaHQiLCJfYWRkTm9kZVJlZiIsIl9sb2FkTGlnaHQiLCJsaWdodEluZGV4IiwiY2FjaGVLZXkiLCJkZXBlbmRlbmN5IiwibGlnaHREZWZzIiwibGlnaHRzIiwibGlnaHREZWYiLCJsaWdodE5vZGUiLCJjb2xvciIsImZyb21BcnJheSIsInJhbmdlIiwidHlwZSIsInRhcmdldCIsInBvc2l0aW9uIiwic2V0IiwiZGlzdGFuY2UiLCJzcG90IiwiaW5uZXJDb25lQW5nbGUiLCJvdXRlckNvbmVBbmdsZSIsIk1hdGgiLCJQSSIsImFuZ2xlIiwicGVudW1icmEiLCJkZWNheSIsImFzc2lnbkV4dHJhc1RvVXNlckRhdGEiLCJpbnRlbnNpdHkiLCJjcmVhdGVVbmlxdWVOYW1lIiwiZ2V0RGVwZW5kZW5jeSIsImluZGV4IiwiY3JlYXRlTm9kZUF0dGFjaG1lbnQiLCJzZWxmMiIsInRoZW4iLCJfZ2V0Tm9kZVJlZiIsImdldE1hdGVyaWFsVHlwZSIsImV4dGVuZFBhcmFtcyIsIm1hdGVyaWFsUGFyYW1zIiwibWF0ZXJpYWxEZWYiLCJwZW5kaW5nIiwib3BhY2l0eSIsIm1ldGFsbGljUm91Z2huZXNzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiLCJBcnJheSIsImlzQXJyYXkiLCJiYXNlQ29sb3JGYWN0b3IiLCJhcnJheSIsImJhc2VDb2xvclRleHR1cmUiLCJhc3NpZ25UZXh0dXJlIiwiYWxsIiwiZXh0ZW5kTWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbEluZGV4IiwibWF0ZXJpYWxzIiwiZW1pc3NpdmVTdHJlbmd0aCIsImVtaXNzaXZlSW50ZW5zaXR5IiwiZXh0ZW5zaW9uIiwiY2xlYXJjb2F0RmFjdG9yIiwiY2xlYXJjb2F0IiwiY2xlYXJjb2F0VGV4dHVyZSIsImNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciIsImNsZWFyY29hdFJvdWdobmVzcyIsImNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUiLCJjbGVhcmNvYXROb3JtYWxUZXh0dXJlIiwic2NhbGUiLCJjbGVhcmNvYXROb3JtYWxTY2FsZSIsImlyaWRlc2NlbmNlRmFjdG9yIiwiaXJpZGVzY2VuY2UiLCJpcmlkZXNjZW5jZVRleHR1cmUiLCJpcmlkZXNjZW5jZUlvciIsImlyaWRlc2NlbmNlSU9SIiwiaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsInNoZWVuQ29sb3IiLCJzaGVlblJvdWdobmVzcyIsInNoZWVuIiwic2hlZW5Db2xvckZhY3RvciIsInNoZWVuUm91Z2huZXNzRmFjdG9yIiwic2hlZW5Db2xvclRleHR1cmUiLCJzaGVlblJvdWdobmVzc1RleHR1cmUiLCJ0cmFuc21pc3Npb25GYWN0b3IiLCJ0cmFuc21pc3Npb24iLCJ0cmFuc21pc3Npb25UZXh0dXJlIiwidGhpY2tuZXNzIiwidGhpY2tuZXNzRmFjdG9yIiwidGhpY2tuZXNzVGV4dHVyZSIsImF0dGVudWF0aW9uRGlzdGFuY2UiLCJJbmZpbml0eSIsImNvbG9yQXJyYXkiLCJhdHRlbnVhdGlvbkNvbG9yIiwiaW9yIiwic3BlY3VsYXJJbnRlbnNpdHkiLCJzcGVjdWxhckZhY3RvciIsInNwZWN1bGFyVGV4dHVyZSIsInNwZWN1bGFyQ29sb3JGYWN0b3IiLCJzcGVjdWxhckNvbG9yIiwic3BlY3VsYXJDb2xvclRleHR1cmUiLCJhbmlzb3Ryb3B5U3RyZW5ndGgiLCJhbmlzb3Ryb3B5IiwiYW5pc290cm9weVJvdGF0aW9uIiwiYW5pc290cm9weVRleHR1cmUiLCJsb2FkVGV4dHVyZSIsInRleHR1cmVJbmRleCIsInRleHR1cmVEZWYiLCJ0ZXh0dXJlcyIsIm9wdGlvbnMiLCJsb2FkVGV4dHVyZUltYWdlIiwic291cmNlIiwiaXNTdXBwb3J0ZWQiLCJpbWFnZXMiLCJ0ZXh0dXJlTG9hZGVyIiwidXJpIiwiaGFuZGxlciIsImdldEhhbmRsZXIiLCJkZXRlY3RTdXBwb3J0IiwiaW1hZ2UiLCJJbWFnZSIsInNyYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJoZWlnaHQiLCJsb2FkQnVmZmVyVmlldyIsImJ1ZmZlclZpZXciLCJidWZmZXJWaWV3cyIsImV4dGVuc2lvbkRlZiIsImJ1ZmZlciIsImRlY29kZXIiLCJzdXBwb3J0ZWQiLCJyZXMiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImNvdW50Iiwic3RyaWRlIiwiYnl0ZVN0cmlkZSIsImRlY29kZUdsdGZCdWZmZXJBc3luYyIsIm1vZGUiLCJmaWx0ZXIiLCJyZXMyIiwicmVhZHkiLCJyZXN1bHQiLCJkZWNvZGVHbHRmQnVmZmVyIiwiY3JlYXRlTm9kZU1lc2giLCJtZXNoIiwibWVzaERlZiIsIm1lc2hlcyIsInByaW1pdGl2ZSIsInByaW1pdGl2ZXMiLCJXRUJHTF9DT05TVEFOVFMiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIlRSSUFOR0xFX0ZBTiIsImF0dHJpYnV0ZXNEZWYiLCJhdHRyaWJ1dGVzIiwiYWNjZXNzb3IiLCJyZXN1bHRzIiwibm9kZU9iamVjdCIsInBvcCIsImlzR3JvdXAiLCJjaGlsZHJlbiIsImluc3RhbmNlZE1lc2hlcyIsIm0iLCJwIiwicSIsInMiLCJpbnN0YW5jZWRNZXNoIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsIlRSQU5TTEFUSU9OIiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIlJPVEFUSU9OIiwiU0NBTEUiLCJzZXRNYXRyaXhBdCIsImNvbXBvc2UiLCJhdHRyaWJ1dGVOYW1lIiwic2V0QXR0cmlidXRlIiwicHJvdG90eXBlIiwiY29weSIsImNhbGwiLCJhc3NpZ25GaW5hbE1hdGVyaWFsIiwiY2xlYXIiLCJCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgiLCJCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTIiwiQklOIiwiYm9keSIsImhlYWRlclZpZXciLCJEYXRhVmlldyIsImhlYWRlciIsImdldFVpbnQzMiIsImNodW5rQ29udGVudHNMZW5ndGgiLCJjaHVua1ZpZXciLCJjaHVua0luZGV4IiwiY2h1bmtMZW5ndGgiLCJjaHVua1R5cGUiLCJjb250ZW50QXJyYXkiLCJwcmVsb2FkIiwiZGVjb2RlUHJpbWl0aXZlIiwiYnVmZmVyVmlld0luZGV4IiwiZ2x0ZkF0dHJpYnV0ZU1hcCIsInRocmVlQXR0cmlidXRlTWFwIiwiYXR0cmlidXRlTm9ybWFsaXplZE1hcCIsImF0dHJpYnV0ZVR5cGVNYXAiLCJ0aHJlZUF0dHJpYnV0ZU5hbWUiLCJBVFRSSUJVVEVTIiwidG9Mb3dlckNhc2UiLCJhY2Nlc3NvckRlZiIsImFjY2Vzc29ycyIsImNvbXBvbmVudFR5cGUiLCJXRUJHTF9DT01QT05FTlRfVFlQRVMiLCJub3JtYWxpemVkIiwiZGVjb2RlRHJhY29GaWxlIiwiYXR0cmlidXRlIiwiZXh0ZW5kVGV4dHVyZSIsInRleHR1cmUiLCJ0cmFuc2Zvcm0iLCJ0ZXhDb29yZCIsImNoYW5uZWwiLCJvZmZzZXQiLCJyb3RhdGlvbiIsImNsb25lIiwicmVwZWF0IiwibmVlZHNVcGRhdGUiLCJHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCIsInBhcmFtZXRlclBvc2l0aW9ucyIsInNhbXBsZVZhbHVlcyIsInNhbXBsZVNpemUiLCJyZXN1bHRCdWZmZXIiLCJjb3B5U2FtcGxlVmFsdWVfIiwidmFsdWVzIiwidmFsdWVTaXplIiwiaW50ZXJwb2xhdGVfIiwiaTEiLCJ0MCIsInQiLCJ0MSIsInN0cmlkZTIiLCJzdHJpZGUzIiwidGQiLCJwcCIsInBwcCIsIm9mZnNldDEiLCJvZmZzZXQwIiwiczIiLCJzMyIsInMwIiwiczEiLCJwMCIsIm0wIiwicDEiLCJtMSIsIl9xIiwiR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50Iiwibm9ybWFsaXplIiwidG9BcnJheSIsIkZMT0FUIiwiRkxPQVRfTUFUMyIsIkZMT0FUX01BVDQiLCJGTE9BVF9WRUMyIiwiRkxPQVRfVkVDMyIsIkZMT0FUX1ZFQzQiLCJMSU5FQVIiLCJSRVBFQVQiLCJTQU1QTEVSXzJEIiwiUE9JTlRTIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJXRUJHTF9GSUxURVJTIiwiV0VCR0xfV1JBUFBJTkdTIiwiV0VCR0xfVFlQRV9TSVpFUyIsIlNDQUxBUiIsIlZFQzIiLCJWRUMzIiwiVkVDNCIsIk1BVDIiLCJNQVQzIiwiTUFUNCIsIlBPU0lUSU9OIiwiTk9STUFMIiwiVEFOR0VOVCIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiVEVYQ09PUkRfMiIsIlRFWENPT1JEXzMiLCJDT0xPUl8wIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJQQVRIX1BST1BFUlRJRVMiLCJ0cmFuc2xhdGlvbiIsIndlaWdodHMiLCJJTlRFUlBPTEFUSU9OIiwiQ1VCSUNTUExJTkUiLCJTVEVQIiwiQUxQSEFfTU9ERVMiLCJPUEFRVUUiLCJNQVNLIiwiQkxFTkQiLCJjcmVhdGVEZWZhdWx0TWF0ZXJpYWwiLCJlbWlzc2l2ZSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zcGFyZW50IiwiZGVwdGhUZXN0Iiwic2lkZSIsImFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSIsImtub3duRXh0ZW5zaW9ucyIsIm9iamVjdERlZiIsInVzZXJEYXRhIiwiZ2x0ZkV4dGVuc2lvbnMiLCJnbHRmRGVmIiwiZXh0cmFzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkTW9ycGhUYXJnZXRzIiwidGFyZ2V0cyIsImhhc01vcnBoUG9zaXRpb24iLCJoYXNNb3JwaE5vcm1hbCIsImhhc01vcnBoQ29sb3IiLCJpbCIsInBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyIsInBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMiLCJwZW5kaW5nQ29sb3JBY2Nlc3NvcnMiLCJwZW5kaW5nQWNjZXNzb3IiLCJub3JtYWwiLCJtb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIm1vcnBoQ29sb3JzIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJ1cGRhdGVNb3JwaFRhcmdldHMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJ0YXJnZXROYW1lcyIsIm1vcnBoVGFyZ2V0RGljdGlvbmFyeSIsImNyZWF0ZVByaW1pdGl2ZUtleSIsInByaW1pdGl2ZURlZiIsImdlb21ldHJ5S2V5IiwiZHJhY29FeHRlbnNpb24iLCJpbmRpY2VzIiwiY3JlYXRlQXR0cmlidXRlc0tleSIsImF0dHJpYnV0ZXNLZXkiLCJrZXlzIiwic29ydCIsImdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSIsImdldEltYWdlVVJJTWltZVR5cGUiLCJzZWFyY2giLCJfaWRlbnRpdHlNYXRyaXgiLCJhc3NvY2lhdGlvbnMiLCJNYXAiLCJwcmltaXRpdmVDYWNoZSIsIm5vZGVDYWNoZSIsIm1lc2hDYWNoZSIsImNhbWVyYUNhY2hlIiwibGlnaHRDYWNoZSIsInNvdXJjZUNhY2hlIiwidGV4dHVyZUNhY2hlIiwibm9kZU5hbWVzVXNlZCIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiZmlyZWZveFZlcnNpb24iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0ZXN0IiwibWF0Y2giLCJjcmVhdGVJbWFnZUJpdG1hcCIsInNldENyb3NzT3JpZ2luIiwiX2ludm9rZUFsbCIsImV4dCIsImJlZm9yZVJvb3QiLCJnZXREZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJzY2VuZSIsInNjZW5lcyIsImFuaW1hdGlvbnMiLCJjYW1lcmFzIiwiYWZ0ZXJSb290IiwiY2F0Y2giLCJza2luRGVmcyIsInNraW5zIiwibWVzaERlZnMiLCJza2luSW5kZXgiLCJza2luTGVuZ3RoIiwiam9pbnRzIiwiaXNCb25lIiwic2tpbiIsImlzU2tpbm5lZE1lc2giLCJjYW1lcmEiLCJyZWYiLCJ1cGRhdGVNYXBwaW5ncyIsIm9yaWdpbmFsIiwibWFwcGluZ3MiLCJjaGlsZCIsImVudHJpZXMiLCJfaW52b2tlT25lIiwiZnVuYyIsInVuc2hpZnQiLCJsb2FkU2NlbmUiLCJsb2FkTm9kZSIsImxvYWRNZXNoIiwibG9hZEFjY2Vzc29yIiwibG9hZEJ1ZmZlciIsImxvYWRNYXRlcmlhbCIsImxvYWRTa2luIiwibG9hZEFuaW1hdGlvbiIsImxvYWRDYW1lcmEiLCJkZWZzIiwibWFwIiwiZGVmIiwiYnVmZmVySW5kZXgiLCJidWZmZXJEZWYiLCJidWZmZXJzIiwicmVzb2x2ZVVSTCIsImJ1ZmZlclZpZXdEZWYiLCJhY2Nlc3NvckluZGV4Iiwic3BhcnNlIiwiaXRlbVNpemUiLCJUeXBlZEFycmF5IiwicGVuZGluZ0J1ZmZlclZpZXdzIiwiZWxlbWVudEJ5dGVzIiwiQllURVNfUEVSX0VMRU1FTlQiLCJpdGVtQnl0ZXMiLCJidWZmZXJBdHRyaWJ1dGUiLCJpYlNsaWNlIiwiZmxvb3IiLCJpYkNhY2hlS2V5IiwiaWIiLCJpdGVtU2l6ZUluZGljZXMiLCJUeXBlZEFycmF5SW5kaWNlcyIsImJ5dGVPZmZzZXRJbmRpY2VzIiwiYnl0ZU9mZnNldFZhbHVlcyIsInNwYXJzZUluZGljZXMiLCJzcGFyc2VWYWx1ZXMiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwic291cmNlSW5kZXgiLCJzb3VyY2VEZWYiLCJzYW1wbGVyIiwicHJvbWlzZSIsImxvYWRJbWFnZVNvdXJjZSIsImZsaXBZIiwic3RhcnRzV2l0aCIsInNhbXBsZXJzIiwibWFnRmlsdGVyIiwibWluRmlsdGVyIiwid3JhcFMiLCJ3cmFwVCIsIlVSTCIsInNlbGYiLCJ3ZWJraXRVUkwiLCJzb3VyY2VVUkkiLCJpc09iamVjdFVSTCIsImJsb2IiLCJCbG9iIiwibWltZVR5cGUiLCJjcmVhdGVPYmplY3RVUkwiLCJzb3VyY2VVUkkyIiwiaXNJbWFnZUJpdG1hcExvYWRlciIsImltYWdlQml0bWFwIiwicmV2b2tlT2JqZWN0VVJMIiwibWFwTmFtZSIsIm1hcERlZiIsImVuY29kaW5nIiwiZ2x0ZlJlZmVyZW5jZSIsImNvbG9yU3BhY2UiLCJ1c2VEZXJpdmF0aXZlVGFuZ2VudHMiLCJ0YW5nZW50IiwidXNlVmVydGV4Q29sb3JzIiwidXNlRmxhdFNoYWRpbmciLCJpc1BvaW50cyIsInV1aWQiLCJwb2ludHNNYXRlcmlhbCIsInNpemVBdHRlbnVhdGlvbiIsImlzTGluZSIsImxpbmVNYXRlcmlhbCIsImNhY2hlZE1hdGVyaWFsIiwidmVydGV4Q29sb3JzIiwiZmxhdFNoYWRpbmciLCJub3JtYWxTY2FsZSIsInkiLCJtYXRlcmlhbFR5cGUiLCJtYXRlcmlhbEV4dGVuc2lvbnMiLCJrbXVFeHRlbnNpb24iLCJtZXRhbGxpY0ZhY3RvciIsInJvdWdobmVzc0ZhY3RvciIsIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsImRvdWJsZVNpZGVkIiwiYWxwaGFNb2RlIiwiZGVwdGhXcml0ZSIsImFscGhhVGVzdCIsImFscGhhQ3V0b2ZmIiwibm9ybWFsVGV4dHVyZSIsIm9jY2x1c2lvblRleHR1cmUiLCJzdHJlbmd0aCIsImFvTWFwSW50ZW5zaXR5IiwiZW1pc3NpdmVGYWN0b3IiLCJlbWlzc2l2ZVRleHR1cmUiLCJvcmlnaW5hbE5hbWUiLCJzYW5pdGl6ZWROYW1lIiwic2FuaXRpemVOb2RlTmFtZSIsImxvYWRHZW9tZXRyaWVzIiwiY3JlYXRlRHJhY29QcmltaXRpdmUiLCJhZGRQcmltaXRpdmVBdHRyaWJ1dGVzIiwiY2FjaGVkIiwiZ2VvbWV0cnlQcm9taXNlIiwibWVzaEluZGV4IiwiZ2VvbWV0cmllcyIsIm5vcm1hbGl6ZVNraW5XZWlnaHRzIiwiZ3JvdXAiLCJjYW1lcmFJbmRleCIsImNhbWVyYURlZiIsInBhcmFtcyIsInJhZFRvRGVnIiwieWZvdiIsImFzcGVjdFJhdGlvIiwiem5lYXIiLCJ6ZmFyIiwieG1hZyIsInltYWciLCJza2luRGVmIiwiX2xvYWROb2RlU2hhbGxvdyIsImludmVyc2VCaW5kTWF0cmljZXMiLCJqb2ludE5vZGVzIiwiYm9uZXMiLCJib25lSW52ZXJzZXMiLCJqb2ludE5vZGUiLCJtYXQiLCJhbmltYXRpb25JbmRleCIsImFuaW1hdGlvbkRlZiIsImFuaW1hdGlvbk5hbWUiLCJwZW5kaW5nTm9kZXMiLCJwZW5kaW5nSW5wdXRBY2Nlc3NvcnMiLCJwZW5kaW5nT3V0cHV0QWNjZXNzb3JzIiwicGVuZGluZ1NhbXBsZXJzIiwicGVuZGluZ1RhcmdldHMiLCJjaGFubmVscyIsIm5vZGUiLCJpbnB1dCIsInBhcmFtZXRlcnMiLCJvdXRwdXQiLCJpbnB1dEFjY2Vzc29ycyIsIm91dHB1dEFjY2Vzc29ycyIsInRyYWNrcyIsImlucHV0QWNjZXNzb3IiLCJvdXRwdXRBY2Nlc3NvciIsInVwZGF0ZU1hdHJpeCIsIlR5cGVkS2V5ZnJhbWVUcmFjayIsInRhcmdldE5hbWUiLCJpbnRlcnBvbGF0aW9uIiwidHJhdmVyc2UiLCJvdXRwdXRBcnJheSIsInNjYWxlZCIsImoiLCJqbCIsInRyYWNrIiwiY3JlYXRlSW50ZXJwb2xhbnQiLCJJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJpbnRlcnBvbGFudFR5cGUiLCJ0aW1lcyIsImdldFZhbHVlU2l6ZSIsImlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lIiwibyIsImlzTWVzaCIsIm5vZGVQZW5kaW5nIiwiY2hpbGRQZW5kaW5nIiwiY2hpbGRyZW5EZWYiLCJza2VsZXRvblBlbmRpbmciLCJza2VsZXRvbiIsImJpbmQiLCJub2RlTmFtZSIsIm1lc2hQcm9taXNlIiwiZm9yRWFjaCIsIm1hdHJpeCIsImFwcGx5TWF0cml4NCIsInF1YXRlcm5pb24iLCJoYXMiLCJzY2VuZUluZGV4Iiwic2NlbmVEZWYiLCJub2RlSWRzIiwicmVkdWNlQXNzb2NpYXRpb25zIiwicmVkdWNlZEFzc29jaWF0aW9ucyIsInZhbHVlIiwibm9kZTIiLCJjb21wdXRlQm91bmRzIiwiYm94IiwibWluIiwibWF4IiwiYm94U2NhbGUiLCJtdWx0aXBseVNjYWxhciIsIm1heERpc3BsYWNlbWVudCIsInZlY3RvciIsImFicyIsImV4cGFuZEJ5VmVjdG9yIiwiYm91bmRpbmdCb3giLCJzcGhlcmUiLCJnZXRDZW50ZXIiLCJjZW50ZXIiLCJyYWRpdXMiLCJkaXN0YW5jZVRvIiwiYm91bmRpbmdTcGhlcmUiLCJhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciIsImdsdGZBdHRyaWJ1dGVOYW1lIiwiYWNjZXNzb3IyIiwic2V0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    console.error(\"THREE.RGBELoader Read Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_write_error:\n                    console.error(\"THREE.RGBELoader Write Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_format_error:\n                    console.error(\"THREE.RGBELoader Bad File Format: \" + (msg || \"\"));\n                    break;\n                default:\n                case rgbe_memory_error:\n                    console.error(\"THREE.RGBELoader: Error: \" + (msg || \"\"));\n            }\n            return RGBE_RETURN_FAILURE;\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                return rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                return rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                return rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {\n            const scanline_width = w;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) {\n                return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    return rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        return rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n            if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n                let data, type;\n                let numElements;\n                switch(this.type){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const floatArray = new Float32Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                        }\n                        data = floatArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const halfArray = new Uint16Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                        }\n                        data = halfArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                        break;\n                    default:\n                        console.error(\"THREE.RGBELoader: unsupported type: \", this.type);\n                        break;\n                }\n                return {\n                    width: w,\n                    height: h,\n                    data,\n                    header: rgbe_header_info.string,\n                    gamma: rgbe_header_info.gamma,\n                    exposure: rgbe_header_info.exposure,\n                    type\n                };\n            }\n        }\n        return null;\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL1JHQkVMb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkY7QUFDN0YsTUFBTUssbUJBQW1CTCxvREFBaUJBO0lBQ3hDTSxZQUFZQyxPQUFPLENBQUU7UUFDbkIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHUCxnREFBYUE7SUFDM0I7SUFDQSw4REFBOEQ7SUFDOURRLE1BQU1DLE1BQU0sRUFBRTtRQUNaLE1BQU1DLHNCQUFzQixDQUFDLEdBQUdDLGtCQUFrQixHQUFHQyxtQkFBbUIsR0FBR0Msb0JBQW9CLEdBQUdDLG9CQUFvQixHQUFHQyxhQUFhLFNBQVNDLGVBQWUsRUFBRUMsR0FBRztZQUNqSyxPQUFRRDtnQkFDTixLQUFLTDtvQkFDSE8sUUFBUUMsS0FBSyxDQUFDLGtDQUFtQ0YsQ0FBQUEsT0FBTyxFQUFDO29CQUN6RDtnQkFDRixLQUFLTDtvQkFDSE0sUUFBUUMsS0FBSyxDQUFDLG1DQUFvQ0YsQ0FBQUEsT0FBTyxFQUFDO29CQUMxRDtnQkFDRixLQUFLSjtvQkFDSEssUUFBUUMsS0FBSyxDQUFDLHVDQUF3Q0YsQ0FBQUEsT0FBTyxFQUFDO29CQUM5RDtnQkFDRjtnQkFDQSxLQUFLSDtvQkFDSEksUUFBUUMsS0FBSyxDQUFDLDhCQUErQkYsQ0FBQUEsT0FBTyxFQUFDO1lBQ3pEO1lBQ0EsT0FBT1A7UUFDVCxHQUFHVSx5QkFBeUIsR0FBR0Msb0JBQW9CLEdBQUdDLHdCQUF3QixHQUFHQyxVQUFVLE1BQU1DLFFBQVEsU0FBU0MsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLE9BQU87WUFDM0ksTUFBTUMsWUFBWTtZQUNsQkYsWUFBWSxDQUFDQSxZQUFZLE9BQU9BO1lBQ2hDLElBQUlHLElBQUlKLFFBQVFLLEdBQUcsRUFBRUMsSUFBSSxDQUFDLEdBQUdDLE1BQU0sR0FBR0MsSUFBSSxJQUFJQyxRQUFRQyxP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QXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYm9pbGVycGxhdGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL1JHQkVMb2FkZXIuanM/ZjM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBEYXRhVXRpbHMsIExpbmVhckZpbHRlciB9IGZyb20gXCJ0aHJlZVwiO1xuY2xhc3MgUkdCRUxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZ3JhcGhpY3MuY29ybmVsbC5lZHUvfmJqdy9yZ2JlLmh0bWxcbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgUkdCRV9SRVRVUk5fRkFJTFVSRSA9IC0xLCByZ2JlX3JlYWRfZXJyb3IgPSAxLCByZ2JlX3dyaXRlX2Vycm9yID0gMiwgcmdiZV9mb3JtYXRfZXJyb3IgPSAzLCByZ2JlX21lbW9yeV9lcnJvciA9IDQsIHJnYmVfZXJyb3IgPSBmdW5jdGlvbihyZ2JlX2Vycm9yX2NvZGUsIG1zZykge1xuICAgICAgc3dpdGNoIChyZ2JlX2Vycm9yX2NvZGUpIHtcbiAgICAgICAgY2FzZSByZ2JlX3JlYWRfZXJyb3I6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlJHQkVMb2FkZXIgUmVhZCBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSByZ2JlX3dyaXRlX2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIFdyaXRlIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJnYmVfZm9ybWF0X2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIEJhZCBGaWxlIEZvcm1hdDogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSByZ2JlX21lbW9yeV9lcnJvcjpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUkdCRV9SRVRVUk5fRkFJTFVSRTtcbiAgICB9LCBSR0JFX1ZBTElEX1BST0dSQU1UWVBFID0gMSwgUkdCRV9WQUxJRF9GT1JNQVQgPSAyLCBSR0JFX1ZBTElEX0RJTUVOU0lPTlMgPSA0LCBORVdMSU5FID0gXCJcXG5cIiwgZmdldHMgPSBmdW5jdGlvbihidWZmZXIyLCBsaW5lTGltaXQsIGNvbnN1bWUpIHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEyODtcbiAgICAgIGxpbmVMaW1pdCA9ICFsaW5lTGltaXQgPyAxMDI0IDogbGluZUxpbWl0O1xuICAgICAgbGV0IHAgPSBidWZmZXIyLnBvcywgaSA9IC0xLCBsZW4gPSAwLCBzID0gXCJcIiwgY2h1bmsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSk7XG4gICAgICB3aGlsZSAoMCA+IChpID0gY2h1bmsuaW5kZXhPZihORVdMSU5FKSkgJiYgbGVuIDwgbGluZUxpbWl0ICYmIHAgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcyArPSBjaHVuaztcbiAgICAgICAgbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgcCArPSBjaHVua1NpemU7XG4gICAgICAgIGNodW5rICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjIuc3ViYXJyYXkocCwgcCArIGNodW5rU2l6ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtMSA8IGkpIHtcbiAgICAgICAgaWYgKGZhbHNlICE9PSBjb25zdW1lKVxuICAgICAgICAgIGJ1ZmZlcjIucG9zICs9IGxlbiArIGkgKyAxO1xuICAgICAgICByZXR1cm4gcyArIGNodW5rLnNsaWNlKDAsIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFJHQkVfUmVhZEhlYWRlciA9IGZ1bmN0aW9uKGJ1ZmZlcjIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljX3Rva2VuX3JlID0gL14jXFw/KFxcUyspLywgZ2FtbWFfcmUgPSAvXlxccypHQU1NQVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sIGV4cG9zdXJlX3JlID0gL15cXHMqRVhQT1NVUkVcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLCBmb3JtYXRfcmUgPSAvXlxccypGT1JNQVQ9KFxcUyspXFxzKiQvLCBkaW1lbnNpb25zX3JlID0gL15cXHMqXFwtWVxccysoXFxkKylcXHMrXFwrWFxccysoXFxkKylcXHMqJC8sIGhlYWRlciA9IHtcbiAgICAgICAgdmFsaWQ6IDAsXG4gICAgICAgIHN0cmluZzogXCJcIixcbiAgICAgICAgY29tbWVudHM6IFwiXCIsXG4gICAgICAgIHByb2dyYW10eXBlOiBcIlJHQkVcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBnYW1tYTogMSxcbiAgICAgICAgZXhwb3N1cmU6IDEsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICBsZXQgbGluZSwgbWF0Y2g7XG4gICAgICBpZiAoYnVmZmVyMi5wb3MgPj0gYnVmZmVyMi5ieXRlTGVuZ3RoIHx8ICEobGluZSA9IGZnZXRzKGJ1ZmZlcjIpKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX3JlYWRfZXJyb3IsIFwibm8gaGVhZGVyIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEobWF0Y2ggPSBsaW5lLm1hdGNoKG1hZ2ljX3Rva2VuX3JlKSkpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIGluaXRpYWwgdG9rZW5cIik7XG4gICAgICB9XG4gICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9QUk9HUkFNVFlQRTtcbiAgICAgIGhlYWRlci5wcm9ncmFtdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgaGVhZGVyLnN0cmluZyArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxpbmUgPSBmZ2V0cyhidWZmZXIyKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSBsaW5lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICBpZiAoXCIjXCIgPT09IGxpbmUuY2hhckF0KDApKSB7XG4gICAgICAgICAgaGVhZGVyLmNvbW1lbnRzICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZ2FtbWFfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLmdhbW1hID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZXhwb3N1cmUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdF9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9GT1JNQVQ7XG4gICAgICAgICAgaGVhZGVyLmZvcm1hdCA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZGltZW5zaW9uc19yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9ESU1FTlNJT05TO1xuICAgICAgICAgIGhlYWRlci5oZWlnaHQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIGhlYWRlci53aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUICYmIGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRElNRU5TSU9OUylcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJtaXNzaW5nIGZvcm1hdCBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0RJTUVOU0lPTlMpKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH0sIFJHQkVfUmVhZFBpeGVsc19STEUgPSBmdW5jdGlvbihidWZmZXIyLCB3LCBoKSB7XG4gICAgICBjb25zdCBzY2FubGluZV93aWR0aCA9IHc7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHJ1biBsZW5ndGggZW5jb2RpbmcgaXMgbm90IGFsbG93ZWQgc28gcmVhZCBmbGF0XG4gICAgICAgIHNjYW5saW5lX3dpZHRoIDwgOCB8fCBzY2FubGluZV93aWR0aCA+IDMyNzY3IHx8IC8vIHRoaXMgZmlsZSBpcyBub3QgcnVuIGxlbmd0aCBlbmNvZGVkXG4gICAgICAgIDIgIT09IGJ1ZmZlcjJbMF0gfHwgMiAhPT0gYnVmZmVyMlsxXSB8fCBidWZmZXIyWzJdICYgMTI4XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjYW5saW5lX3dpZHRoICE9PSAoYnVmZmVyMlsyXSA8PCA4IHwgYnVmZmVyMlszXSkpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwid3Jvbmcgc2NhbmxpbmUgd2lkdGhcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhX3JnYmEgPSBuZXcgVWludDhBcnJheSg0ICogdyAqIGgpO1xuICAgICAgaWYgKCFkYXRhX3JnYmEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfbWVtb3J5X2Vycm9yLCBcInVuYWJsZSB0byBhbGxvY2F0ZSBidWZmZXIgc3BhY2VcIik7XG4gICAgICB9XG4gICAgICBsZXQgb2Zmc2V0ID0gMCwgcG9zID0gMDtcbiAgICAgIGNvbnN0IHB0cl9lbmQgPSA0ICogc2NhbmxpbmVfd2lkdGg7XG4gICAgICBjb25zdCByZ2JlU3RhcnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHB0cl9lbmQpO1xuICAgICAgbGV0IG51bV9zY2FubGluZXMgPSBoO1xuICAgICAgd2hpbGUgKG51bV9zY2FubGluZXMgPiAwICYmIHBvcyA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBpZiAocG9zICsgNCA+IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmdiZVN0YXJ0WzBdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsxXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbMl0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzNdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIGlmICgyICE9IHJnYmVTdGFydFswXSB8fCAyICE9IHJnYmVTdGFydFsxXSB8fCAocmdiZVN0YXJ0WzJdIDw8IDggfCByZ2JlU3RhcnRbM10pICE9IHNjYW5saW5lX3dpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIHJnYmUgc2NhbmxpbmUgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHIgPSAwLCBjb3VudDtcbiAgICAgICAgd2hpbGUgKHB0ciA8IHB0cl9lbmQgJiYgcG9zIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgY291bnQgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICBjb25zdCBpc0VuY29kZWRSdW4gPSBjb3VudCA+IDEyODtcbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKVxuICAgICAgICAgICAgY291bnQgLT0gMTI4O1xuICAgICAgICAgIGlmICgwID09PSBjb3VudCB8fCBwdHIgKyBjb3VudCA+IHB0cl9lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcImJhZCBzY2FubGluZSBkYXRhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlVmFsdWUgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBzY2FubGluZV9idWZmZXJbcHRyKytdID0gYnl0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FubGluZV9idWZmZXIuc2V0KGJ1ZmZlcjIuc3ViYXJyYXkocG9zLCBwb3MgKyBjb3VudCksIHB0cik7XG4gICAgICAgICAgICBwdHIgKz0gY291bnQ7XG4gICAgICAgICAgICBwb3MgKz0gY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGwgPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQgb2ZmID0gMDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0XSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDFdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBudW1fc2NhbmxpbmVzLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YV9yZ2JhO1xuICAgIH07XG4gICAgY29uc3QgUkdCRUJ5dGVUb1JHQkZsb2F0ID0gZnVuY3Rpb24oc291cmNlQXJyYXksIHNvdXJjZU9mZnNldCwgZGVzdEFycmF5LCBkZXN0T2Zmc2V0KSB7XG4gICAgICBjb25zdCBlID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgM107XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGUgLSAxMjgpIC8gMjU1O1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAwXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDBdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDFdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAzXSA9IDE7XG4gICAgfTtcbiAgICBjb25zdCBSR0JFQnl0ZVRvUkdCSGFsZiA9IGZ1bmN0aW9uKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdO1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMl0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoMSk7XG4gICAgfTtcbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGJ5dGVBcnJheS5wb3MgPSAwO1xuICAgIGNvbnN0IHJnYmVfaGVhZGVyX2luZm8gPSBSR0JFX1JlYWRIZWFkZXIoYnl0ZUFycmF5KTtcbiAgICBpZiAoUkdCRV9SRVRVUk5fRkFJTFVSRSAhPT0gcmdiZV9oZWFkZXJfaW5mbykge1xuICAgICAgY29uc3QgdyA9IHJnYmVfaGVhZGVyX2luZm8ud2lkdGgsIGggPSByZ2JlX2hlYWRlcl9pbmZvLmhlaWdodCwgaW1hZ2VfcmdiYV9kYXRhID0gUkdCRV9SZWFkUGl4ZWxzX1JMRShieXRlQXJyYXkuc3ViYXJyYXkoYnl0ZUFycmF5LnBvcyksIHcsIGgpO1xuICAgICAgaWYgKFJHQkVfUkVUVVJOX0ZBSUxVUkUgIT09IGltYWdlX3JnYmFfZGF0YSkge1xuICAgICAgICBsZXQgZGF0YSwgdHlwZTtcbiAgICAgICAgbGV0IG51bUVsZW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNDtcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG51bUVsZW1lbnRzICogNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgUkdCRUJ5dGVUb1JHQkZsb2F0KGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGZsb2F0QXJyYXksIGogKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBmbG9hdEFycmF5O1xuICAgICAgICAgICAgdHlwZSA9IEZsb2F0VHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gaW1hZ2VfcmdiYV9kYXRhLmxlbmd0aCAvIDQ7XG4gICAgICAgICAgICBjb25zdCBoYWxmQXJyYXkgPSBuZXcgVWludDE2QXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgICAgICBSR0JFQnl0ZVRvUkdCSGFsZihpbWFnZV9yZ2JhX2RhdGEsIGogKiA0LCBoYWxmQXJyYXksIGogKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBoYWxmQXJyYXk7XG4gICAgICAgICAgICB0eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogdW5zdXBwb3J0ZWQgdHlwZTogXCIsIHRoaXMudHlwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGhlYWRlcjogcmdiZV9oZWFkZXJfaW5mby5zdHJpbmcsXG4gICAgICAgICAgZ2FtbWE6IHJnYmVfaGVhZGVyX2luZm8uZ2FtbWEsXG4gICAgICAgICAgZXhwb3N1cmU6IHJnYmVfaGVhZGVyX2luZm8uZXhwb3N1cmUsXG4gICAgICAgICAgdHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBzd2l0Y2ggKHRleHR1cmUudHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSAzZTM7XG4gICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICB0ZXh0dXJlLmZsaXBZID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJHQkVMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SR0JFTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIkRhdGFVdGlscyIsIkxpbmVhckZpbHRlciIsIlJHQkVMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJ0eXBlIiwicGFyc2UiLCJidWZmZXIiLCJSR0JFX1JFVFVSTl9GQUlMVVJFIiwicmdiZV9yZWFkX2Vycm9yIiwicmdiZV93cml0ZV9lcnJvciIsInJnYmVfZm9ybWF0X2Vycm9yIiwicmdiZV9tZW1vcnlfZXJyb3IiLCJyZ2JlX2Vycm9yIiwicmdiZV9lcnJvcl9jb2RlIiwibXNnIiwiY29uc29sZSIsImVycm9yIiwiUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSIsIlJHQkVfVkFMSURfRk9STUFUIiwiUkdCRV9WQUxJRF9ESU1FTlNJT05TIiwiTkVXTElORSIsImZnZXRzIiwiYnVmZmVyMiIsImxpbmVMaW1pdCIsImNvbnN1bWUiLCJjaHVua1NpemUiLCJwIiwicG9zIiwiaSIsImxlbiIsInMiLCJjaHVuayIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiVWludDE2QXJyYXkiLCJzdWJhcnJheSIsImluZGV4T2YiLCJieXRlTGVuZ3RoIiwibGVuZ3RoIiwic2xpY2UiLCJSR0JFX1JlYWRIZWFkZXIiLCJtYWdpY190b2tlbl9yZSIsImdhbW1hX3JlIiwiZXhwb3N1cmVfcmUiLCJmb3JtYXRfcmUiLCJkaW1lbnNpb25zX3JlIiwiaGVhZGVyIiwidmFsaWQiLCJzdHJpbmciLCJjb21tZW50cyIsInByb2dyYW10eXBlIiwiZm9ybWF0IiwiZ2FtbWEiLCJleHBvc3VyZSIsIndpZHRoIiwiaGVpZ2h0IiwibGluZSIsIm1hdGNoIiwiY2hhckF0IiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiUkdCRV9SZWFkUGl4ZWxzX1JMRSIsInciLCJoIiwic2NhbmxpbmVfd2lkdGgiLCJVaW50OEFycmF5IiwiZGF0YV9yZ2JhIiwib2Zmc2V0IiwicHRyX2VuZCIsInJnYmVTdGFydCIsInNjYW5saW5lX2J1ZmZlciIsIm51bV9zY2FubGluZXMiLCJwdHIiLCJjb3VudCIsImlzRW5jb2RlZFJ1biIsImJ5dGVWYWx1ZSIsInNldCIsImwiLCJvZmYiLCJSR0JFQnl0ZVRvUkdCRmxvYXQiLCJzb3VyY2VBcnJheSIsInNvdXJjZU9mZnNldCIsImRlc3RBcnJheSIsImRlc3RPZmZzZXQiLCJlIiwic2NhbGUiLCJNYXRoIiwicG93IiwiUkdCRUJ5dGVUb1JHQkhhbGYiLCJ0b0hhbGZGbG9hdCIsIm1pbiIsImJ5dGVBcnJheSIsInJnYmVfaGVhZGVyX2luZm8iLCJpbWFnZV9yZ2JhX2RhdGEiLCJkYXRhIiwibnVtRWxlbWVudHMiLCJmbG9hdEFycmF5IiwiRmxvYXQzMkFycmF5IiwiaiIsImhhbGZBcnJheSIsInNldERhdGFUeXBlIiwidmFsdWUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwiY29sb3JTcGFjZSIsImVuY29kaW5nIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9vYmplY3RzL0dyb3VuZFByb2plY3RlZEVudi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RjtBQUN4RixNQUFNSyxnQkFBZ0IsQ0FBQ0MsTUFBUUEsT0FBT0EsSUFBSUQsYUFBYTtBQUN2RCxNQUFNRSwyQkFBMkJQLHVDQUFJQTtJQUNuQ1EsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDNUIsSUFBSUMsSUFBSUM7UUFDUixNQUFNQyxZQUFZUixjQUFjSTtRQUNoQyxNQUFNSyxJQUFJLENBQUNGLEtBQUtDLFlBQVksQ0FBQ0YsS0FBS0YsUUFBUU0sS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssS0FBSyxHQUFHUCxRQUFRTSxLQUFLLENBQUNDLEtBQUssS0FBSyxPQUFPSixLQUFLO1FBQ3RILE1BQU1LLFdBQVdILElBQUk7UUFDckIsTUFBTUksVUFBVUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxJQUFJLENBQUNKO1FBQ3JDLE1BQU1LLFlBQVlILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTDtRQUM5QixNQUFNRixRQUFRLElBQUlHLEtBQUtLLEdBQUcsQ0FBQ0YsV0FBVyxLQUFLO1FBQzNDLE1BQU1HLFNBQVMsSUFBSUg7UUFDbkIsTUFBTUksVUFBVTtZQUNkYixZQUFZLDZCQUE2QjtZQUN6QyxDQUFDLDJCQUEyQixFQUFFLElBQUlHLE1BQU0sQ0FBQztZQUN6QyxDQUFDLDRCQUE0QixFQUFFLElBQUlTLE9BQU8sQ0FBQztZQUMzQyxDQUFDLHVCQUF1QixFQUFFUCxRQUFRLEVBQUUsQ0FBQztTQUN0QztRQUNELE1BQU1TLGVBQ0osUUFBUSxHQUNSLENBQUM7Ozs7Ozs7OztRQVNDLENBQUM7UUFFTCxNQUFNQyxpQkFBaUJGLFFBQVFHLElBQUksQ0FBQyxRQUFRLFFBQVEsR0FDcEQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQXFFaUIsRUFBRUMsU0FBUzdCLDJDQUFRQSxDQUFDOEIsT0FBTyxDQUFDLFFBQVEsUUFBUSxNQUFNLHdCQUF3QixxQkFBcUI7O1FBRTdHLENBQUM7UUFDTCxNQUFNQyxXQUFXO1lBQ2ZDLEtBQUs7Z0JBQUVDLE9BQU96QjtZQUFRO1lBQ3RCZ0IsUUFBUTtnQkFBRVMsT0FBTyxDQUFDeEIsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWUsTUFBTSxLQUFLO1lBQUc7WUFDbkVVLFFBQVE7Z0JBQUVELE9BQU8sQ0FBQ3hCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF5QixNQUFNLEtBQUs7WUFBSTtRQUN0RTtRQUNBLE1BQU1DLFdBQVcsSUFBSWxDLHNEQUFtQkEsQ0FBQyxHQUFHO1FBQzVDLE1BQU1tQyxXQUFXLElBQUlsQyxpREFBY0EsQ0FBQztZQUNsQzZCO1lBQ0FKO1lBQ0FEO1lBQ0FXLE1BQU1sQyw2Q0FBVUE7UUFDbEI7UUFDQSxLQUFLLENBQUNnQyxVQUFVQztJQUNsQjtJQUNBLElBQUlGLE9BQU9BLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDRyxNQUFNLENBQUNELEtBQUssR0FBR0M7SUFDeEM7SUFDQSxJQUFJQSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNFLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDRyxNQUFNLENBQUNELEtBQUs7SUFDNUM7SUFDQSxJQUFJVCxPQUFPQSxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDWSxRQUFRLENBQUNMLFFBQVEsQ0FBQ1AsTUFBTSxDQUFDUyxLQUFLLEdBQUdUO0lBQ3hDO0lBQ0EsSUFBSUEsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDWSxRQUFRLENBQUNMLFFBQVEsQ0FBQ1AsTUFBTSxDQUFDUyxLQUFLO0lBQzVDO0FBQ0Y7QUFHRSxDQUNGLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvb2JqZWN0cy9Hcm91bmRQcm9qZWN0ZWRFbnYuanM/MTEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZXNoLCBSRVZJU0lPTiwgSWNvc2FoZWRyb25HZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IGlzQ3ViZVRleHR1cmUgPSAoZGVmKSA9PiBkZWYgJiYgZGVmLmlzQ3ViZVRleHR1cmU7XG5jbGFzcyBHcm91bmRQcm9qZWN0ZWRFbnYgZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaXNDdWJlTWFwID0gaXNDdWJlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBjb25zdCB3ID0gKF9iID0gaXNDdWJlTWFwID8gKF9hID0gdGV4dHVyZS5pbWFnZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpZHRoIDogdGV4dHVyZS5pbWFnZS53aWR0aCkgIT0gbnVsbCA/IF9iIDogMTAyNDtcbiAgICBjb25zdCBjdWJlU2l6ZSA9IHcgLyA0O1xuICAgIGNvbnN0IF9sb2RNYXggPSBNYXRoLmZsb29yKE1hdGgubG9nMihjdWJlU2l6ZSkpO1xuICAgIGNvbnN0IF9jdWJlU2l6ZSA9IE1hdGgucG93KDIsIF9sb2RNYXgpO1xuICAgIGNvbnN0IHdpZHRoID0gMyAqIE1hdGgubWF4KF9jdWJlU2l6ZSwgMTYgKiA3KTtcbiAgICBjb25zdCBoZWlnaHQgPSA0ICogX2N1YmVTaXplO1xuICAgIGNvbnN0IGRlZmluZXMgPSBbXG4gICAgICBpc0N1YmVNYXAgPyBcIiNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRVwiIDogXCJcIixcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9URVhFTF9XSURUSCAkezEgLyB3aWR0aH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX0hFSUdIVCAkezEgLyBoZWlnaHR9YCxcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9NQVhfTUlQICR7X2xvZE1heH0uMGBcbiAgICBdO1xuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gKCBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKSApO1xuICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuICAgICAgICB9XG4gICAgICAgIGBcbiAgICApO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gZGVmaW5lcy5qb2luKFwiXFxuXCIpICsgLyogZ2xzbCAqL1xuICAgIGBcbiAgICAgICAgI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgaGVpZ2h0O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGFuZ2xlO1xuICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSBtYXA7XG4gICAgICAgICNlbHNlXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XG4gICAgICAgICNlbmRpZlxuICAgICAgICAvLyBGcm9tOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNHRzQkQ3XG4gICAgICAgIGZsb2F0IGRpc2tJbnRlcnNlY3RXaXRoQmFja0ZhY2VDdWxsaW5nKCB2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWMzIGMsIHZlYzMgbiwgZmxvYXQgciApIFxuICAgICAgICB7XG4gICAgICAgICAgICBmbG9hdCBkID0gZG90ICggcmQsIG4gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGQgPiAwLjAgKSB7IHJldHVybiAxZTY7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmVjMyAgbyA9IHJvIC0gYztcbiAgICAgICAgICAgIGZsb2F0IHQgPSAtIGRvdCggbiwgbyApIC8gZDtcbiAgICAgICAgICAgIHZlYzMgIHEgPSBvICsgcmQgKiB0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKCBkb3QoIHEsIHEgKSA8IHIgKiByICkgPyB0IDogMWU2O1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9pbnRlcnNlY3RvcnMvaW50ZXJzZWN0b3JzLmh0bVxuICAgICAgICBmbG9hdCBzcGhlcmVJbnRlcnNlY3QoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgY2UsIGZsb2F0IHJhICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgb2MgPSBybyAtIGNlO1xuICAgICAgICAgICAgZmxvYXQgYiA9IGRvdCggb2MsIHJkICk7XG4gICAgICAgICAgICBmbG9hdCBjID0gZG90KCBvYywgb2MgKSAtIHJhICogcmE7XG4gICAgICAgICAgICBmbG9hdCBoID0gYiAqIGIgLSBjO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggaCA8IDAuMCApIHsgcmV0dXJuIC0xLjA7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaCA9IHNxcnQoIGggKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIC0gYiArIGg7XG4gICAgICAgIH1cbiAgICAgICAgdmVjMyBwcm9qZWN0KCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgcCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcbiAgICAgICAgICAgIHZlYzMgY2FtUG9zID0gY2FtZXJhUG9zaXRpb247XG4gICAgICAgICAgICBjYW1Qb3MueSAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBmbG9hdCBpbnRlcnNlY3Rpb24gPSBzcGhlcmVJbnRlcnNlY3QoIGNhbVBvcywgcCwgdmVjMyggMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgaWYoIGludGVyc2VjdGlvbiA+IDAuMCApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2ZWMzIGggPSB2ZWMzKCAwLjAsIC0gaGVpZ2h0LCAwLjAgKTtcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnRlcnNlY3Rpb24yID0gZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIGNhbVBvcywgcCwgaCwgdmVjMyggMC4wLCAxLjAsIDAuMCApLCByYWRpdXMgKTtcbiAgICAgICAgICAgICAgICBwID0gKCBjYW1Qb3MgKyBtaW4oIGludGVyc2VjdGlvbiwgaW50ZXJzZWN0aW9uMiApICogcCApIC8gcmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gdmVjMyggMC4wLCAxLjAsIDAuMCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgI2luY2x1ZGUgPGNvbW1vbj5cbiAgICAgICAgI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cbiAgICAgICAgdm9pZCBtYWluKCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgcHJvamVjdGVkV29ybGRQb3NpdGlvbiA9IHByb2plY3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZUN1YmUoIG1hcCwgcHJvamVjdGVkV29ybGRQb3NpdGlvbiApLnJnYjtcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHByb2plY3RlZFdvcmxkUG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMyIHV2ID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XG4gICAgICAgICAgICAgICAgdmVjMyBvdXRjb2xvciA9IHRleHR1cmUyRCggbWFwLCB1diApLnJnYjtcbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Y29sb3IsIDEuMCApO1xuICAgICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuICAgICAgICAgICAgI2luY2x1ZGUgPCR7cGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkgPj0gMTU0ID8gXCJjb2xvcnNwYWNlX2ZyYWdtZW50XCIgOiBcImVuY29kaW5nc19mcmFnbWVudFwifT5cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgbWFwOiB7IHZhbHVlOiB0ZXh0dXJlIH0sXG4gICAgICBoZWlnaHQ6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgfHwgMTUgfSxcbiAgICAgIHJhZGl1czogeyB2YWx1ZTogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSB8fCAxMDAgfVxuICAgIH07XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeSgxLCAxNik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXMsXG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIHNpZGU6IERvdWJsZVNpZGVcbiAgICB9KTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICB9XG4gIHNldCByYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gIH1cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gIH1cbiAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZSA9IGhlaWdodDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgR3JvdW5kUHJvamVjdGVkRW52XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdW5kUHJvamVjdGVkRW52LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1lc2giLCJSRVZJU0lPTiIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJTaGFkZXJNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJpc0N1YmVUZXh0dXJlIiwiZGVmIiwiR3JvdW5kUHJvamVjdGVkRW52IiwiY29uc3RydWN0b3IiLCJ0ZXh0dXJlIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJpc0N1YmVNYXAiLCJ3IiwiaW1hZ2UiLCJ3aWR0aCIsImN1YmVTaXplIiwiX2xvZE1heCIsIk1hdGgiLCJmbG9vciIsImxvZzIiLCJfY3ViZVNpemUiLCJwb3ciLCJtYXgiLCJoZWlnaHQiLCJkZWZpbmVzIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJqb2luIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwidW5pZm9ybXMiLCJtYXAiLCJ2YWx1ZSIsInJhZGl1cyIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJzaWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/types/helpers.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/types/helpers.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi90eXBlcy9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxhQUFhLENBQUNDLEtBQUtDLE1BQVFELEdBQUcsQ0FBQ0MsSUFBSTtBQUd2QyxDQUNGLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2JvaWxlcnBsYXRlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcz80ZDYyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0V2l0aEtleSIsIm9iaiIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBdU07QUFDdEo7QUFDakQsTUFBTVUsd0JBQXdCLENBQUNDLFlBQVlDO0lBQ3pDLE1BQU1DLFlBQVlGLFVBQVUsQ0FBQyxFQUFFLENBQUNHLEtBQUssS0FBSztJQUMxQyxNQUFNQyxpQkFBaUIsSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDUCxVQUFVLENBQUMsRUFBRSxDQUFDUSxVQUFVO0lBQ25FLE1BQU1DLHNCQUFzQixJQUFJSixJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNVLGVBQWU7SUFDN0UsTUFBTUYsYUFBYSxDQUFDO0lBQ3BCLE1BQU1FLGtCQUFrQixDQUFDO0lBQ3pCLE1BQU1DLHVCQUF1QlgsVUFBVSxDQUFDLEVBQUUsQ0FBQ1csb0JBQW9CO0lBQy9ELE1BQU1DLGlCQUFpQixJQUFJdkIsaURBQWNBO0lBQ3pDLElBQUl3QixTQUFTO0lBQ2JiLFdBQVdjLE9BQU8sQ0FBQyxDQUFDQyxNQUFNQztRQUN4QixJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSWYsY0FBZWEsQ0FBQUEsS0FBS1osS0FBSyxLQUFLLElBQUcsR0FBSTtZQUN2Q2UsUUFBUUMsS0FBSyxDQUNYLHVGQUF1RkgsSUFBSTtZQUU3RixPQUFPO1FBQ1Q7UUFDQSxJQUFLLElBQUlJLFFBQVFMLEtBQUtQLFVBQVUsQ0FBRTtZQUNoQyxJQUFJLENBQUNKLGVBQWVpQixHQUFHLENBQUNELE9BQU87Z0JBQzdCRixRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJLGtFQUFrRUksT0FBTztnQkFFdEssT0FBTztZQUNUO1lBQ0EsSUFBSVosVUFBVSxDQUFDWSxLQUFLLEtBQUssS0FBSyxHQUFHO2dCQUMvQlosVUFBVSxDQUFDWSxLQUFLLEdBQUcsRUFB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Y2s6Ly9ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanM/NzIxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFZlY3RvcjMsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IGdldFdpdGhLZXkgfSBmcm9tIFwiLi4vdHlwZXMvaGVscGVycy5qc1wiO1xuY29uc3QgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzID0gKGdlb21ldHJpZXMsIHVzZUdyb3VwcykgPT4ge1xuICBjb25zdCBpc0luZGV4ZWQgPSBnZW9tZXRyaWVzWzBdLmluZGV4ICE9PSBudWxsO1xuICBjb25zdCBhdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5hdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0ubW9ycGhBdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cmllc1swXS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3QgbWVyZ2VkR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSwgaSkgPT4ge1xuICAgIGxldCBhdHRyaWJ1dGVzQ291bnQgPSAwO1xuICAgIGlmIChpc0luZGV4ZWQgIT09IChnZW9tLmluZGV4ICE9PSBudWxsKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghYXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgJy4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIFwiJyArIG5hbWUgKyAnXCIgYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLmF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgYXR0cmlidXRlc0NvdW50Kys7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzQ291bnQgIT09IGF0dHJpYnV0ZXNVc2VkLnNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBNYWtlIHN1cmUgYWxsIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUgIT09IGdlb20ubW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAubW9ycGhUYXJnZXRzUmVsYXRpdmUgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLm1vcnBoQXR0cmlidXRlcykge1xuICAgICAgaWYgKCFtb3JwaEF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAgLm1vcnBoQXR0cmlidXRlcyBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMClcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLm1vcnBoQXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhID0gbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgfHwgW107XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEucHVzaChnZW9tLnVzZXJEYXRhKTtcbiAgICBpZiAodXNlR3JvdXBzKSB7XG4gICAgICBsZXQgY291bnQ7XG4gICAgICBpZiAoZ2VvbS5pbmRleCkge1xuICAgICAgICBjb3VudCA9IGdlb20uaW5kZXguY291bnQ7XG4gICAgICB9IGVsc2UgaWYgKGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gVGhlIGdlb21ldHJ5IG11c3QgaGF2ZSBlaXRoZXIgYW4gaW5kZXggb3IgYSBwb3NpdGlvbiBhdHRyaWJ1dGVcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5LmFkZEdyb3VwKG9mZnNldCwgY291bnQsIGkpO1xuICAgICAgb2Zmc2V0ICs9IGNvdW50O1xuICAgIH1cbiAgfSk7XG4gIGlmIChpc0luZGV4ZWQpIHtcbiAgICBsZXQgaW5kZXhPZmZzZXQgPSAwO1xuICAgIGNvbnN0IG1lcmdlZEluZGV4ID0gW107XG4gICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGdlb20uaW5kZXg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4LmNvdW50OyArK2opIHtcbiAgICAgICAgbWVyZ2VkSW5kZXgucHVzaChpbmRleC5nZXRYKGopICsgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaW5kZXhPZmZzZXQgKz0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgIH0pO1xuICAgIG1lcmdlZEdlb21ldHJ5LnNldEluZGV4KG1lcmdlZEluZGV4KTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgaWYgKCFtZXJnZWRBdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIGF0dHJpYnV0ZS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbWVyZ2VkQXR0cmlidXRlKTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgIGNvbnN0IG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXVswXS5sZW5ndGg7XG4gICAgaWYgKG51bU1vcnBoVGFyZ2V0cyA9PT0gMClcbiAgICAgIGJyZWFrO1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyA9IG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyB8fCB7fTtcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgKytpKSB7XG4gICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cmlidXRlc1tuYW1lXS5sZW5ndGg7ICsraikge1xuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlLnB1c2gobW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZE1vcnBoQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UpO1xuICAgICAgaWYgKCFtZXJnZWRNb3JwaEF0dHJpYnV0ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIG1vcnBoQXR0cmlidXRlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2gobWVyZ2VkTW9ycGhBdHRyaWJ1dGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkR2VvbWV0cnk7XG59O1xuY29uc3QgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBpdGVtU2l6ZSA9IHZvaWQgMDtcbiAgbGV0IG5vcm1hbGl6ZWQgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApIHtcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuYXJyYXkgbXVzdCBiZSBvZiBjb25zaXN0ZW50IGFycmF5IHR5cGVzIGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpdGVtU2l6ZSA9PT0gdm9pZCAwKVxuICAgICAgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuICAgIGlmIChpdGVtU2l6ZSAhPT0gYXR0ci5pdGVtU2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkID09PSB2b2lkIDApXG4gICAgICBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuICAgIGlmIChub3JtYWxpemVkICE9PSBhdHRyLm5vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICB9KTtcbiAgaWYgKFR5cGVkQXJyYXkgJiYgaXRlbVNpemUpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGFycmF5LnNldChhdHRyLmFycmF5LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cbn07XG5jb25zdCBpbnRlcmxlYXZlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBsZXQgc3RyaWRlID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMClcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF0dHJpYnV0ZUJ1ZmZlcnMgb2YgZGlmZmVyZW50IHR5cGVzIGNhbm5vdCBiZSBpbnRlcmxlYXZlZFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyaWJ1dGUuYXJyYXkubGVuZ3RoO1xuICAgIHN0cmlkZSArPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gIH1cbiAgY29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIobmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpLCBzdHJpZGUpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBjb25zdCBzZXR0ZXJzID0gW1wic2V0WFwiLCBcInNldFlcIiwgXCJzZXRaXCIsIFwic2V0V1wiXTtcbiAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgY29uc3QgY291bnQgPSBhdHRyaWJ1dGUuY291bnQ7XG4gICAgY29uc3QgaWJhID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzLnB1c2goaWJhKTtcbiAgICBvZmZzZXQgKz0gaXRlbVNpemU7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0V2l0aEtleShpYmEsIHNldHRlcnNba10pO1xuICAgICAgICBjb25zdCBnZXQgPSBnZXRXaXRoS2V5KGF0dHJpYnV0ZSwgZ2V0dGVyc1trXSk7XG4gICAgICAgIHNldChjLCBnZXQoYykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZXNVc2VkKGdlb21ldHJ5KSB7XG4gIGxldCBtZW0gPSAwO1xuICBmb3IgKGxldCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIG1lbSArPSBhdHRyLmNvdW50ICogYXR0ci5pdGVtU2l6ZSAqIGF0dHIuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIG1lbSArPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCAqIGluZGljZXMuaXRlbVNpemUgKiBpbmRpY2VzLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcbiAgcmV0dXJuIG1lbTtcbn1cbmZ1bmN0aW9uIG1lcmdlVmVydGljZXMoZ2VvbWV0cnksIHRvbGVyYW5jZSA9IDFlLTQpIHtcbiAgdG9sZXJhbmNlID0gTWF0aC5tYXgodG9sZXJhbmNlLCBOdW1iZXIuRVBTSUxPTik7XG4gIGNvbnN0IGhhc2hUb0luZGV4ID0ge307XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgY29uc3QgdmVydGV4Q291bnQgPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCA6IHBvc2l0aW9ucy5jb3VudDtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoZ2VvbWV0cnkuYXR0cmlidXRlcyk7XG4gIGNvbnN0IGF0dHJBcnJheXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyc0FycmF5cyA9IHt9O1xuICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBhdHRyQXJyYXlzW25hbWVdID0gW107XG4gICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgIG1vcnBoQXR0cnNBcnJheXNbbmFtZV0gPSBuZXcgQXJyYXkobW9ycGhBdHRyLmxlbmd0aCkuZmlsbCgwKS5tYXAoKCkgPT4gW10pO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsU2hpZnQgPSBNYXRoLmxvZzEwKDEgLyB0b2xlcmFuY2UpO1xuICBjb25zdCBzaGlmdE11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFNoaWZ0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbmRpY2VzID8gaW5kaWNlcy5nZXRYKGkpIDogaTtcbiAgICBsZXQgaGFzaCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGhhc2ggKz0gYCR7fn4oYXR0cmlidXRlW2dldHRlcnNba11dKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcil9LGA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNoIGluIGhhc2hUb0luZGV4KSB7XG4gICAgICBuZXdJbmRpY2VzLnB1c2goaGFzaFRvSW5kZXhbaGFzaF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgICAgY29uc3QgbmV3YXJyYXkgPSBhdHRyQXJyYXlzW25hbWVdO1xuICAgICAgICBjb25zdCBuZXdNb3JwaEFycmF5cyA9IG1vcnBoQXR0cnNBcnJheXNbbmFtZV07XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGdldHRlckZ1bmMgPSBnZXR0ZXJzW2tdO1xuICAgICAgICAgIG5ld2FycmF5LnB1c2goYXR0cmlidXRlW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgICAgICAgZm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcbiAgICAgICAgICAgICAgbmV3TW9ycGhBcnJheXNbbV0ucHVzaChtb3JwaEF0dHJbbV1bZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhc2hUb0luZGV4W2hhc2hdID0gbmV4dEluZGV4O1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKG5leHRJbmRleCk7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBvbGRBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IoYXR0ckFycmF5c1tuYW1lXSk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIsIG9sZEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlKTtcbiAgICBpZiAobmFtZSBpbiBtb3JwaEF0dHJzQXJyYXlzKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cnNBcnJheXNbbmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgb2xkTW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal07XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgb2xkTW9ycGhBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IobW9ycGhBdHRyc0FycmF5c1tuYW1lXVtqXSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIyLCBvbGRNb3JwaEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkTW9ycGhBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgICAgIHJlc3VsdC5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal0gPSBtb3JwaEF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzdWx0LnNldEluZGV4KG5ld0luZGljZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZShnZW9tZXRyeSwgZHJhd01vZGUpIHtcbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZXNEcmF3TW9kZSkge1xuICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBHZW9tZXRyeSBhbHJlYWR5IGRlZmluZWQgYXMgdHJpYW5nbGVzLlwiKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlIHx8IGRyYXdNb2RlID09PSBUcmlhbmdsZVN0cmlwRHJhd01vZGUpIHtcbiAgICBsZXQgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkrKykge1xuICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyeS5zZXRJbmRleChpbmRpY2VzKTtcbiAgICAgICAgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoMCkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMubGVuZ3RoIC8gMyAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5hYmxlIHRvIGdlbmVyYXRlIGNvcnJlY3QgYW1vdW50IG9mIHRyaWFuZ2xlcy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBuZXdHZW9tZXRyeS5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgICBuZXdHZW9tZXRyeS5jbGVhckdyb3VwcygpO1xuICAgIHJldHVybiBuZXdHZW9tZXRyeTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVua25vd24gZHJhdyBtb2RlOlwiLCBkcmF3TW9kZSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMob2JqZWN0KSB7XG4gIGlmIChvYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBCdWZmZXJHZW9tZXRyeS5cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgX3ZBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhDID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKG9iamVjdDIsIG1hdGVyaWFsMiwgYXR0cmlidXRlLCBtb3JwaEF0dHJpYnV0ZSwgbW9ycGhUYXJnZXRzUmVsYXRpdmUyLCBhMiwgYjIsIGMyLCBtb2RpZmllZEF0dHJpYnV0ZUFycmF5KSB7XG4gICAgX3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBhMik7XG4gICAgX3ZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBiMik7XG4gICAgX3ZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBjMik7XG4gICAgY29uc3QgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Mi5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbWF0ZXJpYWwyLm1vcnBoVGFyZ2V0cyAmJiBtb3JwaEF0dHJpYnV0ZSAmJiBtb3JwaEluZmx1ZW5jZXNcbiAgICApIHtcbiAgICAgIF9tb3JwaEEuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQi5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhDLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgaWwyID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpMiA8IGlsMjsgaTIrKykge1xuICAgICAgICBjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaTJdO1xuICAgICAgICBjb25zdCBtb3JwaCA9IG1vcnBoQXR0cmlidXRlW2kyXTtcbiAgICAgICAgaWYgKGluZmx1ZW5jZSA9PT0gMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgX3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGEyKTtcbiAgICAgICAgX3RlbXBCLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGIyKTtcbiAgICAgICAgX3RlbXBDLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGMyKTtcbiAgICAgICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlMikge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQS5zdWIoX3ZBKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIuc3ViKF92QiksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLnN1YihfdkMpLCBpbmZsdWVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfdkEuYWRkKF9tb3JwaEEpO1xuICAgICAgX3ZCLmFkZChfbW9ycGhCKTtcbiAgICAgIF92Qy5hZGQoX21vcnBoQyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QyLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShhMiwgX3ZBKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShiMiwgX3ZCKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShjMiwgX3ZDKTtcbiAgICB9XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAwXSA9IF92QS54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMV0gPSBfdkEueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDJdID0gX3ZBLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAwXSA9IF92Qi54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMV0gPSBfdkIueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDJdID0gX3ZCLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAwXSA9IF92Qy54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMV0gPSBfdkMueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDJdID0gX3ZDLno7XG4gIH1cbiAgY29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gIGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuICBsZXQgYSwgYiwgYztcbiAgY29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcbiAgY29uc3QgbW9ycGhOb3JtYWwgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgY29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuICBsZXQgaSwgaiwgaWwsIGpsO1xuICBsZXQgZ3JvdXAsIGdyb3VwTWF0ZXJpYWw7XG4gIGxldCBzdGFydCwgZW5kO1xuICBjb25zdCBtb2RpZmllZFBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIHBvc2l0aW9uQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgY29uc3QgbW9kaWZpZWROb3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbEF0dHJpYnV0ZS5jb3VudCAqIG5vcm1hbEF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGluZGV4LmdldFgoaik7XG4gICAgICAgICAgYiA9IGluZGV4LmdldFgoaiArIDEpO1xuICAgICAgICAgIGMgPSBpbmRleC5nZXRYKGogKyAyKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGluZGV4LmdldFgoaSk7XG4gICAgICAgIGIgPSBpbmRleC5nZXRYKGkgKyAxKTtcbiAgICAgICAgYyA9IGluZGV4LmdldFgoaSArIDIpO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gajtcbiAgICAgICAgICBiID0gaiArIDE7XG4gICAgICAgICAgYyA9IGogKyAyO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaTtcbiAgICAgICAgYiA9IGkgKyAxO1xuICAgICAgICBjID0gaSArIDI7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkUG9zaXRpb24sIDMpO1xuICBjb25zdCBtb3JwaGVkTm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWROb3JtYWwsIDMpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZVxuICB9O1xufVxuZnVuY3Rpb24gdG9DcmVhc2VkTm9ybWFscyhnZW9tZXRyeSwgY3JlYXNlQW5nbGUgPSBNYXRoLlBJIC8gMykge1xuICBjb25zdCBjcmVhc2VEb3QgPSBNYXRoLmNvcyhjcmVhc2VBbmdsZSk7XG4gIGNvbnN0IGhhc2hNdWx0aXBsaWVyID0gKDEgKyAxZS0xMCkgKiAxMDA7XG4gIGNvbnN0IHZlcnRzID0gW25ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCldO1xuICBjb25zdCB0ZW1wVmVjMSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBWZWMyID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0gPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybTIgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBoYXNoVmVydGV4KHYpIHtcbiAgICBjb25zdCB4ID0gfn4odi54ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHkgPSB+fih2LnkgKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeiA9IH5+KHYueiAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICByZXR1cm4gYCR7eH0sJHt5fSwke3p9YDtcbiAgfVxuICBjb25zdCByZXN1bHRHZW9tZXRyeSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkudG9Ob25JbmRleGVkKCkgOiBnZW9tZXRyeTtcbiAgY29uc3QgcG9zQXR0ciA9IHJlc3VsdEdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgY29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBpZiAoIShoYXNoIGluIHZlcnRleE1hcCkpIHtcbiAgICAgICAgdmVydGV4TWFwW2hhc2hdID0gW107XG4gICAgICB9XG4gICAgICB2ZXJ0ZXhNYXBbaGFzaF0ucHVzaChub3JtYWwpO1xuICAgIH1cbiAgfVxuICBjb25zdCBub3JtYWxBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocG9zQXR0ci5jb3VudCAqIDMpO1xuICBjb25zdCBub3JtQXR0ciA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXJyYXksIDMsIGZhbHNlKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIHRlbXBOb3JtLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGNvbnN0IG90aGVyTm9ybWFscyA9IHZlcnRleE1hcFtoYXNoXTtcbiAgICAgIHRlbXBOb3JtMi5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBrID0gMCwgbGsgPSBvdGhlck5vcm1hbHMubGVuZ3RoOyBrIDwgbGs7IGsrKykge1xuICAgICAgICBjb25zdCBvdGhlck5vcm0gPSBvdGhlck5vcm1hbHNba107XG4gICAgICAgIGlmICh0ZW1wTm9ybS5kb3Qob3RoZXJOb3JtKSA+IGNyZWFzZURvdCkge1xuICAgICAgICAgIHRlbXBOb3JtMi5hZGQob3RoZXJOb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcE5vcm0yLm5vcm1hbGl6ZSgpO1xuICAgICAgbm9ybUF0dHIuc2V0WFlaKGkzICsgbiwgdGVtcE5vcm0yLngsIHRlbXBOb3JtMi55LCB0ZW1wTm9ybTIueik7XG4gICAgfVxuICB9XG4gIHJlc3VsdEdlb21ldHJ5LnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBub3JtQXR0cik7XG4gIHJldHVybiByZXN1bHRHZW9tZXRyeTtcbn1cbmV4cG9ydCB7XG4gIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyxcbiAgZXN0aW1hdGVCeXRlc1VzZWQsXG4gIGludGVybGVhdmVBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyR2VvbWV0cmllcyxcbiAgbWVyZ2VWZXJ0aWNlcyxcbiAgdG9DcmVhc2VkTm9ybWFscyxcbiAgdG9UcmlhbmdsZXNEcmF3TW9kZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlckdlb21ldHJ5VXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsiQnVmZmVyR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJJbnRlcmxlYXZlZEJ1ZmZlciIsIkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiVHJpYW5nbGVzRHJhd01vZGUiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVmVjdG9yMyIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJnZXRXaXRoS2V5IiwibWVyZ2VCdWZmZXJHZW9tZXRyaWVzIiwiZ2VvbWV0cmllcyIsInVzZUdyb3VwcyIsImlzSW5kZXhlZCIsImluZGV4IiwiYXR0cmlidXRlc1VzZWQiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwiYXR0cmlidXRlcyIsIm1vcnBoQXR0cmlidXRlc1VzZWQiLCJtb3JwaEF0dHJpYnV0ZXMiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZSIsIm1lcmdlZEdlb21ldHJ5Iiwib2Zmc2V0IiwiZm9yRWFjaCIsImdlb20iLCJpIiwiYXR0cmlidXRlc0NvdW50IiwiY29uc29sZSIsImVycm9yIiwibmFtZSIsImhhcyIsInB1c2giLCJzaXplIiwidXNlckRhdGEiLCJtZXJnZWRVc2VyRGF0YSIsImNvdW50IiwicG9zaXRpb24iLCJhZGRHcm91cCIsImluZGV4T2Zmc2V0IiwibWVyZ2VkSW5kZXgiLCJqIiwiZ2V0WCIsInNldEluZGV4IiwibWVyZ2VkQXR0cmlidXRlIiwibWVyZ2VCdWZmZXJBdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwibnVtTW9ycGhUYXJnZXRzIiwibGVuZ3RoIiwibW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSIsIm1lcmdlZE1vcnBoQXR0cmlidXRlIiwiVHlwZWRBcnJheSIsIml0ZW1TaXplIiwibm9ybWFsaXplZCIsImFycmF5TGVuZ3RoIiwiYXR0ciIsImFycmF5IiwiY29uc3RydWN0b3IiLCJzZXQiLCJpbnRlcmxlYXZlQXR0cmlidXRlcyIsInN0cmlkZSIsImwiLCJhdHRyaWJ1dGUiLCJpbnRlcmxlYXZlZEJ1ZmZlciIsInJlcyIsImdldHRlcnMiLCJzZXR0ZXJzIiwiaWJhIiwiYyIsImsiLCJnZXQiLCJlc3RpbWF0ZUJ5dGVzVXNlZCIsImdlb21ldHJ5IiwibWVtIiwiZ2V0QXR0cmlidXRlIiwiQllURVNfUEVSX0VMRU1FTlQiLCJpbmRpY2VzIiwiZ2V0SW5kZXgiLCJtZXJnZVZlcnRpY2VzIiwidG9sZXJhbmNlIiwiTWF0aCIsIm1heCIsIk51bWJlciIsIkVQU0lMT04iLCJoYXNoVG9JbmRleCIsInBvc2l0aW9ucyIsInZlcnRleENvdW50IiwibmV4dEluZGV4IiwiYXR0cmlidXRlTmFtZXMiLCJhdHRyQXJyYXlzIiwibW9ycGhBdHRyc0FycmF5cyIsIm5ld0luZGljZXMiLCJtb3JwaEF0dHIiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJkZWNpbWFsU2hpZnQiLCJsb2cxMCIsInNoaWZ0TXVsdGlwbGllciIsInBvdyIsImhhc2giLCJuZXdhcnJheSIsIm5ld01vcnBoQXJyYXlzIiwiZ2V0dGVyRnVuYyIsIm0iLCJtbCIsInJlc3VsdCIsImNsb25lIiwib2xkQXR0cmlidXRlIiwiYnVmZmVyIiwib2xkTW9ycGhBdHRyaWJ1dGUiLCJidWZmZXIyIiwibW9ycGhBdHRyaWJ1dGUiLCJ0b1RyaWFuZ2xlc0RyYXdNb2RlIiwiZHJhd01vZGUiLCJ3YXJuIiwibnVtYmVyT2ZUcmlhbmdsZXMiLCJuZXdHZW9tZXRyeSIsImNsZWFyR3JvdXBzIiwiY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzIiwib2JqZWN0IiwiaXNCdWZmZXJHZW9tZXRyeSIsIl92QSIsIl92QiIsIl92QyIsIl90ZW1wQSIsIl90ZW1wQiIsIl90ZW1wQyIsIl9tb3JwaEEiLCJfbW9ycGhCIiwiX21vcnBoQyIsIl9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YSIsIm9iamVjdDIiLCJtYXRlcmlhbDIiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZTIiLCJhMiIsImIyIiwiYzIiLCJtb2RpZmllZEF0dHJpYnV0ZUFycmF5IiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIm1vcnBoSW5mbHVlbmNlcyIsIm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyIsIm1vcnBoVGFyZ2V0cyIsImkyIiwiaWwyIiwiaW5mbHVlbmNlIiwibW9ycGgiLCJhZGRTY2FsZWRWZWN0b3IiLCJzdWIiLCJhZGQiLCJpc1NraW5uZWRNZXNoIiwiYm9uZVRyYW5zZm9ybSIsIngiLCJ5IiwieiIsIm1hdGVyaWFsIiwiYSIsImIiLCJwb3NpdGlvbkF0dHJpYnV0ZSIsIm1vcnBoUG9zaXRpb24iLCJub3JtYWxBdHRyaWJ1dGUiLCJub3JtYWwiLCJtb3JwaE5vcm1hbCIsImdyb3VwcyIsImRyYXdSYW5nZSIsImlsIiwiamwiLCJncm91cCIsImdyb3VwTWF0ZXJpYWwiLCJzdGFydCIsImVuZCIsIm1vZGlmaWVkUG9zaXRpb24iLCJGbG9hdDMyQXJyYXkiLCJtb2RpZmllZE5vcm1hbCIsImlzQXJyYXkiLCJtYXRlcmlhbEluZGV4IiwibWluIiwibW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlIiwibW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSIsInRvQ3JlYXNlZE5vcm1hbHMiLCJjcmVhc2VBbmdsZSIsIlBJIiwiY3JlYXNlRG90IiwiY29zIiwiaGFzaE11bHRpcGxpZXIiLCJ2ZXJ0cyIsInRlbXBWZWMxIiwidGVtcFZlYzIiLCJ0ZW1wTm9ybSIsInRlbXBOb3JtMiIsImhhc2hWZXJ0ZXgiLCJ2IiwicmVzdWx0R2VvbWV0cnkiLCJ0b05vbkluZGV4ZWQiLCJwb3NBdHRyIiwidmVydGV4TWFwIiwiaTMiLCJzdWJWZWN0b3JzIiwiY3Jvc3NWZWN0b3JzIiwibm9ybWFsaXplIiwibiIsInZlcnQiLCJub3JtYWxBcnJheSIsIm5vcm1BdHRyIiwib3RoZXJOb3JtYWxzIiwibGsiLCJvdGhlck5vcm0iLCJkb3QiLCJzZXRYWVoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;